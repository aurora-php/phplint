<HTML>
<HEAD>
<TITLE>PHPLint Reference Manual</TITLE>
<META name=description content="PHPLint Reference Manual">
<META name=author      content="icosaedro.it di Umberto Salsi">
<META name=owner       content="icosaedro.it di Umberto Salsi">
<META HTTP-EQUIV="Content-Language"    content="en">
<LINK rel='SHORTCUT ICON' HREF='/favicon.ico'>
<LINK rel=stylesheet type='text/css' href='/styles.css'>
</HEAD><BODY><pre>


</pre>
<center>
<img src="phplint.png">
</center>
<pre>

</pre>
<h1 align=center>PHPLint Reference Manual</h1>
<center><i>PHP source parser and validator<br>with extended syntax</i></center>
<pre>


</pre>
<center>
Version: <b><!--VERSION_START-->1.1_20130803
<!--VERSION_END--></b>
<br>Copyright 2012 by icosaedro.it di Umberto Salsi
<br><code>phplint@icosaedro.it</code>
<br><code>www.icosaedro.it/phplint/</code>
</center>
<pre>

</pre>
<h2>Contents</h2>
&emsp;&emsp;&emsp;&emsp;<a href='#introduction-introduction'>Introduction</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#basicfeatures-basic-features'>Basic features</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#packages-packages'>Packages</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#packages-modules-libraries-and-programs'>Modules, libraries and programs</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#packages-items-phplint-collects-from-parsed-packages'>Items PHPLint collects from parsed packages</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#packages-general-structure-of-a-package'>General structure of a package</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#importingmodules-importing-modules'>Importing modules</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#importingpackages-importing-packages'>Importing packages</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#autoload-autoloading-classes'>Autoloading classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#autoload-the-autoload-magic-function'>The __autoload() magic function</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#autoload-resolution-schema-with-namespaces'>Resolution schema with namespaces</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#autoload-general-form-of-the-autoload-pragma'>General form of the autoload pragma</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#autoload-when-phplint-and-php-trigger-autoloading-of-class'>When PHPLint and PHP trigger autoloading of class</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#autoload-a-more-realistic-autoload-function'>A more realistic __autoload() function</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-namespaces'>Namespaces</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-terminology'>Terminology</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-names-and-case-sensitiveness'>Names and case sensitiveness</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-the-namespace-statement'>The namespace statement</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-the-use-statement'>The use statement</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-name-resolution-algorithm'>Name resolution algorithm</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#constants-constants'>Constants</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#constants-the-define-statement'>The define() statement</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#constants-the-const-statement'>The const statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#predefinedconstants-predefined-constants'>Predefined constants</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#globalvariables-global-variables'>Global variables</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#predefinedsuperglobalvariables-predefined-superglobal-variables'>Predefined superglobal variables</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#types-types'>Types</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-how-phplint-enhance-the-type-model-of-php'>How PHPLint enhance the type model of PHP</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-how-phplint-handle-the-php-types'>How PHPLint handle the PHP types</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-the-boolean-type'>The boolean type</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-the-int-type'>The int type</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-the-float-type'>The float type</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-the-string-type'>The string type</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#arrays-arrays'>Arrays</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#arrays-the-structured-array-type'>The structured array type</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#arrays-building-arrays-element-by-element'>Building arrays element-by-element</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#arrays-the-array-constructor'>The array constructor</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#arrays-runtime-errors-accessing-arrays'>Runtime errors accessing arrays</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#typecompatibility-type-compatibility'>Type compatibility</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecompatibility-assignment'>Assignment</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecompatibility-comparison-operators'>Comparison operators</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecompatibility-strict-equality-operators'>Strict equality operators</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#typecasting-typecasting'>Typecasting</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecasting-value-conversion-operators'>Value conversion operators</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecasting-formal-type-conversion-operators'>Formal type conversion operators</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecasting-the-cast-t-v-magic-function'>The cast(T,V) magic function</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#classes-classes'>Classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-introduction'>Introduction</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-class-constants'>Class constants</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-properties'>Properties</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-methods'>Methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-methods-attributes'>Methods attributes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-inheritance-and-methods-overriding'>Inheritance and methods overriding</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-accessing-to-the-methods'>Accessing to the methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-special-methods'>Special methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-abstract-classes'>Abstract classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-interfaces'>Interfaces</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#recursivedeclarations-recursive-declarations'>Recursive declarations</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#recursivedeclarations-function-prototypes'>Function prototypes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#recursivedeclarations-method-prototypes'>Method prototypes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#recursivedeclarations-class-prototypes'>Class prototypes</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-control-structures'>Control structures</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-declare-'>declare()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-namespace'>namespace</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-use'>use</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-const'>const</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-if-'>if()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-for-'>for()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-while-and-do-while-'>while() and do...while()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-foreach-'>foreach()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-switch-'>switch()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-try-catch'>try...catch</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-return'>return</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-break'>break</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-definite-assignment-analysis'>Definite assignment analysis</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-if-statement'>The if() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-while-statement'>The while() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-do-while-statement'>The do...while() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-foreach-statement'>The foreach() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-for-statement'>The for() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-switch-statement'>The switch() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-try-catch-statement'>The try...catch statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-arguments-passed-by-reference'>Arguments passed by reference</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#functions-functions'>Functions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-returned-type'>Returned type</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-mandatory-arguments'>Mandatory arguments</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-default-arguments'>Default arguments</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-optional-arguments'>Optional arguments</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-passing-method-for-arguments'>Passing method for arguments</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-the-contract-of-a-function'>The contract of a function</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-examples'>Examples</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#errors-errors'>Errors</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#errors-fully-handling-of-errors'>Fully handling of errors</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#errors-triggering-errors-and-errors-inheritance'>Triggering errors and errors inheritance</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#errors-mapping-errors-into-exceptions'>Mapping errors into exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-exceptions'>Exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-the-exception-base-class'>The Exception base class</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-extending-exception'>Extending Exception</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-declaring-thrown-exceptions'>Declaring thrown exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-exceptions-and-prototypes-methods-and-inheritance'>Exceptions and prototypes, methods and inheritance</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-detecting-the-exceptions'>Detecting the exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-checked-exceptions'>Checked exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-unchecked-exceptions'>Unchecked exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-may-overriding-methods-throw-new-exceptions-'>May overriding methods throw new exceptions?</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#stdlib-phplint-s-standard-library'>PHPLint's Standard Library</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#stdlib-handling-errors-errors-h'>Handling errors -- errors.h</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#stdlib-autoloading-classes-autoload-php'>Autoloading classes -- autoload.php</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#stdlib-the-typecast-magic-function-cast-php'>The typecast magic function -- cast.php</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#stdlib-include-all-all-php'>Include all -- all.php</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#documentator-documentator'>Documentator</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#usage-usage'>Usage</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-command-line-options'>Command line options</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-general-options'>General options</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-error-detection-options'>Error detection options</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-format-of-the-report'>Format of the report</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-exit-status'>Exit status</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-examples-of-invocation'>Examples of invocation</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#howto-how-to-'>How To...</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-php4-classes'>PHP4 - Classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-new-attributes-for-class-items'>New attributes for class items</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-class-constants'>Class constants</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-properties'>Properties</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-methods'>Methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-example'>Example</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-overriding-properties'>Overriding properties</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-overriding-methods'>Overriding methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-special-methods'>Special methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-final-classes'>Final classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-abstract-classes'>Abstract classes</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#php4-typeconversionoperators-php4-type-conversion-operators'>PHP4 - Type conversion operators</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#reserverdkeywords-reserved-keywords'>Reserved keywords</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#reserverdkeywords-php-keywords'>PHP keywords</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#reserverdkeywords-phplint-keywords'>PHPLint keywords</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#todolist-to-do-list'>To-do list</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#todolist-known-bugs'>Known bugs</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#todolist-missing-features'>Missing features</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#todolist-php-features-intentionally-omitted'>PHP features intentionally omitted</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#todolist-other-differences'>Other differences</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#todolist-wish-list'>Wish list</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-memorandum'>Memorandum</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-source-encoding'>Source encoding</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-identifiers'>Identifiers</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-constants'>Constants</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-variables'>Variables</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-functions'>Functions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-classes'>Classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-class-constants'>Class::Constants</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-class-variables-aka-properties-aka-members-'>Class::Variables (aka Properties, aka Members)</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-class-functions-aka-methods-'>Class::Functions (aka Methods)</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#license-license'>License</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#references-references'>References</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#syntax-the-syntax-of-phplint'>The syntax of PHPLint</a><p>
<pre>

</pre>
<a name=introduction-introduction></a>
<h2>Introduction</h2>

<p>
<b>PHPLint</b> is a parser and semantic validator for PHP
programs.  Moreover, <b>PHPLint</b> enhance the syntax of the
PHP language with transparent extended syntax (or meta-code) that can
drive the parser to even more strict checking. The <b>PHPLint
Documentator</b>, a tool to generate automatically the documentation
about a PHP source program, is described in a separate document (see <a
href="documentator.html">www.icosaedro.it/phplint/documentator.html</a>).
</p>

<p>
The main application of the PHP language is to provide dynamic contents
to the WEB pages. Most of that pages are really simple, and typically
they involve the parsing of the HTTP request, a connection to the
data base to retrieve data, and then the presentation of the results to the
user. These applications cannot really benefit from PHPLint. Rather,
the applications where PHPLint may reveal to be really useful are the
complexes one, where much code and included libraries are involved, and
where it would be difficult to track down formal and conceptual errors.
In the next chapters we will explain how PHPLint works and how you can
get the best results programming with it.
</p>

<p>
A summary of the implemented features:
</p>

<ul>
<li>Support for PHP 4 and PHP 5.</li>
<li>General syntax check.</li>
<li>Strict type checking in expressions, assignments and function arguments.</li>
<li>Structured array declarations.</li>
<li>Checks functions signature usage.</li>
<li>Checks methods signature and method inheritance.</li>
<li>Recursive inclusion of the required packages.</li>
<li>Meta-code that implement C-style type declarations.</li>
<li>Check items declared but never used, or used but never declared.</li>
<li>Support for phpDocumentor comments (DocBlocks).</li>
<li>Documentation generation.</li>
</ul>


<p>
<b>PHPLint</b> comes in two forms: a stand-alone program you may execute
on your computer, and a WEB version that allows you to try your code
on-line.
</p>
<pre>

</pre>
<a name=basicfeatures-basic-features></a>
<h2>Basic features</h2>

<p>
PHP is a great programming language suitable for rapid development of
WEB applications and other programs. However, PHP is too "liberal",
and lets the programmer to do many dangerous things. Some problems are
detected by the interpreter itself in parse phase. Others are detected only if the
interpreter goes through the bugged code at run-time. Other errors
are not detected at all, or reveal them only in particular circumstances.
</p>

<p>
Several problems the PHP parser and interpreter cannot detect can be
detected by <b>PHPLint</b>.  The list of the
<script>
document.write("<"+"a href='error-messages.cgi'>error messages</a>");
</script>
should give you an idea of all the checks that PHPLint can do.
</p>

<p>
The PHP language is weak-typed, that is the programmers can freely mix data of
different type (numbers, strings of characters, etc.) and different structure
(objects, arrays, etc.). The language takes care to perform automatically and
at run-time any conversion that may be required based on the context were these
data appears. This feature is also known as <i>type juggling</i>.
Unfortunately, sometimes type juggling brings to unexpected results that arise
only on particular combination of values, and it may be very difficult to
discover were the problem originates.
</p>

<p>
So, one of the main goals PHPLint tries to achieve is to turn a weak-type
language as PHP is into a strong-typed one, but with a minimal impact on the
programming style of the typical PHP programmer. PHPLint detects automatically
the type of any element of the language, be it a constant, a variable or a
function, and then it ensures this element be handled according to it type:
numbers go with numbers, arrays with arrays and so on. The following list
should give an idea of the strategies PHPLint follows in order to detect the
type of an expression:
</p>

<ul>
<li>Trying to <b>guess</b> the correct types of the expressions from
the operands and from the operators involved, and trying to guess the
signature of the functions from their usage.</li>

<li>
Based on known <b>prototypes</b> of functions, classes and methods.
</li>

<li>Providing <b>meta-code</b> to drive the parser. This code needs to
be added by hand. This is the subject of the next chapters.</li>

<li>Based on the declarations provided with the phpDocumentor DocBlocks.</li>

</ul>




<p>
<b>Guessing the type from the expression.</b>
PHPLint can guess the type of an expression tracking the propagation
of the literal constants through each operator and each variable. For
example, it is evident from this chunk of code
</p>

<blockquote><pre>
class A {
    public $count = 0;  # $count is an int
}

function f()
{
    $a = 123;     # ==&gt; $a is an int
    $b = 2*45;    # ==&gt; $b is another int
    $c = $a + $b; # ==&gt; $c is int
    $arr[$a] = "hello!";  # ==&gt; $arr is an array of strings
                          # with int index
    return $c;    # this functions returns int
}
</pre></blockquote>

<p>
that the variables <code>$count</code>, <code>$a</code> and
<code>$b</code> are of type integer and that the function <code>f()</code>
does not take arguments and returns a value of type integer. The guess
of the type of the variable <code>$c</code> requires to recall one
interesting feature of PHP: when the intermediate result of an evaluation
can't fit a 32-bit integer number, the value is automatically converted
to a floating point number.  That seems to be a limitation on any guess we
can do simply parsing the source, since we can't know how big such a variable
will become at run-time. However, we can nearly be sure that, in a
strong-typed language, the variable <code>$c</code> would be declared
of type integer by the programmer, and just so PHPLint will do.  The
operators <code>-</code> and <code>*</code> are treated in the same way.
</p>




<p>
<b>Guessing the type from the typecast.</b>
PHP does not provide an explicit division operator among integer numbers,
and the division operation <code>/</code> might result in a float
value also if the arguments are both integer numbers. For example,
<code>$x/2</code> would give the integer value <code>8</code>
for <code>$x=16</code> and would give the floating point value
<code>8.5</code> for <code>$x=17</code>. In general, since the value of
the arguments are known only at runtime, PHPLint assumes that a division
always returns a floating point number. If this is not the case, the programmer
must to provide an explicit typecast:
</p>

<blockquote><code>$c = (int) ($a / $b);</code></blockquote>

<p>
Not only this typecast is required to drive PHPLint to the correct guess,
but it is also a good programming practice if the required result is
intended to be an integer number.
</p>

<p>
The values returned by the WEB client are collected into the
superglobal arrays <code>$_GET</code>, <code>$_POST</code> and
<code>$_REQUEST</code>. These arrays have a string as index and their
elements are of type mixed. If the expected value is a string, a <i>value
conversion type-cast operator</i> to string is required (see chapters
<u>Typecasting</u> and  <u>Predefined superglobals</u> for details):
</p>

<blockquote><code>$your_name = (string) $_POST['your_name'];</code></blockquote>

<p>
If the expected value is the result of the selection of multiple options
in a pop-up menu, a <i>formal type-cast</i> to array is required:
<p>

<blockquote><code>$colors = /*.(array[int]string).*/ $_POST['colors'];</code></blockquote>

<p>
so that <code>$colors</code> results to be an array of strings with
integer index.
</p>

<pre>

</pre>
<DIV><FIELDSET><LEGEND><b>WARNING</b></LEGEND>
We can't trust data coming from the client browser: there is no garanties
that a parameter expected to be an array of strings actually be what we
expect. The parameter might be missing, or it might be a string or even
an array of arrays.  The example above (multiple selections from a menu)
should then be re-written in a safer way as follows:

<pre>
$colors = /*. (array[int]string) .*/ array();
if( is_array( $_POST['colors'] ) )
    foreach(/*. (array[]mixed) .*/ $_POST['colors'] as $v)
        $colors[] = (string) $v;
</pre>

Moreover, the resulting array <code>$colors</code> of the selected colors
should now be checked for valid colors and possible duplicated values.

</FIELDSET></DIV>
<pre>

</pre>




<p>
<b>Guessing the type from the <code>foreach</code> statement.</b>
The <code>foreach</code> statement can set one or two variables, that
is the key and the value of each element of the array we are scanning:
</p>

<blockquote><pre>
$a = array("a", "b", "c");
# $a is an array of strings with integer index 0, 1 and 2

foreach($a as $v){
    # $v results to be a string
}

foreach($a as $k => $v){
    # $k results to be an int
    # $v results to be a string
}
</pre></blockquote>


<p>
NOTE. Once the type of a variable has been guessed by PHPLint, this
variable must be always used accordingly to its type.  PHPLint does not
allow for automatic type/value conversion: for example, numbers and
strings cannot be mixed together.  Any conversion from a value of
one type to the value of another type must take place by an explicit
type-cast operator.  PHPLint provides type-cast operators that perform
either an actual conversion of the value at run-time (for example,
<code>(int)</code> applied to a <b>string</b>) and type-cast operators
that only formally convert the type - see the chapter <u>Typecasting</u>
for details.
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#packages-packages'>Packages</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#packages-modules-libraries-and-programs'>Modules, libraries and programs</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#packages-items-phplint-collects-from-parsed-packages'>Items PHPLint collects from parsed packages</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#packages-general-structure-of-a-package'>General structure of a package</a><p>
<a name=packages-packages></a>
<h2>Packages</h2>


<p>
In the PHPLint terminology, a <b>package</b> is simply any PHP file the PHPLint
program can parse. Since a single PHP source file can define an arbitrary
number of items (functions, classes, etc.), this name appears to be quite
justified to indicate a collection of programming tools. "Namespace" is another
term that indicate a collection of packages more or less related.
PHPLint packages have nothing to do with the DocBlock
<code>@package</code> line tag, nor with PHP 5 namespaces, it is only a
specific name given to a PHP source file.

<p>
PHPLint distinguishes among three types of packages: modules, libraries and
programs.
</p>



<a name=packages-modules-libraries-and-programs></a>
<h3>Modules, libraries and programs</h3>


<ul>

<li>
A <b>module</b> is a stub of PHP source code where the standard extensions of
the PHP language are described. These modules are available under the
<code>modules</code> directory of the PHPLint program. Modules can be imported
with the special meta-code statement <code>/*. require_module 'MODULENAME';
.*/</code>.
</li>

<li>
A <b>library</b> is an user package intended to provide reusable constants,
functions and classes to other librares or client programs.
Each library can define one or more namespaces. Libraries can import
several modules and can also import other lower-level libraries
with the <b>require_once</b> statement.
</li>

<li>
A <b>program</b> is an user package that can be executed to generate a WEB page
or any other document. PHP code may be surrounded by textual content, typically
HTML or XML. Executable CGI scripts are also allowed and the standard
<i>shabang</i> leading line <code>#!</code> is detected.
Programs can import modules and libraries, but cannot import other programs.
</li>


</ul>

<p>
<b>IMPORTANT NOTE:</b>
only modules imported with <b>/*.require_module.*/</b> and libraries imported
with <b>require_once</b> and classes autoload are parsed recursively by
PHPLint. Sources imported with <b>require</b>, <b>include</b> and
<b>include_once</b> are not parsed recursively.
</p>



<a name=packages-items-phplint-collects-from-parsed-packages></a>
<h3>Items PHPLint collects from parsed packages</h3>

<p>
From a package PHPLint gathers the informations that follow:
</p>

<ul>

<li>The list of the <b>required PHP built-in modules</b> aka
<i>extensions</i> (for example, <code>standard</code>, <code>mysql</code>,
<code>session</code>, etc.). These modules may or may not be present in
your installation of the PHP interpreter, as their presence depends on how
the PHP interpreter was built from the sources.
</li>

<li>The list of the <b>required packages</b> imported with
<code>require_once</code>.
</li>

<li>The list of the <b>exported items</b> from this package:<p>

	<ul>

	<li>The list of the non-private constants exported.
	<p>
	</li>

	<li>The list of the non-private global variables exported.
	<p>
	</li>

	<li>The list of the non-private functions exported.
	<p>
	</li>

	<li>The list of the non-private classes exported.
	<p>
	</li>

	<li>The list of the non-private items exported by these classes
	(constants, variables and functions).
	<p>
	</li>

	</ul>
</li>

</ul>



<a name=packages-general-structure-of-a-package></a>
<h3>General structure of a package</h3>

<p>
As PHPLint is a single-pass parser, it very important to define every thing
before its usage according to the well know <i>bottom-up</i> ordering.
So if function a() calls b() and b() calls c(), then these functions must be
declared in the order c, b, a.
</p>

<p>
To overcome this strict bottom-up ordering, PHPLint also provides a special
meta code <i>forward</i> declarations for functions and classes with which
recursive functions, recursive classes and recursive methods are allowed.
</p>

<p>
A <b>project</b>, or <b>application</b>, or <b>WEB application</b>, can consist
of several packages. The typical structure of a library might look something
like this:
</p>


<pre>
&lt;?php
# REQUIRED MODULES:
/*.
    require_module 'standard';
    require_module 'pgsql';
    require_module 'session';
.*/

# REQUIRED LIBRARIES:
require_once __DIR__ . '/SiteConfig.php';
require_once __DIR__ . '../php-libs/MimeMail.inc';

# PRIVATE ITEMS:
/*. private .*/ define("MAX_LOGGED_USERS", 20);
/*. private .*/ class SessionFile { ... }
/*. private .*/ $current_session = /*. (SessionFile) .*/ NULL;

/*. private SessionFile .*/ function NewSessionFile($max_size = 10000)
{ ... }

# EXPORTED ITEMS:
define("MAX_USER_NAME", 20);
class User { ... }
$loggedUsers = /*. (array[int]User) .*/ array();

/*. void .*/ function UpdateLoggedUsers() { ... }

/*. User .*/ function NewUserSession() { ... }

# INITIALIZATION CODE:
$current_session = NewSessionFile();
UpdateLoggedUsers();
</pre>


<p>
The <code>/*. private .*/</code> attribute is an extension of the PHPLint
meta-code.  The private items of a package can be used only inside the
package itself.  PHPLint raises an error if a private item of a package
is used or re-defined inside another package. Private items are listed
in the documentation generated by the PHPLint Documentator, so to make
the programmer aware of that global name-space "pollution".
</p>
<pre>

</pre>
<a name=importingmodules-importing-modules></a>
<h2>Importing modules</h2>

<p>
Several extension modules come built-in with the base PHP interpreter,
and many others are available from other sources (mainly from the PECL
project). These extensions may or may not be available in our PHP
installation, so PHPLint provides a way to specify which extensions
our program actually requires.  For example, <code>strlen()</code>
is provided by the <b>standard</b> module (normally always available),
<code>session_start()</code> is provided by the module <b>session</b>,
and <code>preg_match()</code> comes from <b>pcre</b>.  PHPLint checks
if these modules are actually used, and reports them on the final
documentation generated automatically.
</p>

<p>
The <i>PHPLint extended syntax</i>, or <i>meta-code</i> for short, lets
the programmer to give some insight about its code that drive PHPLint to
an even more strict checking of variables and of functions. Since
that meta-code isn't valid PHP code, it must be enclosed inside a comment
<code>/*.&nbsp;.*/</code>. Note that there is exactly one period after
the first asterisk, and another period before the closing asterisk.
Since the PHPLint meta-code is enclosed in a comment, it will not interfere
with the PHP interpreter.
</p>

<p>
The first usage of the PHPLint meta-code we'll describe is the meta-statement
<code>require_module&nbsp;'<i>MODULE</i>'</code> where the MODULE is the name of
the extension module required. With this statement we tell to PHPLint
which extension modules are required by our program.
The name of the module MUST appear inside a single-quoted string;
expressions aren't allowed. This meta-code statement MUST appear at the
scope level "zero", i.e. it cannot be inside a function or inside a
class declaration. For example:
</p>

<blockquote>
<pre>
&lt;?php
/*****************************
 *  My beautiful WEB page.   *
 *****************************/

<b>/*. require_module 'standard';
    require_module 'pcre';
    require_module 'mysql'; .*/</b>

...rest of the program here...
?&gt;
</pre>
</blockquote>

<p>
PHPLint will parse the files of the modules located in the directory
<code>modules/</code> of the distributed package. Each module is a
collection of declarations of constants, functions and classes of the
corresponding module, as reported by the PHP manual.  Without these
modules PHPLint would be unaware of which items are available, and it
would raise an error for any item it don't know, even for a simple
standard function as <code>strlen()</code>.
</p>

<p>
The module <code>'standard'</code> is the library of resources that
should always be available in every installation of PHP. In this
module functions like <code>strlen()</code>, <code>mail()</code> and
<code>trigger_error()</code> are defined.  The other modules might
or might not be present in your installation of PHP: the function
<code>phpinfo()</code> gives the list of the modules currently available
in your system. As an alternative you can use this simple program to
display which modules are actually available in your system:
</p>

<blockquote><pre>
&lt;?php print_r( get_loaded_extensions() ); ?&gt;
</pre>
</blockquote>

For example, on my system this program displays:

<blockquote><pre>
Array
(
    [0] =&gt; tokenizer
    [1] =&gt; standard
    [2] =&gt; session
    [3] =&gt; posix
    [4] =&gt; pcre
    [5] =&gt; mbstring
    [6] =&gt; ftp
    [7] =&gt; sockets
    [8] =&gt; pgsql
)
</pre></blockquote>

<p>
The function <code>extension_loaded('MODULE_NAME')</code> returns
<code>TRUE</code> if the given module is available, so that you may check
at run-time the environment of your program.
</p>

<p>
Recent versions of the PHP 5 CLI or CGI allows to list the compiled-in
modules simply typing this command from the console:
</p>

<blockquote><pre>
$ <b>php -m</b>
[PHP Modules]
Core
date
dom
ereg
libxml
mbstring
pcre
PDO
posix
Reflection
session
SPL
standard
tokenizer
xml

[Zend Modules]
</pre></blockquote>

<p>
Near to the end of its report, PHPLint will list a summary of all the
modules that are required by the package and the packages it import,
along the modules imported but actually never used in the package:
</p>

<blockquote>
<pre>
...
?: notice: required module: pgsql
?: notice: required module: regex
?: notice: required module: standard
?: notice: unused module `xmlreader'
?: notice: unused module `libxml'
Overall test results: 3 errors, 10 warnings.
</pre>
</blockquote>

<p>
From this output we learn that the package just
requires the modules <code>pgsql</code>, <code>regex</code> and
<code>standard</code>. This information might be very useful in the
deployment phase of the application, since the program would not work
if the PHP interpreter on the target system lacks some these modules.
</p>

<p>
A package can include other packages through the <code>require_once</code>
statement (see the next chapter), and in turn these included files might
require even more modules and packages. Every module and every package
is always parsed only once, and it is ignored in the following inclusions.
</p>

<p>
The complete list of the modules provided with PHPLint is
available in a separate document: <a href="http://www.icosaedro.it/phplint/libraries.cgi">www.icosaedro.it/phplint/libraries.cgi</a>.
Users can also easily add their own new modules or extensions.
</p>
<pre>

</pre>
<a name=importingpackages-importing-packages></a>
<h2>Importing packages</h2>


<p>
PHPLint follows recursively the files that are imported through the PHP
statement <code>require_once&nbsp;EXPR;</code> where EXPR is a string
expression giving the file name of the file to be included. The included file,
in turn, might require several other modules and packages.
</p>

<p>
The path of the required package <b>must be absolute</b>. PHPLint raises an
error if the path cannot be evaluated statically or if the path is relative.
The magic constant <code>__DIR__</code> gives the directory of the current
script.
</p>

<blockquote>

	<p>
	<b>ATTENTION!</b>
	</p>

	<p>
	Only the <code>require_once</code> statement is parsed recursively. The
	statements <code>include</code>, <code>include_once</code> and
	<code>require</code> are scanned by PHPLint but the files specified are
	not parsed. To parse also these files, you can either change the
	statement to <code>require_once</code> or add these files to the list
	of files to be parsed in the command line that started PHPLint.
	The reason is explained below.
	</p>

</blockquote>

<p>
<code>include()</code> and <code>include_once()</code> are not suitable to
include libraries because these statements can fail but the execution still
continues, with possible safety and security issues if the program does not
crash immediately.
</p>

<p>
<code>require()</code> is not suitable to include libraries because a program
may include several libraries that, in turn, include some other common library,
so generating a fatal error when a const/funct/class is re-defined.
</p>

<p>
Then, <code>require_once()</code> must be parsed recursively just to collect
the definitions of all the items the program needs. The other inclusion
statements, instead, must not be parsed recursively because may either fail at
runtime (<code>include*()</code>) or may cause fatal errors
(<code>require()</code>) that can be detected only at runtime.
</p>

<p>
As a practical rule, you should always use <code>require_once</code> to include
libraries, and use <code>include</code> to include template files, header
files, footer files, chunks of HTML code and similar.
</p>

<p>
The <code>require_once</code> statement must appear at scope level "zero" of
the program, and the expression giving the file name must be a simple
expression of strings that can be evaluated "statically"; magic constants are
also allowed; expressions involving variables and functions are not allowed.
Some typical examples:
</p>

<blockquote>
<pre>
define("LIBS", __DIR__ . "/../libs/");

/* These packages are parsed recursively: */
require_once LIBS . "db_access.php";
require_once LIBS . "users_table.php";
require_once __DIR__ . "/../frames/frame-top.php";

/* These packages ARE NOT PARSED recursively because the expression
   giving the file name cannot be evaluated statically: */
require_once "lang-$lang.php";
require_once $_SERVER['DOCUMENT_ROOT'] . "/borders.php";

/* Files imported with the require|include|include_once statements
   ARE NOT PARSED recursively: */
require "borders/red.inc";
include "borders/green.inc";
include_once "borders/blue.inc";
</pre>
</blockquote>

<p>
When PHP is run in CLI mode, the current working directory is set to that
from which the script was invoked, so in order to load the required libraries
you may either specify absolute path file names, or use the __DIR__
constant in PHP 5:
</p>

<blockquote><code>
require_once __DIR__ . "/../lib/MyLib.php";
</code></blockquote>


<p>
Every program and every package may require several other packages.
The following picture shows the dependency tree among the packages
required by the Main.php program. The main directly uses only A.php,
B.php and C.php, but in turn B.php also requires D, E, and F.php and so on.
Often these files contain a single class, or a set of related functions.
</p>

<blockquote>
<pre>
       Main.php
       /   |   \
      /    |    \
     /     |     \
    /      |      \
A.php    B.php    C.php
         / | \      |
        /  |  \     |
       /   |   \    |
      /    |    \   |
   D.php  E.php  \  |
              \   \ |
               \  | |
                F.php
</pre>
</blockquote>

<p>
There are at least two possible strategies to import all the required package:
</p>

<ol>

<li>
<b>In the Main.php program we may list all the required packages,</b> including
those sub-packages as D,E,F that are not directly used by Main.php and of which
Main.php is completely unaware of. This strategy is not recommended with
PHPLint and it is not recommended in any case.
</li>

<li>
<b>Every package requires only the packages it directly needs,</b> and every
sub-package, in turn, requires the other sub-packages. So, writing for example
the source of Main.php, the programmer has only to require the packages he
really directly needs, and every sub-package will import automatically its
dependencies. This is the recommended import strategy with PHPLint because it
is simpler and more natural for the programmer, and because it also allows to
check with PHPLint every single file separately.
</li>

</ol>

<p>
Then, following the suggested strategy above, every package of our example will
load only the packages it directly needs:
</p>

<blockquote>
<pre>
Main.php:
    require_once "A.php";
    require_once "B.php";
    require_once "C.php";

B.php:
    require_once "D.php";
    require_once "E.php";
    require_once "F.php";

C.php:
    require_once "F.php";

E.php:
    require_once "F.php";
</pre>
</blockquote>


<p>
In some rare cases packages cannot be organized in a dependency tree as shown
above because there are mutual depencencies, that might be direct (A requires B
and B requires A) or indirect (A requires B, B requires C and C requires A).
These mutual dependencies should be avoided reorganizing the structure of the
program, possibly introducing common interfaces of common abstract classes.
The chapter <i>Recursive declarations</i> addresses the cases that cannot
be resolved otherwise.
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#autoload-autoloading-classes'>Autoloading classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#autoload-the-autoload-magic-function'>The __autoload() magic function</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#autoload-resolution-schema-with-namespaces'>Resolution schema with namespaces</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#autoload-general-form-of-the-autoload-pragma'>General form of the autoload pragma</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#autoload-when-phplint-and-php-trigger-autoloading-of-class'>When PHPLint and PHP trigger autoloading of class</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#autoload-a-more-realistic-autoload-function'>A more realistic __autoload() function</a><p>
<a name=autoload-autoloading-classes></a>
<h2>Autoloading classes</h2>

<p>
Normally PHP raises a fatal error at runtime if we try to use an undefined
class, so the programmer must take care to load in advance any class the
following code may require:
</p>

<blockquote><pre>
&lt;?php

require_once '/path/to/classes/MyClass.php';
require_once '/path/to/classes/YourClass.php';
require_once '/path/to/classes/HisInterface.php';
...

$a = new MyClass();

class OurClass extends YourClass implements HisInterface { ... }
...
?&gt;
</pre></blockquote>


<a name=autoload-the-autoload-magic-function></a>
<h3>The __autoload() magic function</h3>

<p>
PHP 5 introduces a new magic function named <b>__autoload($className)</b> that
allows to load at runtime any missing class if and only when this class is
actually needed. Class autoloading is triggered, for example, when a new object
is created with <tt>new MyClass()</tt>, when a class implements or extends an
unknown class or interface, or when serialized data are recoverd with the
function <tt>unserialize()</tt> and in any other case PHP encounters a class
still not defined. Obviously, if auto-loaded classes in turn need other
classes, again the autoload mechanism is triggered again, recursively.
</p>

<p>
In the following example, PHP will load automatically the class
<code>MyClass</code> from the file <code>/path/to/classes/$className.php</code>
when the object $a is created, and will also load all the other required
classes when the the new class <code>OurClass</code> is declared:
</p>

<blockquote><pre>
&lt;?php

function __autoload(/*. string .*/ $className)
{
    require_once "/path/to/classes/$className.php";
}

$a = new MyClass();

class OurClass extends YourClass implements HisInterface { ... }
...
?&gt;
</pre></blockquote>

<p>
Unfortunately this source cannot be submitted to PHPLint as-is because PHPLint
is not smart enough to understand how the trick works, so we need to provide
some hint to it. To this aim PHPLint introduces the concept of <i>resolution
schema</i> that can be specified through the special
<b>pragma&nbsp;'autoload'</b> meta-code statement.
</p>

<p>
The autoload pragma must appear inside the body of the <tt>__autoload()</tt>
function and it is not allowed elsewere. This pragma tells to PHPLint how to
build the full file name of the file that contains the definition of a class.
Here is and example of how it can be used:
</p>

<blockquote><pre>
&lt;?php

function __autoload(/*. string .*/ $className)
{
    <b>/*. pragma 'autoload'
               'schema1'
               '/path/to/classes/'
               '/'
               '.php';
    .*/</b>

    require_once "/path/to/classes/"
        . (string) str_replace("\\", "/", $className)
        . ".php";
}

$obj = new MyClass();
...
?&gt;
</pre></blockquote>

<p>
The resolution schema explains to PHPLint how the name of the missing class
should be processed in order to get the name of the file where the class is
defined: <code>/path/to/classes/</code> is the string to prepend to the name of
the class, and <code>'.php'</code> is string to append to the name of the
class. The substitution operated by <code>str_replace</code> has effect only
when classes and namespaces are involved.
</p>

<p>
Note that the <code>__autoload</code> function has then two parts: the
pragma is the resolution schema as used by PHPLint, and the PHP code
that follows is the resolution schema that will be actually applied
by PHP at runtime.  PHPLint has no way to check if the two schemas do
match, and in fact often they do not, as the first schema is used on the
computer where the source validation was performed, whereas the latter
must match the filesystem layout of the WEB server where the source will
be deployed and the program executed.
</p>

<p>
The <tt>schema1</tt> resolution schema is very simple but it forces
to collect all the classes of a project in a single, flat directory.
Another way to organize classes among a strctured hierarchy of directories
is by achieved using namespaces as explained below.
</p>


<a name=autoload-resolution-schema-with-namespaces></a>
<h3>Resolution schema with namespaces</h3>

<p>
When namespaces are involved the name of the class as passed to the
<tt>__autoload()</tt> function contains the absolute name of the
class with identifiers separated by backslash.  Here is where the
<code>'/'</code> parameter of the autoload pragma comes into play:
in fact this parameter is the string into which the backslashes of the
absolute name of the class has to be converted, so that
</p>

<blockquote><pre>
$zero = it\icosaedro\bignumbers\BigInt(0);
</pre></blockquote>

<p>
will causes the file
<code>/path/to/classes/it/icosaedro/bignumbers/BigInt.php</code> to be
automatically loaded by PHP and parsed by PHPLint.  The resulting file
name then uses the slash as path separator suitable to be used in Unix
and Unix-like file systems. Under Windows, instead, the backlash has to
be used.
</p>


<a name=autoload-general-form-of-the-autoload-pragma></a>
<h3>General form of the autoload pragma</h3>

<p>
The general form of the autoload pragma is then the following:
</p>

<blockquote>
<code>pragma 'autoload' 'schema1' '<i>prepend</i>' '<i>separator</i>' '<i>append</i>';</code>
</blockquote>

<p>
where <tt><i>prepend</i></tt> is the base directory of the classes tree.
If a relative path is given, it is resolved against the directory of the
file where the pragma is located, so that normally a bare dot <tt>'.'</tt>
here does the job provided that the file where the pragma is located
(normally <tt>autoload.php</tt>) be the root directory of the classes root.
</p>

<blockquote><tt>pragma 'autoload' 'schema1' '/home/www/libs/' '/' '.php';</tt>
</blockquote>

<p>
the class <tt>MyClass</tt> would be mapped into the file name
</p>

<blockquote><tt>/home/www/libs/MyClass.php</tt></blockquote>

<p>
whereas the class <tt>it\icosaedro\bignumbers\BigInt</tt> would be mapped
into the file name
</p>

<blockquote><tt>/home/www/libs/it/icosaedro/bignumbers/BigInt.php</tt></blockquote>

<p>
The autoload pragma MUST appear inside the <b>__autoload</b> function, and then
only one resolution schema is allowed at a time.
</p>

<p>
Currently PHPLint supports only the <code>'schema1'</code> resolution schema
described here. Others resolution schemas, for example to support the PEAR
naming schema, might be added later.
</p>



<a name=autoload-when-phplint-and-php-trigger-autoloading-of-class></a>
<h3>When PHPLint and PHP trigger autoloading of class</h3>

<p>
As a general rule, PHPLint triggers class autoloading anywhere an unknow class
is found in the source code, including PHPLint meta-code and DocBlocks, with
the only exclusing of some very special functions that are listed below the
table. PHP, instead, triggers class autoloading only in some contexts where
this is really necessary for the correct execution of the program. The
following table lists all the cases in which class autoloading is triggered,
also specifying when only PHPLint or only PHP perform class autoloading and
not both.
</p>


<pre>
</pre>
<table border=1 cellspacing=0 cellpadding=7>

<tr>
<th width="30%">Case</th>
<th>Example</th>
</tr>


<tr>
<td valign=top>
Creating a new object from an undefined class.
</td>
<td valign=top>
<code>$obj = new <b>UndefinedClass</b>();</code>
</td>
</tr>


<tr>
<td valign=top>
Extending or implementing undefined classes.
</td>
<td valign=top>
<code>class MyClass<br>
&nbsp;&nbsp;&nbsp;&nbsp;extends <b>UndefinedClass1</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;implements <b>UndefinedClass2</b> { ... }</code>
</td>
</tr>


<tr>
<td valign=top>
On type hinting of argument of function or method (PHPLint only).
</td>
<td valign=top>
<pre>
function f(<b>UndefClass</b> $obj)
{
    ...
}

class MyClass
{
    function aMethod(<b>UndefClass</b> $obj)
    { ... }
</pre>
</td>
</tr>


<tr>
<td valign=top>
Accessing to static members of undefined classes.
</td>
<td valign=top>
<pre>
$n = <b>UndefClass1</b>::SOME_CONST;
<b>UndefClass2</b>::aMehtod();
</pre>
</td>
</tr>


<tr>
<td valign=top>
Testing if a variable contains an object instance of a given class
(PHPLint only).
</td>
<td valign=top>
<pre>
if( $o instanceof <b>UndefClass</b> ) ...
</pre>
</td>
</tr>


<tr>
<td valign=top>
Checking a class or interface does exist (PHP only). The second argument allows to perform
the test disabling autoloading.
</td>
<td valign=top>
<pre>
if( class_exists("MyClass", FALSE) )...
if( interface_exists("MyIF", FALSE) )...
</pre>
</td>
</tr>


<tr>
<td valign=top>
In <code>catch</code> brances (PHPLint only).
(PHPLint only).
</td>
<td valign=top>
<pre>
try { ... } catch(<b>UndefClass</b> $e){ ... }
</pre>
</td>
</tr>


<tr>
<td valign=top>
When the name of the undefined class appears in PHPLint meta-code:
signature of function or method; type of a variable or property;
formal type-cast; forward declaration of functions, classes and methods
when a reference to an undefined class occurs; /*.throws.*/ declaration.
PHPLint only.
</td>
<td valign=top>
<pre>
/*. <b>UndefClass1</b> .*/ function f(/*. <b>UndefClass2</b> .*/ $obj)
{
    ...
}

/*. forward class MyClass extends <b>UndefClass</b>
{
    void function aMethod()
        throws <b>UndefException1</b>, <b>UndefException2</b>;
}
.*/
</pre>
</td>
</tr>


<tr>
<td valign=top>
In DocBlocks when the name of an unknown class appears in a <code>{@link}</code>
in-line tag, a <code>@param</code> line tag or a <code>@param</code> line tag.
PHPLint only.
</td>
<td valign=top>
<pre>
/**
 * Returns the next available book in {@link <b>Bookstore</b>}.
 * @param <b>Bookstore</b> $bs  The bookstore.
 * @return <b>Book</b>          Next book, or NULL if not available.
 */<br>
function nextBook($bs)
{
    ...<br>
}
</pre>
</td>
</tr>

<tr>
<td valign=top>
When the <code>cast()</code> magic function requires a class.
PHPLint only.
</td>
<td valign=top>
<pre>
$project = cast("<b>Project</b>", $a_mixed_value);
$users = cast("array[int]<b>User</b>", $another_mixed_value);
</pre>
</td>
</tr>

<tr>
<td valign=top>
Unserializing data. Any object that appear in the unserialized data
contains the name of the class to which it belongs, so that the definition
of that class can be automatically loaded.
PHP only.
</td>
<td valign=top>
<pre>
$a_mixed_value = unserialize($serialized_data);
</pre>
</td>
</tr>

<tr>
<td valign=top>
Restoring the HTTP session.
PHP only.
</td>
<td valign=top>
<pre>
session_start();
</pre>
</td>
</tr>

</table>
<pre>
</pre>

<p>
There are also some special functions that may trigger class autoloading:
<tt>class_implements()</tt>, <tt>class_parents()</tt>,
<tt>spl_autoload_*()</tt>. Please note that <b>these functions are not
supported by PHPLint, in the sense that PHPLint does not parse nor autoload the
indicated classes.</b>
</p>


<a name=autoload-a-more-realistic-autoload-function></a>
<h3>A more realistic __autoload() function</h3>

<p>
Since I'm currently experimenting with the new PHP 5.3.0, I put all my scripts
related to this version of the language under the directory
<code>/home/salsi/php530</code> and here is located also this script
<code>phpini.php</code> and my libraries under
<code>/home/salsi/php530/it/icosaedro</code>. This script should be loaded by
every script:
</p>


<pre>
&lt;?php  # /home/salsi/php530/phpini.php

/*.
    require_module 'standard';
    require_module 'spl';
.*/

error_reporting(0xfffff);


/**
 *  Checks the proper php.ini has been loaded.
 */
/*. void .*/ function check_php_ini()
{
    $expected = "/home/salsi/php530/php.ini";
    $actual = php_ini_loaded_file();
    if( $actual === FALSE )
        throw new RuntimeException(
            "expected configuration file $expected not loaded");
    if( $actual !== $expected )
        throw new RuntimeException("loaded php.ini: $actual"
        . ", expected: $expected");
}

check_php_ini();


/*. void .*/ function __autoload(/*. string .*/ $name)
{
    /*. pragma 'autoload'
            '/home/salsi/php530/'
            '/'
            '.php';
    .*/
    $s = (string) str_replace("\\", "/", $name) . ".php";

    // Search in the same directory of this script:
    $include_path = __DIR__;

    // Search in include_path of php.ini:
    //$include_path = ini_get("include_path");

    $paths = explode(PATH_SEPARATOR, $include_path);
    for($i = 0; $i &lt; count($paths); $i++){
        $fn = $paths[$i] . "/" . $s;
        if( file_exists($fn) ){
            //echo "__autoload($name): $fn\n";
            require_once $fn;
            return;
        }
    }

    throw new RuntimeException("class $name not found in $include_path");
}
</pre>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-namespaces'>Namespaces</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-terminology'>Terminology</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-names-and-case-sensitiveness'>Names and case sensitiveness</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-the-namespace-statement'>The namespace statement</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-the-use-statement'>The use statement</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#namespaces-name-resolution-algorithm'>Name resolution algorithm</a><p>
<a name=namespaces-namespaces></a>
<h2>Namespaces</h2>

<p>
PHP 5.3 introduces namespaces, a powerful and effective way to give longest,
meaningful names to items to avoid collisions among items exported
by different packages. PHP also allows to write shorter, incomplete names:
in this case a <i>namespace resolution algorithm</i> has to be applied in
order to obtain the actual absolute name of the item. In this chapter
we will describe in detail how this resolution algorithm works under PHP,
and then under PHPLint too.
</p>


<a name=namespaces-terminology></a>
<h3>Terminology</h3>

<p>
<b>Item:</b> a constant, a function or a class. Items are univocally
represented by an <i>fully qualified name</i> (see below). Note that variables
are not involved in the namespace mechanism, so a thing like
<code>$a\b\c</code> has no meaning and it is a syntactic error.
</p>

<p>
<b>Name:</b> a sequence of one or more identifiers separated by <code>\</code>
(back-slash), for example <code>it\icosaedro\bignumbers\BigInt</code>.
Names can then be bare identifiers (if contain only one identifier)
or qualified (if contain two or more identifiers).
</p>

<p>
<b>Bare identifier</b> is a name that contains only an identifier and no
back-slashes. Items defined in global namespace are all bare identifiers.
In other words, the absolute name of items defined in global namespace
are all bare identifiers.
</p>

<p>
<b>Qualified name:</b> a name that contains at least one back-slash, then at
least two identifiers.
</p>

<p>
<b>Fully qualified name (FQN):</b> the complete name of an item with which PHP
univocally identifies that item. Obviously, the fully qualified names of items
defined in global namespace are all bare identifiers, for example
<code>strlen</code>. Instead, the FQN of items defined in any other namespace
are composed by a path part (the namespace) and the proper identifier specific
for that item defined in the namespace. For example, the FQN
</p>
<center><code>it\icosaedro\bignumbers\BigInt</code></center>
<p>
is the <code>BigInt</code> class (the identifier) defined in the
<code>it\icosaedro\bignumbers</code> namespace (the path part of the FQN).

<p>
<b>Leading word</b> is the first word of a name. If the name is a bare
identifier, then the leading word is the identifier itself.
</p>

<p>
<b>Absolute name</b> is a FQN with a leading back-slash added in
front to it, for example <code>\strlen</code> or
<code>\it\icosaedro\bignumbers\BigInt</code>. This leading back-slash is the
syntactic trick with which the programmer tells to PHP that the following name
is already the absolute name of an item and then the <i>resolution
algorithm</i> has not to be applied to it.
</p>

<p>
All the definitions above are summarized below in EBNF syntax:
</p>

<blockquote>
<p>
name = qualified_name | absolute_name;<br>
qualified_name = id "\" id {"\" id};<br>
fully_qualified_name = qualified_name;<br>
absolute_name = "\" fully_qualified_name;<br>
</p>
</blockquote>

<p>
To summarize, any name that starts with a back-slash is absolute, and the
rest of the name is the FQN of the item.
</p>


<a name=namespaces-names-and-case-sensitiveness></a>
<h3>Names and case sensitiveness</h3>

<p>
In PHP names are all case-insensitive, with the only exception of
the last identifier of the name of constants which is case-sensitive.
</p>

<p>
PHPLint checks the exact spelling of names as they were all case-sensitive,
and signals a Notice when the name does not match exactly its definition.
So for example this chunk of code:
</p>

<blockquote><pre>
namespace it\icosaedro\bignumbers { ... }
namespace it\Icosaedro\BigNumbers { ... }
namespace { $zero = \It\IcoSAedro\BigNUmbERS\ZERO(); }
</pre></blockquote>

<p>
gives several Notices under PHPLint because the namespaces listed here does not match exactly those defined in other packages.
</p>



<a name=namespaces-the-namespace-statement></a>
<h3>The namespace statement</h3>

<p>
The <tt>namespace</tt> statement (not to be confused with the
<tt>namespace\</tt> operator) allows to define the namespace inside which the
items are defined:
</p>

<blockquote><pre>
namespace it\icosaedro\bignumbers {

    const MAX_LEN = 100;
    class BigInt {...}
    /*. BigInt .*/ function Zero(){...}

}
</pre></blockquote>

<p>
All the items defined inside a namespace take that namespace as the path part
of their name. So in the example above the following items are defined
with FQN:
</p>

<blockquote><pre>
it\icosaedro\bignumbers\MAX_LEN
it\icosaedro\bignumbers\BigInt
it\icosaedro\bignumbers\Zero
</pre></blockquote>



<a name=namespaces-the-use-statement></a>
<h3>The use statement</h3>

<p>
The <tt>use</tt> statement declares an abbreviation for a given path,
but it allows also to "import" the name of a single class.
We will use the following terminology for the <code>use</code>
statement:
</p>

<blockquote>
<code>use</code> <i>path</i> <code>as</code> <i>target</i>;
</blockquote>

<p>
where <i>path</i> is a name that identifies a partial namespace name or the
FQN of a class, and <i>target</i> is a bare identifier. If the
<code>as</code>&nbsp;<i>target</i> part of the statement is missing, then the
last word of the <i>path</i> is assumed as <i>target</i>. Then for
example:
</p>

<blockquote><pre>
use it\icosaedro\bignumbers as BN;
use it\icosaedro\bignumbers\BigInt;
</pre></blockquote>

<p>
define the target <code>BN</code> which stands for for the FQN
<code>it\icosaedro\bignumbers</code> and the target <code>BigInt</code> which
stands for the FQN <code>it\icosaedro\bignumbers\BigInt</code>. The <code>use</code>
statements are applied by the namespace name resolver algorithm in the order
to resolve a partial name into a FQN.
</p>




<a name=namespaces-name-resolution-algorithm></a>
<h3>Name resolution algorithm</h3>

<p>
In the source text of the program can appear bare identifiers, qualified
names and fully qualified names. Absolute names are easily converted
into FQNs by simply removing the leading back-slash, so for
example the absolute name
</p>

<blockquote>
<code>\it\icosaedro\bignumbers\BigInt</code>
</blockquote>

<p>
is immediately recognized to identify the FQN
</p>

<blockquote>
<code>it\icosaedro\bignumbers\BigInt</code>
</blockquote>

<p>
The <code>namespace\</code> operator can also be used as a shortland for the
current namespace and can be used to build an absolute name. For example,
if the current namespace is <code>it\icosaedro</code> then
<code>namespace\bignumbers\BigInt</code> is equivalent to the absolute
name <code>\it\icosaedro\bignumbers\BigInt</code>.
</p>

<p>
Instead, bare identifiers and qualified names need to be resolved into a FQN
applying the algorithm we well describe below. This algorithm
depends on the nature of the item involved: constants and functions are
resolved in a way, classes are resolved in a different way.
</p>

<p>
<b>Resolution algorithm for constants and functions.</b> When the name
identifies a constant or a function, these steps are applied in the order:
</p>

<blockquote>
<p>
<b>Bare identifier of constant or function.</b> If bare identifier: search the
name in the current namespace, then in the global namespace, then error.
</blockquote>

<blockquote>
<p>
<b>Qualified name of constant or function.</b>
If it is a qualified name, try applying the <code>use</code> statements defined
in the current namespace, in the order, looking for the first target that
matches the leading word of the qualified name. If a match is found, then the
FQN of the item is formed joining the path part and the trailing part
of the name, the trailing part of the name being the name without its leading
word. Then for example according to the <code>use</code> statements above, the
qualified name
<blockquote>
<code>BN\Zero</code>
</blockquote>
is resolved into the FQN
<blockquote>
<code>it\icosaedro\bignumbers\Zero</code>
</blockquote>
If no matching target is found it is a fatal error.
</blockquote>


<p>
<b>Resolution algorithm for classes.</b> When the name identifies a class,
then the following resolution algorithm applies:
</p>

<blockquote>
<p>
<b>Bare identifier of class.</b>
If bare identifier (for example <code>BigInt</code>), applies all the
<code>use</code> statements in the order, looking for the first target that
matches the identifier. If a match is found,
then the FQN of the class is the corresponding path part of
the <code>use</code> statement; if a class with that name is not
defined, and class autoloading is enabled (see
<code>__autoload()</code> and <code>spl_autoload()</code>) try
autoloading for that name; if the autoloading fails to resolve the FQN of the
class, it is a fatal error.
<p>
If no matching target is found, then a class with this name is searched in the
current namespace <i>namespace</i>; if no class exists with this name and
autoloading is enabled, try autoloading of
<code><i>namespace</i>\BigInt</code>.
If the class cannot be resolved, it is
a fatal error.
</blockquote>


<blockquote>
<p>
<b>Qualified identifier of class.</b>
If the name of the class is a qualified name, for example
<code>BN\BigInt</code>, all the <code>use</code> statements are applied to
the leading word <code>BN</code> of the name; if a matching target is found,
then the leading word is substituted with the corresponding path part of the use
statement to finally obtain the FQN of the class
<code>it\icosaedro\bignumbers\BigInt</code>; if the class with this absolute
name is not currently defined, and autoloading is enabled, try to autoload of
that class; if also autoload fails, it is a fatal error.
<p>
If no matching <code>use</code> statement is found, the current namespace
name <i>namespace</i> is added to the qualified name to obtain the absolute
name <code><i>namespace</i>\BN\BigInt</code> and then search for this
absolute name; if class autoloading is enabled, also tries autoloading;
if also autoloading fails, it is a fatal error.
</blockquote>

<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#constants-constants'>Constants</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#constants-the-define-statement'>The define() statement</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#constants-the-const-statement'>The const statement</a><p>
<a name=constants-constants></a>
<h2>Constants</h2>


<a name=constants-the-define-statement></a>
<h3>The define() statement</h3>


<p>
The PHP statements <code>define()</code> allows to define constants,
that is symbolic names whose value is defined once for all and cannot
be changed later. The first argument of this function is the name of
the constant provided as a string; the second argument is its value.
For example:
</p>

<blockquote><code>define("PI", 3.141592);</code></blockquote>

<p>
The <b>name</b> of the constant can be any expression of the type
string, but typically it is simply a literal string like in our example.
PHPLint raises an error if the name cannot be evaluated statically, so
it cannot contain variables nor functions, and raises an error if the
name of the constant isn't a valid identifier.  Valid identifiers are those
composed of letters, digits and the underscore "<code>_</code>"; the first
character cannot be a digit. The name of a constant is case-sensitive,
so "<code>Pi</code>" and "<code>pi</code>" are different names.
</p>

<p>
The <b>value</b> is an expression of simple type that can be evaluated
statically: a <b>boolean</b>, an <b>int</b>, a
<b>float</b> or a <b>string</b>. Also a generic <code>NULL</code> value
and the <code>NULL</code> string are allowed, for example:
</p>

<blockquote><code>
define("UndefinedValue", NULL);<br>
define("DefaultName", /*. (string) .*/ NULL);
</code></blockquote>

<p>
A constant cannot be re-defined.
</p>

<p>
A constant can be defined inside a function, but PHPLint raises a warning
because it cannot ensure the correct usage of its definition: the constant
might be used before the function defining it be called, or the function
might be called more than once causing a run-time error from the PHP
interpreter. The constants cannot be declared inside the classes for
the same reason. So, the only remaining place where a constant can be
declared is the global scope of the package.
</p>

<p>
A constant that should not be exported toward the client packages should
be declared as "private" to the package where it is defined. To this
end, PHPLint provides a specific meta-code word:
</p>

<blockquote><code>/*. private .*/ define("MAX_USERS", 20);</code></blockquote>

<p>
A private constant cannot be re-defined nor it can be used in any other
package importing this package.  The private constants are reported by
the PHPLint Documentator into the list of the <b>Private items</b> of
the package, since they still occupy their position into the name-space.
</p>



<a name=constants-the-const-statement></a>
<h3>The const statement</h3>

<p>
This statement is available since PHP 5.3 and allows to define one or more
constants:
</p>

<blockquote><pre>
const MAX_CONNECTED_USERS = 10,
      MAX_USER_NAME_LENGTH = 20,
      ADMIN_ROLE_NAME = "Admin";
</pre></blockquote>

<p>
This statement can occur only at global scope, and the expression must be
static.
Constants so defined are added to the current namespace.
</p>

<p>
The <code>/*.private.*/</code> attribute can be prepended to the
<code>const</code> keyword, and it is intended to mark constants that are
private to the package and cannot be used outside, neither if in the same
namescope.
</p>
<pre>

</pre>
<a name=predefinedconstants-predefined-constants></a>
<h2>Predefined constants</h2>

<p>
The following constants are predefined inside the PHPLint parser:
</p>

<blockquote>

<p>
<code>/*. boolean .*/ <b>FALSE</b></code><br>
<code>/*. boolean .*/ <b>TRUE</b></code><br>
Logical values. PHPLint accepts the lower-case letters version
<code>false</code> and <code>true</code>.
</p>

<p>
<code>/*. float .*/ <b>NAN</b></code><br>
Not-A-Number.
</p>

<p>
<code>/*. float .*/ <b>INF</b></code><br>
Infinity.
</p>

<p>
<code>/*. <i>null</i> .*/ <b>NULL</b></code><br>
This constant is the only value allowed for the type <b>null</b>
and it can match a <b>string</b>, an <b>array</b>, a <b>resource</b>, an
<b>object</b> or a <b>mixed</b>.  PHPLint also accepts the lower-case letters
version <code>null</code>.
</p>

<p>
<code>/*. resource .*/ <b>STDIN</b><br>
/*. resource .*/ <b>STDOUT</b><br>
/*. resource .*/ <b>STDERR</b></code><br>
These constant are special the sense that constants of type resource cannot
be defined in user code (only scalar values and strings are allowed).
Note too that these constants are defined only in the CLI version of PHP,
but that cannot be verified by PHPLint.
</p>


</blockquote>





<p>
The following <b>magic constants</b> are available only if the standard module
is loaded. The magic constants are not really constants, but special
expressions of the language whose value depends on the context in which they
appear. PHPLint calculate their value and substitute this value in place
according to the specifications of the PHP manual:
</p>

<blockquote><pre>
/*. string .*/ __DIR__         (PHP 5 only)
/*. string .*/ __FILE__
/*. int    .*/ __LINE__
/*. string .*/ __NAMESPACE__   (PHP 5 only)
/*. string .*/ __FUNCTION__    (lowercase in PHP 4)
/*. string .*/ __CLASS__       (lowercase in PHP 4)
/*. string .*/ __METHOD__      (PHP 5 only)
</pre></blockquote>
<pre>

</pre>
<a name=globalvariables-global-variables></a>
<h2>Global variables</h2>

<p>
The <b>global variables</b> are those variables defined at the global
scope of the package. "Defining" a variable simply means assigning it
a value, like in these examples:
</p>

<blockquote><pre>
$n = 123;
$src = fopen("data.txt", "r");
$matrix[1][$n] = $n + 1;
$redColor = "red";
$colors = array($redColor, "green", "blue");
$adminName = "admin";
$userName = /*. (string) .*/ NULL;
</pre></blockquote>

<p>
In the last line you can see another example of the PHPLint meta-code:
since according to the <i>PHPLint types model</i>, a string can be either a
sequence of characters or the <code>NULL</code> value, and since the
<code>NULL</code> alone isn't a well defined type, a <i>formal
type-cast</i> to the <b>string</b> type is required in order to specify
the type of the expression assigned to the variable <code>$userName</code>
(more on this argument in the following chapters).
</p>

<p>
Global variables that the package don't want to export toward other
packages should be qualified as "private" using the PHPLint meta-code:
</p>

<blockquote><code>
/*. private .*/ $dbConn = pg_connect("dbname=SiteDB");
</code></blockquote>

<p>
These private variables are reserved by the package and cannot be used
by client packages. PHPLint raises an error if a private variable is used
or re-defined in another package.
</p>

<p>
The private variables are reported into the list of the <b>Private
items</b> by the PHPLint Documentator.  Since the private variables still
occupy space inside the global name-space, the programmer should take
care to limit their usage, possibly choosing an appropriate naming schema
that prevent collisions. A common practice is to prefix their name
with the package name <code>$ThePkg_theVar</code>.
</p>
<pre>

</pre>
<a name=predefinedsuperglobalvariables-predefined-superglobal-variables></a>
<h2>Predefined superglobal variables</h2>

<p>
The "superglobals" are variables accessible from any scope. They
are predefined by the interpreter and are documented in the PHP manual.
PHPLint assigns to them a type as follows:
</p>

<dl>

<dt><code>/*. mixed[string] .*/ <b>$GLOBALS</b></code></dt>
<dd>
This array is indexed by the names of the global variables and returns
their value. If the variable isn't already defined in the global scope,
the program raises a warning message. For example:
<p>

<pre>
$x = 1;

function f()
{
    echo $GLOBALS['x'];
    echo $GLOBALS['y'];  # warning: undefined global $y
}
</pre>

<p>
If the expression inside the $GLOBALS[] square braces isn't statically
determinable, i.e. it is an expression to be evaluated at runtime,
PHPLint will not be able to resolve the variable and it will raise a
warning message.
</p>
</dd>

<dt><code>/*. string[string] .*/ <b>$_SERVER</b></code></dt>
<dd>
This array is indexed by the environmental variables that are set by
the WEB server.
<p>
</dd>

<dt>
<code>/*. mixed[string] .*/ <b>$_GET</b></code><br>
<code>/*. mixed[string] .*/ <b>$_POST</b></code><br>
<code>/*. mixed[string] .*/ <b>$_REQUEST</b></code><br>
<code>/*. mixed[string] .*/ <b>$_COOKIE</b></code>
</dt>
<dd>
These array are all of the same type: they are indexed by the name
of a parameter received from the browser. Typically their value is a
string, but they can also be an array of strings when the name of the
parameter received from the client is terminated by these characters:
"<code>[]</code>". Its a good idea to always check for the existence
and the actual type of every parameter. For example, in this code the
parameter "name" is expected to be a string:
<p>

<pre>
if( isset($_POST['name']) &amp;&amp; is_string($_POST['name']) )
    $name = (string) $_POST['name'];
else
    $name = "";
</pre>

<p>
In the following example, the HTML SELECT tag with the "multiple" option
returns an array of the selected options:
</p>

<pre>
if( isset($_POST['hobbies']) &amp;&amp; is_array($_POST['hobbies']) )
    $hobbies = cast("string[int]", $_POST['hobbies']);
else
    $hobbies = /*. (string[int]) .*/ array();
</pre>
</dd>

<dt>
<code>/*. mixed[string][string] .*/ <b>$_FILES</b></code>
</dt>
<dd>
Here too, typically the elements of the array are strings and integer
numbers, but they can be <b>mixed[int]</b> if the request from the browser
contains a parameter terminating with "<code>[]</code>" (upload of two
or more files).
<p>
</dd>

<dt>
<code>/*. string[string] .*/ <b>$_ENV</b></code>
</dt>
<dd>
These are the environment variables of the process executing the PHP program.
<p>
</dd>

<dt>
<code>/*. mixed[string] .*/ <b>$_SESSION</b></code>
</dt>
<dd>
This array is indexed by the names of the variables stored in the current
user session.
<p>
</dd>

<dt>
<code>/*. string .*/ <b>$php_errormsg</b></code>
</dt>
<dd>
A variable containing the text of the last error message generated by
PHP. This variable will only be available within the scope in which
the error occurred, and only if the track_errors option of the php.ini
configuration file is turned on (it is off by default).
Actually this is not a true super-global, but it is a trick of the
PHP interpreter that creates $php_errormsg as a variable local to the
scope where the error occurred.
<p>
</dd>

</dl>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#types-types'>Types</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-how-phplint-enhance-the-type-model-of-php'>How PHPLint enhance the type model of PHP</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-how-phplint-handle-the-php-types'>How PHPLint handle the PHP types</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-the-boolean-type'>The boolean type</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-the-int-type'>The int type</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-the-float-type'>The float type</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#types-the-string-type'>The string type</a><p>
<a name=types-types></a>
<h2>Types</h2>


<a name=types-how-phplint-enhance-the-type-model-of-php></a>
<h3>How PHPLint enhance the type model of PHP</h3>

<p>
The PHP language provides some basic data types: numbers, strings of
characters, arrays and classes. Every expression and every variable
has its own type. Although PHP allows to mix freely data of different
types, abusing of this feature might compromise the <u>efficiency</u>,
the <u>safety</u> and the <u>security</u> of the program.  Moreover, the
long-run aim of the PHPLint is to validate sources ready to be compiled
into an efficient and compact executable code.
</p>

<p>
So, PHPLint takes the type model already existent in the PHP language, and
adds some restrictions on how these types can be combined together. For
example, we can multiply two numbers, but adding an object to a boolean
value generally does not make much sense. PHP allows to add a number to a
string <code>$str + $num</code>, but this implies a conversion of the
string into a number. Since converting data from a type to another takes
some time, and since there might be some safety and security issues
involved, in this case PHPLint requires and explicit typecast operator
<code>$str + (int)$num</code> just to make the programmer aware that a
conversion takes place. The presence of too much conversions in a source
is the clear symptom that the types choosen by the programmer do not
fit well the problem, and the source should be rewritten in a better way.
</p>



<a name=types-how-phplint-handle-the-php-types></a>
<h3>How PHPLint handle the PHP types</h3>

<p>
PHP provides the type <b>null</b> that has only one value, namely the
constant <code>NULL</code>.  Currently the NULL value is seldom used by
PHP programmers.  On the contrary, PHPLint implement a different model where
some data types take the <code>NULL</code> value as a special value. These
are the types commonly known in other programming languages as <i>dynamically
allocated</i> data types, namely <b>string</b>, <b>resource</b>, <b>array</b>
and <b>object</b>.  So, for example, if <code>$str</code> is a variable of
the type <b>string</b>, this variable can be either the <code>NULL</code>
value or an actual string of zero or more characters.
</p>

<blockquote>
NOTE. These types are called <i>dynamic</i> in this documentation because most
programming languages implement them as pointers to dynamically allocated
memory storage. A <code>NULL</code> pointer simply point to nothing and
its typical value is zero.  Actually, in PHP <i>all</i> the variables are
dynamically allocated.
</blockquote>

<p>
In PHP the data types <code>int float string</code> etc. are
keywords the programmer can use only inside the type-cast operator,
but these keywords cannot be used elsewere (apart the limited
case of the <i>type hinting</i> in function parameters).
Since a suitable syntax isn't provided by the language, PHPLint
introduces its own meta-code to declare the type of a variable or an
expression; remember that this meta-code must always be enclosed
inside a comment <code>/*. <i>the_type</i> .*/</code>:
</p>

<ul>
<li><b><code>void</code></b> is a special type returned by functions that... do not return a value.</li>
<li><b><code>boolean</code></b> is a boolean value, i.e. <code>FALSE</code> or <code>TRUE</code>.</li>
<li><b><code>int</code></b> is an integer number, like <code>-123</code>.</li>
<li><b><code>float</code></b> is a floating-point number, like <code>1.234</code>.</li>
<li><b><code>string</code></b> is a string like <code>"abc"</code>, possibly <code>NULL</code>.</li>
<li><b><code>array</code></b> is an array, like <code>array("a", "b")</code>, possibly <code>NULL</code>.</li>
<li><b><code>resource</code></b> is an handle to a resource, like a file descriptor, possibly <code>NULL</code>.</li>
<li><b><code>object</code></b> is a generic object, possibly <code>NULL</code>.</li>
<li><b><code><i>CLASS_NAME</i></code></b> is an object of the named class, possibly <code>NULL</code>. Declaring new classes is the only way to create
new data types in PHPLint.</li>
<li><b><code>mixed</code></b> is any type of value, possibly NULL.</li>
</ul>

<p>
Using a simplified EBNF notation, a type declaration using the PHPLint
meta-code can be defined as follows:
</p>

<blockquote>
x_type = <code><b>"void"</b></code> | <code><b>"boolean"</b></code> |
<code><b>"int"</b></code> | <code><b>"float"</b></code> |
<code><b>"string"</b></code> |
<i>x_array_type</i> | <code><b>"resource"</b></code> |
<code><b>"mixed"</b></code> | <code><b>"object"</b></code> | <i>class_name</i>
;<br>
</blockquote>

<p>
The syntax of the array type will be explained in the chapter <u>Arrays</u>.
</p>

<p>
Values and variables of different types can be mixed only in few
controlled ways.  The chapter <u>Type compatibility</u> gives the rules
that PHPLint apply when variables or expressions of different type are
assigned together or passed as arguments to a function.
</p>

<p>
The chapter <u>Typecasting</u> explain how an expression of a type can be
converted to an expression of another type.
</p>


<a name=types-the-boolean-type></a>
<h3>The boolean type</h3>

<p>
There are only two possible literal values of the type <b>boolean</b>:
they are the constants <code>FALSE</code> and <code>TRUE</code>.
The lower-case version of these constants <code>false</code> and
<code>true</code> are allowed but their usage is discouraged, since
constants are commonly written in upper-case letters only.  <b>bool</b>
is allowed as an abbreviation for <b>boolean</b>.
</p>


<a name=types-the-int-type></a>
<h3>The int type</h3>

<p>
The integer numbers can be either positive and negative. The range is
limited: typically, on 32-bit processors the minimum value is -2^31 and
the maximum value is 2^31-1. This chunk of code prints the number
of bits available on the computer running the program:
</p>

<blockquote><pre>
/*. int .*/ function size_of_int()
{
    static $n = 0;

    if( $n &gt; 0 )  return $n;
    $n = 1;
    $i = 1;
    while( $i &gt; 0 ){
        $i &lt;&lt;= 1;
        $n++;
    }
    return $n;
}

echo "int size = ", size_of_int(), " bits\n";
# ==&gt; int size = 32 bits
</pre></blockquote>

<p>
While evaluating an expression, if an intermediate result becomes too big
to be represented as an <b>int</b>, the PHP interpreter automatically
promote this value to a <b>float</b>ing-point precision number.
This feature provides an effective way to detect overflow in integer
expressions, for example:
</p>

<blockquote><pre>
$count = $count + $incr;
if( is_float($count) )
    trigger_error("overflow on \$count", E_USER_ERROR);
</pre></blockquote>

<b>integer</b> is allowed as alternative name for <b>int</b>.



<a name=types-the-float-type></a>
<h3>The float type</h3>

<p>
The floating-point numbers include the fractional part, and they can
hold values much bigger than <b>int</b>, but with limited precision.
Float numbers are seldom used in WEB applications; sometimes they are
used to hold monetary values, but the programmer must take care of the
rounding problem, since that might bring to unexpected results also for
simple operations. For example, 0.57-0.56 gives 0.0099999999 rather than
the expected 0.01.
</p>

<p>
<b>double</b> is allowed as an alternative name for <b>float</b>.
</p>


<a name=types-the-string-type></a>
<h3>The string type</h3>

<p>
According to PHPLint, the type <b>string</b> is something that contain
zero, one or more bytes, or possibly the value NULL. The value NULL
is handled by PHP mostly like the empty string, so for
example <code>$s=NULL;&nbsp;echo&nbsp;$s;</code> will display nothing.
The following function will print a string as a proper "PHPLint-compliant"
literal string whatever its value is, including the NULL value,
and can be useful for debugging and logging purposes:
</p>

<blockquote><pre>
/*. string .*/ function stringToLiteral(/*. string .*/ $s)
{
    if( $s === NULL )
        return "NULL";
    else
        return '"' . addcslashes($s, "\000..\037\\\"\$\177..\377") . '"';
}
echo StringToLiteral(NULL);  # ==&gt; NULL
echo StringToLiteral("");    # ==&gt; ""
echo StringToLiteral("\\x\"abc\n\x85{\$x}");
# ==&gt; "\\x\"abc\n\205{\$x}"
</pre></blockquote>

<p>
The function <code>addcslashes()</code> converts all the non-ASCII
printable characters to the corresponding escaped sequence. The double
quote, the back-slash and the dollar character are converted to their
escaped sequence, since they have a special meaning.  Note that the
special NULL value must be treated differently since the function
<code>addcslashes()</code> would consider NULL as an empty string.
</p>

<p>
<b>Double quoted literal strings</b> can contain simple variables.  In PHP
5 also objects of classes providing a <code>__toString()</code> method are
allowed. These variables must already have a value and are accounted as
"used":
</p>

<blockquote>
<code>"Found $n records looking for $name:\n"</code>
</blockquote>

<p>
Variables embedded inside double quoted strings cannot be dereferenced,
and the curly brace syntax is not currently supported by PHPLint. For example
PHPLint will raise an error if any of these forms is used:
</p>

<blockquote>
<code>
"Element value is <b>$arr[$i]</b>"<br>
"Property value is <b>$obj->prop</b>"</br>
"<b>{$x}${x}</b>"
</code>
</blockquote>

<p>
In here-docs and now-docs, if the terminating line contains invisible spaces or
tabulators these are detected and signaled as error.
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#arrays-arrays'>Arrays</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#arrays-the-structured-array-type'>The structured array type</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#arrays-building-arrays-element-by-element'>Building arrays element-by-element</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#arrays-the-array-constructor'>The array constructor</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#arrays-runtime-errors-accessing-arrays'>Runtime errors accessing arrays</a><p>
<a name=arrays-arrays></a>
<h2>Arrays</h2>

<p>
PHP implements the arrays as hash tables whose index can be both integers
and strings of characters, possibly mixed together in the same array.
There are no restrictions on the type of the elements stored inside an
array, and they can be all of different types inside the same array.
Very simple to use, very powerful for quick-and-dirty programming,
very dangerous.
</p>

<p>
Not surprisingly, PHPLint introduces some restriction on how an array
can be defined and used.
</p>



<a name=arrays-the-structured-array-type></a>
<h3>The structured array type</h3>

<p>
Simply declaring that a value is of the type <b>array</b> don't give
very much information to the parser. So, <b>PHPLint</b> allows a more
accurate description of the array structure that provides the type of the
index (<b>int</b>, <b>string</b> or both) and the type of the elements
and that can be expressed informally as:
</p>

<blockquote>
<code><i>E</i>[<i>K</i>]</code>
</blockquote>

<p>
where <i>K</i> is the type of the index (<b>int</b> or <b>string</b> or both if
empty) and <i>E</i> is the type of the elements.
Arrays can also be declared in the form
</p>

<blockquote>
<code>array[<i>K</i>]<i>E</i></code>
</blockquote>

<p>
In this case the element E if omitted is assumed mixed, and if also
the index is omitted then <code>[]</code> is assumed. Then a bare
"<code>array</code>" type is equivalent to <code>array[]mixed</code>.
</p>

<p>
Several indeces may be provided to define a matrix, for example:
<code>float[int][int]</code> is a matrix of floating point numbers. The
rightmost index is the inner index.
</p>


<pre>

</pre>

<DIV><FIELDSET><LEGEND><b>Warning</b></LEGEND>
PHP allows to mix indices of type <b>int</b> and of type <b>string</b> on
the same array. However there is a quirk: as stated by the PHP manual,
<i>if a key</i> (an index, in our discussion) <i>is the standard
representation of an integer, it will interpreted as such.</i> Isn't
unclear to me what the manual exactly mean as "standard representation"
of an integer, but it gives this example: <code>$a[8]</code> and
<code>$a["8"]</code> are the same element, while <code>$a["08"]</code> is
dereferenced actually using the string "08" as an index. In general,
different strings might be evaluated to indices that collide with others
integer numbers.  So, be careful selecting the type of the index that
better matches your needs.
</FIELDSET></DIV>

<pre>

</pre>

<p>
If you really need an associative array that maps both strings and integers
to different values, the problem stated in the box above may be resolved
adding a fixed string to the given index. For example, this code maps
the key <code>$key</code> into the value <code>$value</code>:
</p>

<blockquote>
<code>$map[ "x" . $key ] = $value;</code>
</blockquote>

<p>
This ensures that different values of the <code>$key</code>, that can
be either integer numbers or strings of characters, will be mapped into
distinct elements of the array. Note too that the NULL string (a value
allowed for a <b>string</b> according to the type model of PHPLint) would
be mapped into <code>"x"</code> exactly as the empty string <code>""</code>:
how to resolve this ambiguity is left as an exercise for the reader :-)
</p>




<a name=arrays-building-arrays-element-by-element></a>
<h3>Building arrays element-by-element</h3>

<p>
PHPLint guesses the structure of a variable examining its usage. The
presence of the operator "<code><b>[</b></code>" lets to guess that the
variable is an array, the type of the expression giving the index gives
the type of the index of the array, and the type of the expression
assigned gives the type of the elements. In this example, the type of
the variables is guessed from their usage:
</p>

<blockquote><pre>
$players[] = "Rick"; # Guess: $players is string[int]
$players[] = "John";

$groups['beta'] = $players;  # Guess: $groups is
                             # string[string][int]

$matrix[0][0] = 1.0;  # Guess: $m is float[int][int]
$matrix[0][1] = 0.0;
/* ... */

$params["width"] = 10.0;  # Guess: $parmas is float[string]
$params["height"] = 7.0;
$params["depth"] = 3.0;
</pre></blockquote>







<a name=arrays-the-array-constructor></a>
<h3>The array constructor</h3>

<p>
The <code>array()</code> is a special construct of the PHP language
that allows to define an array, its values and their indices using only
one instruction.  The <code>array()</code> lets to assign both the
elements and the index (or key) of each element. For example, the same
arrays of the example above might be rewritten as:
</p>

<blockquote><pre>
$players = array("Rick", "John");
$groups = array( "beta" =&gt; $players );
$matrix = array( array(1.0, 0.0, 0.0),
                 array(0.0, 1.0, 0.0),
                 array(0.0, 0.0, 1.0));
$params = array("width" =&gt; 10.0, "height" =&gt; 7.0, "depth" =&gt; 3.0);
</pre></blockquote>


<p>
PHPLint parses the <code>array()</code> constructor to guess the type the
resulting array.  The first element of the array can contain an expression
giving the key and an expression giving the value
</p>

<blockquote>
<code>array( KEY =&gt; VALUE, </code>...
</blockquote>

<p>
This first element gives the structure of the array acconding to these rules:
</p>

<ul>
<li>If the key is not present, the index is <b>int</b>.</li>
<li>If the key is present, its type must be <b>int</b> or <b>string</b>,
and the type of the index is set accordingly.</li>
<li>The type of the element gives the type of the elements of the array.</li>
</ul>

<p>
Once the first element of the array constructor has been parsed,
PHPLint scans the remaining elements. Each key/element pair found must
match the type of the first pair. If a key does not match, a warning
message is raised and the type of the index can be either <b>int</b>
or <b>string</b>. If an element does not match the type of the first
element a warning message is raised and the type of the elements of the
array becomes <b>mixed</b>.
</p>

<p>
The empty array <code>array()</code> don't lets PHPLint to guess anything
about the structure of the array, so the resulting type is a generic
<code>array[]</code> with index and element types both unknown.  To build
an empty array of a specific type, you <b>must</b> use a formal type-cast operator
(see chapter <u>Typecasting</u>):
</p>

<blockquote><code>
$file_names = /*. (string[int]) .*/  array();
</code></blockquote>

<p>
The following table summarizes the rules PHPLint applyes trying to detect
the structure of the array. $k is an expression giving a value of the type
K (<b>int</b> or <b>string</b>). $e is an expression giving a value of the
type E.
</p>

<pre>

</pre>
<table align=center cellpadding=5 cellspacing=0 border=1>

<tr>
<th>Array constructor</th>
<th>Detected type</th>
<th>Note</th>
</tr>

<tr>
<td><code>/*.&nbsp;(E[K])&nbsp;.*/&nbsp;array()</code></td>
<td><code>E[K]</code></td>
<td>
The formal typecast is the PHPLint meta-code in the comment that tells to
PHPLint which is the exact expected type of the empty array.
</td>
</tr>

<tr>
<td><code>array()</code></td>
<td><code>UNKNOWN[UNKNOWN]</code></td>
<td>
The type of the index and the type of the elements are both unknown and
the array cannot be used practically. <b>Do not do that.</b>
</td>
</tr>

<tr>
<td><code>array($e, ...)</code></td>
<td><code>E[int]</code></td>
<td>
The type of the index is <b>int</b> and the first element will be stored at
the offset 0. The type of the elements is the type of the expression
$e. If more that one element is present, the others elements must be
of the same type of $e and the keys, if they are present, must be of
type int.
</td>
</tr>

<tr>
<td><code>array($k&nbsp;=&gt;&nbsp;$e, ...)</code></td>
<td><code>E[K]</code></td>
<td>
The type of the index is the type of the expression $k. K must be the
type <b>int</b> or the type <b>string</b>. The type of the elements is
the type of the expression $e. If more that one element is present,
the others elements must be of the same type E and the keys, if they
are present, must be of the type K; missing keys are allowed only
if the guessed type of the key is <b>int</b>.
</td>
</tr>

</table>
<pre>

</pre>

<p>
<b>RESTRICTION.</b> You cannot list elements of different type in the
array() constructor. For example
</p>

<blockquote>
<code>array(1, "two")</code>
</blockquote>

<p>
causes a warning message for mixed types and then the array is assumed
<code>mixed[int]</code>. If you really need to build an array of mixed
elements, first declare the empty array, then add the mixed elements one by
one, like in this example:
</p>

<blockquote>
<pre>
$a = /*. (mixed[int]) .*/ array();
$a[] = 1;
$a[] = "two";
</pre>
</blockquote>

<p>
Some examples (the comments reports the type of the resulting expression):
</p>


<blockquote>
<pre>
# Our test class:
class A { }

# The comment shows the assigned type guessed by PHPLint:
$a0 = array();  // array[]
$a1 = array( 123, 456, 789 );  // int[int]
$a2 = array( 123, 456, "xyz"); // mixed[int] - WARNING: mixing
                               // elements of different types
$a3 = array( 1=&gt;"one", 2=&gt;"two", 8=&gt;"eight");  // string[int]
$a4 = array( array( new A() ) ); // A[int][int]
$a5 = array( "data" => $a4 ); // A[string][int][int]
$x = $a4[0]; // A[int]
$y = $a4[0][0]; // A

/**
 * Builds a row of objects A.
 * @param int $width Number of elements in the row.
 * @return A[int] Array of exactly $width A objects.
 */
function BuildRow($width)
{
    $row = array( new A() );
    for( $i = 1; $i &lt; $width; $i++ )  $row[$i] = new A();
    return $row;
}

/**
 * Builds a matrix of objects A.
 * @param int $width Width of the matrix (columns).
 * @param int $height Height of the matrix (rows).
 * @return A[int][int] The matrix of $width*$height A
 * objects.
 */
function BuildMatrix($width, $height)
{
    $m = array( BuildRow($width) );
    for( $i = 1; $i &lt; $height; $i++ )  $m[] = BuildRow($width);
    return $m;
}

$matrix = BuildMatrix(4, 4);  // A[int][int]
</pre>
</blockquote>


<p>
Unsure of the actual type of a variable? PHPlint can tell you with this
little trick:
</p>

<blockquote>
<pre>
if( $a5 ) ;

    <b>ERROR: `if(EXPR)': expected expression of the type boolean, but found
    A[string][int][int]. Remember that an array with zero elements evaluates
    to FALSE, and an array with one or more elements evaluates to TRUE.</b>
</pre>
</blockquote>



<a name=arrays-runtime-errors-accessing-arrays></a>
<h3>Runtime errors accessing arrays</h3>

<p>
The formal validation of the source does not prevent errors that may be
detected only at runtime by the PHP interpreter. Arrays are particularly prone
to bugs that cannot be detected with a static analisys (or, at least, that
PHPLint cannot detect yet). One of the most common errors of this type is
accessing a missing entry, like in this example:
</p>

<blockquote>
<pre>
&lt;?php
error_reporting(-1);

$a = array(1, 2, 3);
var_dump($a[9]);

<b>==&gt; Notice: Undefined offset: 9 in /home/salsi/test.php on line 5
    NULL</b>
</pre>
</blockquote>

<p>
The error here is evident to the human eye: we are accessing an element of the
array that does not exist, PHP recognizes the issue and reports a notice just
because I have set the maximum error level detection (-1), but the program
still continues running possibly generating random results. On a real
program, things becomes rapidly more complicated, and detecting errors like
these becomes really difficult. My suggestions are:
</p>

<ul>

<li>
<b>Prevention.</b>
Apply PHPLint for a first, formal validation. Also review the code and try to
make it clean and readable. Use the <code>array_key_exists(key, arr)</code>
function if you are not sure if a certain key exists. Every function and method
should check if its arguments are valid and in the expected range; if not, an
<tt>IllegalAegumentException</tt> or a <tt>RuntimeException</tt> should be
thrown; these exceptions are unchecked under PHPLint, that is they should cause
an immediate abort because are the clear symptom of a bug.
</li>

<li>
<b>Testing.</b>
Every important package or class should have its
own test suite. For example, for every <tt>MyClass.php</tt> there might be a
<tt>test-MyClass.php</tt> that performs a number of tests on every method and
with different input parameters. Run the whole set of test units before the
deployment of a new release.
</li>

<li>
<b>Enable maximum runtime error detection level.</b>
You may either set it in the php.ini once for all:
<blockquote>
<code>error_reporting = E_ALL | E_STRICT | E_STYLE | E_DEPRECATED</code>
</blockquote>
or you may set it at runtime like in the example above. Also remember to send
error message to a log file, typically the error log file of the WEB server,
and do not display errors to the user (display_errors = Off). Always read
carefully the log, every day, and refine you program until the number of
messages be reduced to a minimum.
</li>

<li>
<b>Dead programs are better than zombie programs.</b>
Safety (data integrity, etc.) and security increase if the program gets killed
as soon as possible whenever an unexpected problem is detected. Also the
"notice" we saw above <b>is</b> a potential security and safety risk we must
avoid absolutely. PHPLint provides the <code>errors.php</code> package along
with its library: this package maps errors (E_NOTICEs included) into exceptions
that normally stop the execution and generate a detailed report with stack
trace.
</li>

</ul>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#typecompatibility-type-compatibility'>Type compatibility</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecompatibility-assignment'>Assignment</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecompatibility-comparison-operators'>Comparison operators</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecompatibility-strict-equality-operators'>Strict equality operators</a><p>
<a name=typecompatibility-type-compatibility></a>
<h2>Type compatibility</h2>

<p>
As a general rule, PHPLint does not allow to mix values and variables of
different types.  So, for example, if <code>$i</code> is a variable of type
<b>int</b>, PHPLint expects this variable appears inside an expression that
involves only integer numbers.
</p>

<p>
PHPLint relaxes this strict compatibility rule with some exceptions that are
detailed here. Moreover the chapter <u>Typecasting</u> explains how a value
of given type can be converted into another type in a safe, controlled way.
</p>



<a name=typecompatibility-assignment></a>
<h3>Assignment</h3>

<p>
A <i>right hand side</i> (RHS) is the expression that generates a value,
while a <i>left hand side</i> (LHS) is the entity that stores this value.
The type of the RHS expression is checked against the type expected by
the LHS in these cases:
</p>

<ul>
<li>Assignment instructions: LHS = RHS, LHS += RHS, LHS .= RHS, etc.</li>

<li>Function and method declarations may define a default value (RHS) for
the default formal arguments (LHS).</li>

<li>Calling a function or a method:<p>

	<ul>
	<li>if the actual argument is passed by value (the default) its type
	    is the RHS and the type of the formal argument is the LHS;
	</li>

	<li>if the actual argument is passed by reference or returns by reference,
		that is the formal argument has the attribute "&amp;", then its
	    type is the LHS and the type of the formal argument is the RHS.
	</li>

	</ul>
</li>

<li>Initial value (RHS) of a class property (LHS).</li>

<li>The value generated by the instruction <code>return RHS;</code> is checked
against the function type (LHS).</li>
</ul>

<p>
The table below summarizes the rules PHPLint applies when a value of the
type RHS is assigned (passed by value, etc.) to a variable of the type LHS:
</p>

<pre>

</pre>

<table border=1 cellspacing=0 cellpadding=3>

<tr>
<td colspan=2 rowspan=2>&nbsp;</td>
<th colspan=12 bgcolor="#ddddff">R H S</th>
</tr>

<tr bgcolor=ccccff>
<th>(unk.)</th>
<th>(null)</th>
<th>void</th>
<th>bool.</th>
<th>int</th>
<th>fl.</th>
<th>str.</th>
<th>arr.</th>
<th>mix.</th>
<th>res.</th>
<th>obj.</th>
<th>(cl.)</th>
</tr>

<tr>
<th rowspan=12 bgcolor="#ddddff">L<p>H<p>S</th>
<th bgcolor="#ccccff">(unknown)</th>
<td>I</td>
<td>W</td>
<td>E</td>
<td>W</td>
<td>W</td>
<td>W</td>
<td>W</td>
<td>W</td>
<td>W</td>
<td>W</td>
<td>W</td>
<td>W</td>
</tr>

<tr>
<th bgcolor="#ccccff">(null)</th>
<td>I</td>
<td>-</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>W</td>
<td>W</td>
<td>W</td>
<td>W</td>
<td>W</td>
<td>W</td>
</tr>

<tr>
<th bgcolor="#ccccff">void</th>
<td>I</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
</tr>

<tr>
<th bgcolor="#ccccff">boolean</th>
<td>I</td>
<td>E</td>
<td>E</td>
<td>-</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>W</td>
<td>E</td>
<td>E</td>
<td>E</td>
</tr>

<tr>
<th bgcolor="#ccccff">int</th>
<td>I</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>-</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>W</td>
<td>E</td>
<td>E</td>
<td>E</td>
</tr>

<tr>
<th bgcolor="#ccccff">float</th>
<td>I</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>-</td>
<td>-</td>
<td>E</td>
<td>E</td>
<td>W</td>
<td>E</td>
<td>E</td>
<td>E</td>
</tr>

<tr>
<th bgcolor="#ccccff">string</th>
<td>I</td>
<td>-</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>-</td>
<td>E</td>
<td>W</td>
<td>E</td>
<td>E</td>
<td>E</td>
</tr>

<tr>
<th bgcolor="#ccccff">array</th>
<td>I</td>
<td>-</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>A</td>
<td>W</td>
<td>E</td>
<td>E</td>
<td>E</td>
</tr>

<tr>
<th bgcolor="#ccccff">mixed</th>
<td>I</td>
<td>-</td>
<td>E</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<th bgcolor="#ccccff">resource</th>
<td>I</td>
<td>-</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>W</td>
<td>-</td>
<td>E</td>
<td>E</td>
</tr>

<tr>
<th bgcolor="#ccccff">object</th>
<td>I</td>
<td>-</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>W</td>
<td>E</td>
<td>-</td>
<td>-</td>
</tr>

<tr>
<th bgcolor="#ccccff">(class)</th>
<td>I</td>
<td>-</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>E</td>
<td>W</td>
<td>E</td>
<td>E</td>
<td>C</td>
</tr>

</table>



<pre>

</pre>

<p>
LEGEND:<br>
I = Ignore. The RHS is of unknown type (for example, a variable never
encountered before), so the assignment cannot be checked.  No error message
is raised, since an error message has been already raised once the RHS of
unknown type was parsed.<br>
E = Raise an error message.<br>
W = Raise a warning message.<br>
A = Arrays are compared index by index and element type by element
type. The LHS index can be unknown or the LHS index and the RHS index
must be both <b>int</b> or both <b>string</b>. The types of the elements must
match as LHS and RHS. The match might raise a warning message or an error.<br>
</p>
C = The RHS must be an object of the same class of the LHS, or a class
derived from the the same class of the LHS, otherwise an error message
is raised.<br>
</p>



<a name=typecompatibility-comparison-operators></a>
<h3>Comparison operators</h3>

<p>
All the comparison operators <code>&lt; &lt;= == &gt;= &gt;</code>
generate a boolean value. For the sake of brevity, we will call the
operators <code>==</code> and <code>!=</code> <i>equality operators</i>.
The PHP language applies some really complex rules and automatic conversions
to the values being compared. For example:
</p>

<blockquote>
<code>"123" == 123</code> is <code>TRUE</code> because the string is
automatically converted into an integer number;<br>
<code>NULL == ""</code> is <code>TRUE</code> because the <code>NULL</code>
value is equivalent to the empty string;<br>
<code>array() == NULL</code> is <code>TRUE</code>;<br>
<code>0.57 - 0.56 == 0.1</code> is <code>FALSE</code>.
</blockquote>

<p>
PHPLint simplifies these rules and forces a more consistent way of handling
the comparisons. In the table below you may think at the first column
as the left term of the comparison, and the second column gives the
types that can appear in the right term of the comparison:
</p>

<pre>

</pre>

<table border=1 cellspacing=0 cellpadding=3>

<tr bgcolor="#ccccff">
<th>Type</th>
<th>Comparison with
== != &lt; &lt;= &gt;= &gt;
</th>
</tr>

<tr>
<th valign=top><b>(unknown)</b></th>
<td>
Value of unknown type cannot be compared at all. These values of unknown type
apper when PHPLint was unable to parse successfully the source code.
</td>
</tr>

<tr>
<th valign=top><b>null</b></th>
<td>
The only expression that may generate a value of the type <b>null</b>
is the constant <code>NULL</code>. This value can be compared with other
types as listed below.
</td>
</tr>

<tr>
<th valign=top><b>void</b></th>
<td>
This value returns from functions that... do not return a value,
so it cannot be compared and PHPLint raises an error.
</td>
</tr>

<tr>
<th valign=top><b>boolean</b></th>
<td>
A <b>boolean</b> value can be compared with another <b>boolean</b> value
using the equality operators <code>==</code> and <code>!=</code>.
Any other comparison operator raises an error.
</td>
</tr>

<tr>
<th valign=top><b>int</b></th>
<td>
An <b>int</b> value can be compared with another <b>int</b>.
If you need to compare an integer value versus a floating point number, it is
responsability of the programmer to convert explicitly the <b>int</b>
into <b>float</b> using the <code>(float)</code> typecast, something like
<code>if( $x &lt; (float) $i ) ...</code>
</td>
</tr>

<tr>
<th valign=top><b>float</b></th>
<td>
A <b>float</b> value can be compared with another <b>float</b> using
the operators <code>&lt; &lt;= &gt;=</code> and <code>&gt;</code>.
Two floating point numbers cannot be compared with the equality operators
- see the box below. Comparison against an integer number requires
that the integer number be converted into <b>float</b>.
Remember also that floating point numbers in the IEEE 754 format can also be
NAN or INF or -INF that must be compared with caution. In particular NAN != NAN
and NAN != from any float, so you must use <code>is_nan()</code> to check for
this value; moreover also INF != INF and INF != from any float so you must use
<code>is_infinite()</code> to check for INF and -INF. See also
<code>is_finite()</code>.
</td>
</tr>

<tr>
<th valign=top><b>string</b></th>
<td>
Strings cannot be compared at all. Either use a strict comparison operator
(see the next paragraph) or the function <code>strcmp()</code>.  See the
chapter <u>How To...</u> for some examples on how to translate an unsafe
string comparison into a PHPLint-compliant safe string comparison.
</td>
</tr>

<tr>
<th valign=top><b>array</b></th>
<td>
Arrays cannot be compared at all. See the next paragraph about the
strict equality operators.
</td>
</tr>

<tr>
<th valign=top><b>mixed</b></th>
<td>
A value of type mixed cannot be compared. Typically mixed values come
from predefined superglobal variables or standard functions that might
return values of different types: always check the actual type of
the value and apply the proper type-cast before the comparison.
</td>
</tr>

<tr>
<th valign=top><b>resource</b></th>
<td>
A <b>resource</b> can be compared with another <b>resource</b> or
with the <code>NULL</code> value using the equality operators.
</td>
</tr>

<tr>
<th valign=top><b>object</b><br><b>(class)</b></th>
<td>
An object can be compared with the <code>NULL</code> value using an equality
operator. Two objects cannot be compared with weak operators. See the next
paragraph about the strict equality operators.
</td>
</tr>

</table>

<pre>

</pre>

<p>
Note that a <b>float</b> value cannot be compared with an <b>int</b> value:
either apply an <code>(int)</code> typecast to the <b>float</b> value, or
apply a <code>(float)</code> typecast to the <b>int</b> value.
</p>


<DIV><FIELDSET><LEGEND><b>Warning</b></LEGEND>
<p>
Floating point numbers should not be used as "bigger integers with decimals".
Instead they are numbers with high range of values, but limited precision.
The precision cannot be controlled in an effective way, so that simple
calculations might give unpredictable results. For example, this logical
expression gives <code>FALSE</code>:
<p>
<code>0.57 - 0.56 == 0.01</code>
<p>
This is the reason why PHPLint raises a notice messages on comparisons between
floating point numbers.
Do not use floating point numbers to store currency values that might be
fractional, like euro-cents or dollar-cents because their limited precision
can cause rounding errors and other unexpected results.
Please read carefully the manual page
<a href="http://www.php.net/manual/en/language.types.float.php">www.php.net/manual/en/language.types.float.php</a>.
</FIELDSET></DIV>





<a name=typecompatibility-strict-equality-operators></a>
<h3>Strict equality operators</h3>

<p>
The operator of strict equality <code>===</code> gives <code>TRUE</code>
if and only if the operands are both of the same type and they have the
"same value".  If the two operands are of the same type, the "same value"
concept may be expressed as follows:
</p>

<pre>

</pre>

<table border=1 cellspacing=0 cellpadding=3>

<tr bgcolor="#ccccff">
<th>Type</th>
<th>Comparison with === (negate the sentence for !==)</th>
</tr>

<tr>
<th valign=top>boolean</th>
<td>
Gives <code>TRUE</code> if the operands are both <code>FALSE</code> or both <code>TRUE</code>.
</td>
</tr>

<tr>
<th valign=top>int</th>
<td>
Gives <code>TRUE</code> if the two integer numbers are equal.
</td>
</tr>

<tr>
<th valign=top>float</th>
<td>
Gives <code>TRUE</code> if the two floating point numbers are equal. Floating
point numbers in the IEEE 754 format can also be NAN or INF or -INF that must
be compared with caution. In particular NAN !== NAN and NAN != from any float,
so you must use <code>is_nan()</code> to check for this value. On the contrary,
for some obscure reason, under PHP INF === INF.
</td>
</tr>

<tr>
<th valign=top>string</th>
<td>
Gives <code>TRUE</code> if the two strings are both <code>NULL</code>
or they contain the same sequence of bytes. For example, <code>"abc" ===
"ab"."c"</code> gives <code>TRUE</code>.
</td>
</tr>

<tr>
<th valign=top>array</th>
<td>
Gives <code>TRUE</code> if both the arrays are <code>NULL</code> or
they contains the same index/value pairs in the same order, element by
element; the index/value pairs are compared with the strict equality
operator itself.  For example, <code>array(0, 1, 2) === array(0, 1,
2)</code> gives <code>TRUE</code> because the arrays both contains
the same index/value pairs in the same order.  Instead, the comparison
<code>array(0, 1, 2) === array(0=&gt;0, 2=&gt;2, 1=&gt;1)</code> gives
<code>FALSE</code> because, although the index/value pairs are the same,
the elements are stored in memory in a different internal order.
</td>
</tr>

<tr>
<th valign=top>mixed</th>
<td>
The result depends on the type of the two operands, and can be computed
only at run-time.
</td>
</tr>

<tr>
<th valign=top>resource</th>
<td>
Gives <code>TRUE</code> if the two operands are both <code>NULL</code>
or are the same resource.  For example, <code>fopen("xyz", "r") ===
fopen("xyz", "r")</code> gives <code>FALSE</code> because each call to the
<code>fopen()</code> function returns a different file handle.
</td>
</tr>

<tr>
<th valign=top>object<br>(class)</th>
<td>
Gives <code>TRUE</code> if the two operands are both <code>NULL</code> or
are the same object.  Note that <code>new ACLASS() === new ACLASS()</code>
always gives <code>FALSE</code> because the operands are two different
instances of the class "ACLASS".
</td>
</tr>

</table>


<pre>

</pre>

<p>
The operator of strict inequality <code>!==</code> just gives the logical
negation of the strict equality operator <code>===</code>: the result
is <code>TRUE</code> only if the two operands are of different types or
of different values.
</p>

<p>
Some functions of the standard library are formally declared to return
a value of a given type, but in some cases they can return values of
different type too.  For example, the function <code>fopen()</code>
normally returns a value of the type <b>resource</b> if the file was
opened successfully, but the same function returns the <b>boolean</b>
value <code>FALSE</code> when an error occurs. Here is the correct way
to check for such error:
</p>

<blockquote>
<pre>$f = @fopen($fn, "r");
if( $f === FALSE )
    die("fopen($fn, r): $php_errormsg");
</pre></blockquote>

<p>
Note that we cannot use the simple equality operator <code>==</code>
since PHPLint would raise an error message because the two operands are of
different types (<code>$f</code> is a <b>resource</b>, <code>FALSE</code>
is a <b>boolean</b> value).
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#typecasting-typecasting'>Typecasting</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecasting-value-conversion-operators'>Value conversion operators</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecasting-formal-type-conversion-operators'>Formal type conversion operators</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#typecasting-the-cast-t-v-magic-function'>The cast(T,V) magic function</a><p>
<a name=typecasting-typecasting></a>
<h2>Typecasting</h2>


<p>
With the word <i>typecasting</i> we mean a way to convert a given type or value
into another type or value. This conversion can happen at validation time (and
then it is a bare type conversion that invoves PHPLint only) or at execution
time (and then it is type or value conversion process that involves both
PHPLint and PHP).
</p>


<a name=typecasting-value-conversion-operators></a>
<h3>Value conversion operators</h3>

<p>
A <i>value conversion operator</i> is an internal function of the PHP
interpreter that lets to convert a value of a given type into a value of
another type. The general syntax is a sub-expression of the form:
</p>

<blockquote><code>(type) term</code></blockquote>

<p>
PHPLint (and PHP) allows for these value conversion operators:
</p>

<pre>

</pre>

<table cellspacing=0 cellpadding=3 border=2>

<tr bgcolor=ccccff>
<th>Value conversion operator</th>
<th>Applied to</th>
<th>Description</th>
</tr>

<tr>
<td valign=top><code>(int)</code></td>

<td valign=top><b>boolean</b></td>

<td valign=top>
Gives <code>0</code> if the boolean term
is <code>FALSE</code>, or <code>1</code> if <code>TRUE</code>.
</td>
</tr>



<tr>
<td valign=top><code>(bool)</code></td>

<td valign=top><b>int</b></td>

<td valign=top>
Gives <code>FALSE</code> if the value of the
term is zero; gives <code>TRUE</code> for any other integer value.
</td>
</tr>



<tr>
<td valign=top><code>(float)</code></td>

<td valign=top><b>int</b></td>

<td valign=top>
Gives the floating-point representation of the
integer number.
</td>
</tr>



<tr>
<td valign=top><code>(string)</code></td>

<td valign=top><b>int</b></td>

<td valign=top>
Gives the string representation of the
integer number in decimal notation; a leading minus sign is prepended
if negative.
</td>
</tr>



<tr>
<td valign=top><code>(int)</code></td>

<td valign=top><b>float</b></td>

<td valign=top>
Gives an integer number that is the integral
part of the given floating-point number. If the float number is too large,
or it is not finite, an unpredictable value results.
</td>
</tr>



<tr>
<td valign=top><code>(string)</code></td>

<td valign=top><b>float</b></td>

<td valign=top>
Gives a string representation of the given
floating-point number in decimal notation, possibly also \"NAN\", \"INF\" or \"-INF\". Note that in the conversion
from the internal binary representation to the decimal representation
we might loose precision.
</td>
</tr>



<tr>
<td valign=top><code>(int)</code></td>

<td valign=top><b>string</b></td>

<td valign=top>
Given a string that is the decimal
representation of an integer number, gives the corresponding integer
number. If the string is not a valid representation of an integer number,
or it is a number too large, the result is an undefined integer value.
If the string is <code>NULL</code>, the result is <code>0</code>.
</td>
</tr>



<tr>
<td valign=top><code>(float)</code></td>

<td valign=top><b>string</b></td>

<td valign=top>
Given a string that is the decimal
representation of a floating-point number, gives the corresponding
floating-point number. If the string is not a valid representation
of a floating-point number, or it is too large, the result is an
undefined floating-point value. Note that in the conversion from the
decimal representation to the internal binary representation we might
loose precision.
If the string is <code>NULL</code>, the result is
<code>0.0</code>.
<br>
<b>WARNING.</b> Non-finite representations of floating point numbers are not
translated properly: the strings \"NAN\" and \"INF\" both give 0.0, while
\"-INF\" gives -0.0. These special values must then be converted apart.
</td>
</tr>



<tr>
<td valign=top><code>(bool)<br>(int)<br>(float)<br>(string)</code></td>

<td valign=top><b>mixed</b></td>

<td valign=top>
Since the type
of the term is known only at run-time, the program should take care to
detect the actual type of the value using one of the following functions
and then apply the proper value conversion operator:
<code>is_bool()</code>, <code>is_int()</code>, <code>is_float()</code>,
<code>is_number()</code>, <code>is_string()</code>. Please note that
<code>is_string(\$s)</code> will give <code>FALSE</code> if <code>\$s===NULL</code>.
</td>
</tr>



<tr>
<td valign=top><code>(string)</code></td>

<td valign=top><b><i>object of some class</i></b></td>

<td valign=top>
In PHP 5 objects of classes providing a <code>__toString()</code> method
can be converted to <b>string</b>.
</td>
</tr>

</table>
<pre>

</pre>




<a name=typecasting-formal-type-conversion-operators></a>
<h3>Formal type conversion operators</h3>

<p>
A <i>type conversion operator</i> allows to specify the exact type of the
<tt>NULL</tt> value and of the empty array <tt>array()</tt>, so driving PHPLint
to the correct interpretation of these values.
<p>

<pre>

</pre>

<table cellspacing=0 cellpadding=3 border=2>

<tr bgcolor=ccccff>
<th>Type conversion operator</th>
<th>Applied to</th>
<th>Description</th>
</tr>

<tr>
<td valign=top><code>/*. (string) .*/<br>/*.&nbsp;(array)&nbsp;.*/<br>/*.&nbsp;(array&nbsp;...)&nbsp;.*/<br>/*. (resource)
.*/<br>/*. (object) .*/<br>/*.&nbsp;(</code><i>CLASS_NAME</i>&nbsp;<code>)&nbsp;.*/
</code>
</td>

<td valign=top><b>null</b></td>

<td valign=top>
The <code>NULL</code> value can be formally converted into any
type which is a reference according to the PHPLint type model (see chapter
<u>Types</u>).
</td>
</tr>



<tr>
<td valign=top><code>/*. (array ... ) .*/</code></td>

<td valign=top><b>array()</b></td>

<td valign=top>
This operator lets to declare
the structure of the empty <b>array()</b>. Note that
this operator cannot be applied to an array of a known structure; an
array of a given structure can be converted to an array of a different
structure using a specific algorithm.
</td>

</table>
<pre>


</pre>

<p>Examples:</p>

<blockquote><pre>
$processed_users = <b>/*. (string[int]) .*/ array()</b>;

$logger = <b>/*. (LoggerInterface) .*/ NULL</b>;


/*. string .*/ function makeTmpFile($dir = <b>/*. (string) .*/ NULL</b>)
{
    if( $dir === NULL )
        $dir = "C:\\TEMP";
    return tempnam($dir, "dat");
}
</pre></blockquote>





<a name=typecasting-the-cast-t-v-magic-function></a>
<h3>The cast(T,V) magic function</h3>

<pre>

</pre>
<table align=center width='70%' cellspacing=0 cellpadding=10 border=1><tr><td>
<b>Not available under PHP 4</b>
<br>&nbsp;<br>
The <code>cast()</code> magic function is available only under PHP 5. Under PHP
4 you may stick with the unsafe formal type conversion operator <code>/*. (T)
.*/</code> that does not perform any check at runtime, but assumes the
programmer already made the required checks with some test code, for example:
<pre>
if ( $x instanceof MyClass )
    $p = /*. (MyClass) .*/ $x;
else
    die("invalid value for x");</pre>
</td></tr></table>
<pre>

</pre>

<p>
The chapter <b>PHPLint's Standard Library</b> describes the <tt>cast.php</tt>
package that provides the standard implementation of the <code>cast()</code>
function. Importing this package in your programs allows then to perfom formal
typecast that are checked at runtime:
</p>

<blockquote>
<code>$x = cast(<i>T</i>, <i>V</i>);</code>
</blockquote>

<p>
where <code><i>T</i></code> is a string giving the type descriptor,
and <code><i>V</i></code> is any expression.
The <tt>cast()</tt> magic function then provides 2 well dinstinct features:

<ul>

<li>
<b>At parse time</b> tells to PHPLint that <code><i>T</i></code> is the
expected type of <code><i>V</i></code>.
</li>

<li>
<b>At runtime</b> the value <code><i>V</i></code> must be a valid value for
the type expected. Note that the special NULL value is a valid value for
all those types that are "references" according to the PHPLint type model,
then string, resource, array or object.
</li>

</ul>

<p>
It is important to stress that the <tt>cast()</tt> magic function <b>does not
perform any value conversion</b> and it either returns the same value
<code><i>V</i></code> if valid, or it throws ErrorException if the value does
not match the type.
</p>

<p>
The <tt>cast()</tt> magic function is "magic" in the sense that if a function
with this name gets defined, the PHPLint handles it in a special way. First
of all, this function must have a signature that match this prototype:
</p>

<blockquote><pre>
mixed <b>cast</b>(string $type, mixed $value)
    throws CastException;
</pre></blockquote>

<p>
where <tt>$value</tt> is some expression whose type has to be checked against
the <tt>$type</tt> descriptore specified. The type descriptor must be an
expression of type string that PHPLint can evaluate statically; normally it is
a literal string. Class names must be indicated with their fully qualified name,
for example <code>it\icosaedro\bignumbers\BigInt</code> (hint: inside a method, the
PHP magic constant <code>__CLASS__</code> privides the FQN of the
class itself).
</p>

<p>
Then this function does not really return <tt>mixed</tt> as the prototype
states, but it always return a value of the specified type, or a value whose
type is compatible with it according to the specifications that follow.
Examples:
</p>


<blockquote>
<code>$name = cast("string", $_GET['name']);</code>
<p>
If <code>$_GET['n']</code> is not set this statement gives E_NOTICE and
evaluates to NULL; if errors to exceptions remapping is enabled, an
ErroException is thrown. If set, it can be either a string or an array: in the
first case that string is assigned to $name; in the latter case an
ErrorException is thrown. The final result is that the <code>$name</code> takes
either NULL or a string of characters.
</blockquote>

<blockquote>
<code>$bi = cast("it\\icosaedro\\bignumbers\\BigInt", $_SESSION['v']);</code>
<p>
If <code>$_SESSION['v']</code> is not set, this statement gives E_NOTICE and
evaluates to NULL; if errors to exceptions remapping is enabled, an
ErrorException is thrown. If set, its value matches the type only if NULL or if
it is an instance of the specified class. The final result is that the
<code>$bi</code> variable takes either NULL or an instance of the specified
class.
</blockquote>

<blockquote>
<code>$names = cast("string[int]", unserialize($names_serialized));</code>
<p>
If the <code>unserialize()</code> function fails to decode the data, an
E_NOTICE is raised and that function returns FALSE; if errors to exceptions
remapping is enabled, an ErrorException is thrown. The resulting unserialized
value must be either the NULL value or an array of strings with int indeces, or
ErrorException is thrown. The final result is that the <code>$names</code>
variable takes a value compatible with the expected type.
</blockquote>

<p>
The syntax of the type accepted by <tt>cast()</tt> can be described
in EBNF form as follows (the vertical bar is the alternative operator,
while <code>{A}</code> is a part that may be repeated 0 or more times):
</p>


<blockquote><pre>
type = type_name {index} | "array" index {index} type_name;

type_name = "boolean" | "bool" | "int" | "float" | "double" | "real"
            | "string" | "resource" | "object" | FQN_OF_CLASS;

index = "[]" | "[int]" | "[string]";
</pre></blockquote>


<p>
It is important to note that:

<ul>

<li>
<b>There is not a "mixed" type,</b> as this type does not really exists in PHP
at runtime (there is no a is_mixed() function) but it is purely fictional in
PHPLint. Here <tt>object</tt> matches any instance of a class, while
<tt>FQN_OF_CLASS</tt> is the fully qualified name of any existing class or
interface.
</li>

<li>
<b>Arrays always require to specify the index and the type of the
elements,</b> so <code>array</code> (missing index and element type) and
<code>array[]</code> (missing element type) are not allowed.
</li>

<li>
<b>Classes must be always indicated with their fully qualified name.</b> This
is because the implementation of the <code>cast()</code> function does not know
which is the namespace context from which it has been called. Then the full name
of the class must be specified in order to univocally resolve and possibly
autoload the class.
</li>

</ul>

<p>
The type descriptor is a string that gets parsed at runtime, which is a quite
expensive task. The result of the parsing is then cached internally in a
compiled form by the <code>cast()</code> function and a fast look-up retrieves
the same compiled form whenever the same type descriptor is required again
later.


<pre>

</pre>
<table border=1 cellspacing=0 cellpadding=5>

<tr>
<th colspan=2 rowspan=2>cast(T,V)</th>
<th colspan=8>Type of the expression V detected by PHPLint</th>
</tr>

<tr>
<th>boolean</th>
<th>int</th>
<th>float</th>
<th>string</th>
<th>array</th>
<th>resource</th>
<th>object or CLASS</th>
<th>mixed</th>
</tr>


<tr>
<th rowspan=7>T</th>
<th>"boolean"</th>
<td>OK<sup>(b)</sup></td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>OK<sup>(a)</sup></td>
</tr>


<tr>
<th>"int"</th>
<td>NO</td>
<td>OK<sup>(b)</sup></td>
<td>NO<sup>(e)</sup></td>
<td>NO<sup>(d)</sup></td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>OK<sup>(a)</sup></td>
</tr>


<tr>
<th>"float"</th>
<td>NO</td>
<td>NO<sup>(f)</sup></td>
<td>OK<sup>(b)</sup></td>
<td>NO<sup>(d)</sup></td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>OK<sup>(a)</sup></td>
</tr>


<tr>
<th>"string"</th>
<td>NO<sup>(g)</sup></td>
<td>NO<sup>(h)</sup></td>
<td>NO<sup>(h)</sup></td>
<td>OK<sup>(b)</sup></td>
<td>NO</td>
<td>NO</td>
<td>NO<sup>(i)</sup></td>
<td>OK<sup>(a)</sup></td>
</tr>


<tr>
<th>"array..."</th>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>OK<sup>(j)</sup></td>
<td>NO</td>
<td>NO</td>
<td>OK<sup>(j)</sup></td>
</tr>


<tr>
<th>"resource"</th>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>OK<sup>(b)</sup></td>
<td>NO</td>
<td>OK<sup>(a)</sup></td>
</tr>


<tr>
<th>"CLASS"</th>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td>OK<sup>(c)</sup></td>
<td>OK<sup>(a)</sup></td>
</tr>

</table>
<p>
<b>Legenda:</b><br>
a) <code>code("T",<i>mixed</i>)</code> performs runtime check on the actual
type of the mixed expression, and performs unboxing of simple types boolean,
int and float.<br>
b) <code>cast("T",<i>T</i>)</code> is useless has PHPLint already has detected
the type of the expression.<br>
c) In <code>cast("CLASS", $obj)</code> $obj must be NULL or an instance of the
class CLASS.<br>
d) To convert a string representing a number into number use the PHP's typecast
operators <code>(int)</code> and <code>(float)</code>.<br>
e) To convert float into int you may use the PHP's typecast operator
<code>(int)</code>.<br>
f) To convert int into float you may use the PHP's typecast operator
<code>(float)</code>.<br>
g) To convert boolean into string you may use this espression:
<code>((V?) "TRUE" : "FALSE")</code>.<br>
h) To convert int or float into string you may use the PHP's typecast operator
<code>(int)</code> and <code>(float)</code>. The function
<code>sprintf()</code> provides a finer control on the result.<br>
i) Objects that implements the <code>__toString()</code> method can be converted
into string either using the PHP's <code>(string)</code> typecast operator or
calling directly that method. That method is invoked automatically for objects
that appear in string concatenation and inside the <code>echo</code> statement.
<br>
j) As a general rule, <code>cast("E[I]",V)</code> matches only V
of type mixed that at runtime is NULL or an array of the specified exact type,
or a generic array of unspecified index type and elements that at runtime
has the exact specified type.
The discussion below details how this match is performed.<br>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#classes-classes'>Classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-introduction'>Introduction</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-class-constants'>Class constants</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-properties'>Properties</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-methods'>Methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-methods-attributes'>Methods attributes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-inheritance-and-methods-overriding'>Inheritance and methods overriding</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-accessing-to-the-methods'>Accessing to the methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-special-methods'>Special methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-abstract-classes'>Abstract classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#classes-interfaces'>Interfaces</a><p>
<a name=classes-classes></a>
<h2>Classes</h2>

<a name=classes-introduction></a>
<h3>Introduction</h3>

<p>
PHP 5 introduces many new features in its OOP model: class constants,
the visibility attributes (public, protected, private), the "static"
and "final" attributes, object introspection, etc.  PHPLint generally
supports all the features of PHP5, but it adds some restrictions and
detects some weakness of the language: the differences are here detailed.
</p>

<p>
Lets see an example:
</p>

<blockquote><pre>
class A {
    const a_string = "The current value is ";
    public $an_int = 1;
    private /*. mixed .*/ $anything;

    public /*. void .*/ function __construct(/*. int .*/ $n)
    { 
        $this-&gt;an_int = $n;
    }

    public /*. string .*/ function Get()
    {
        return A::a_string . $this-&gt;an_int;
    }
}
</pre></blockquote>

<p>
The only entities that require an explicit type are the property
<code>$anything</code> and the formal argument <code>$n</code>.
</p>


<a name=classes-class-constants></a>
<h3>Class constants</h3>

<p>
Class constants can be declared using a syntax similar to this one:
</p>

<blockquote>
<pre>
/*. <i>visibility</i> .*/ const
    CONSTNAME1 = STATICEXPR1,
    CONSTNAME2 = STATICEXPR2,
    CONSTNAME3 = STATICEXPR3;
</pre>
</blockquote>

<p>
Class constants never require (nor <b>PHPLint</b> will allow to provide)
an explicit type: the type of a constant is always given implicitly by
its value.
</p>

<p>
Class constants are <b>public</b> by default, but an explicit visibility
attribute can be provided as PHPLint meta-code.
<b>private</b> class constants are not reported by the PHPLint Documentator.
</p>

<p>
<b>Accessing.</b>
Class constants can be accessed in several ways, depending on the context:
</p>

<blockquote>

<p>
<code>self::CONSTNAME</code>
<br>
Inside a class to access a local constant or an inherited non-private
constant.
</p>

<p>
<code>parent::CONSTNAME</code>
<br>
Inside a class to access a non-private constant of a parent class, possibly
re-defined inside the current class.
</p>

<p>
<code>CLASSNAME::CONSTNAME</code>
<br>
Everywhere to access a public constant of a class.
</p>

</blockquote>

<p>
<b>Collisions.</b>
A class can extend another class and can re-define some of the inherited
constants.
A class can also implement several interfaces, but constants inherited from all
these classes cannot collide and need to be all distinct.
Example:
</p>

<blockquote><pre>
# All these interfaces and classes define the same constant:
interface IF1 { const x = 0; }
interface IF2 { const x = 1; }
abstract class ABS { const x = 2; }
class A { const x = 3; }

# Now testing collisions:

class B extends A {
    const x = "hello";  # re-defining A::x is allowed
                        # Note the different type
}

class C extends ABS implements IF1, IF2 {
    # ERROR: collision among inherited
    # consts ABS::x, IF1::x, IF2::x

    const x = 5;  # ERROR: collides with all the consts above
}
</pre></blockquote>

<p>
The <code>/*.private.*/</code> meta-code attribute does not help to limit the
scope of visibility of a constant because it is not supported by PHP, so
also private constants can collide in derived classes.
</p>

<p>
<b>Re-defining.</b>
Class constants declared in interfaces and abstract classes cannot
be re-defined. Only constants inherited from concrete classes can be
re-defined.	 In this latter case the operators <code>self::CONSTNAME</code>
and <code>parent::CONSTNAME</code> allow to access the desired value in
the current or in the parent class, respectively.
</p>

<p>
<b>Overriding.</b>
Class constants cannot be overridden. From the point of view of PHPLint,
this implies that constants with the same name defined in related concrete
classes can have different types (see example above).
</p>



<a name=classes-properties></a>
<h3>Properties</h3>

<p>
Classes and abstract classes can define several properties, basically
variables bound to the class (if <b>static</b>) or bound to every object
instantiated from this class (if non-static).  A property can be declared
using a syntax similar to this one:
</p>

<blockquote>
<pre>
<i>visibility</i> [<b>static</b>] [ /*. <i>x_type</i> .*/ ]
    $name1 = STATICEXPR1,
    $name2 = STATICEXPR2,
    $name3 = STATICEXPR3;
</pre>
</blockquote>

where:

<blockquote>

    <p>
    The visibility attributes are: <b>public</b>, <b>protected</b>
    or <b>private</b>.
	</p>

    <p>
    The <b>static</b> attribute marks the property to be a proper <i>class
    property</i> rather than <i>object property</i>, i.e. there is only one
    instance of this property for all the objects of this class.
    </p>

	<p>
	The visibility and the <b>static</b> attributes can be indicated in
	any order. Properties that are both <b>public</b> and <b>static</b>
	can be indicated simply being <b>static</b> omitting the other attribute.
    </p>

    <p>
    The type is optional. It is simpler and shorter to indicate a proper
    initial value, since PHPLint guesses the type of the property from the
    type of the expression. Providing both the type and the initial value
    is allowed for clearness if desired, but it is redundant. For example,
    writing
    </p>

<pre>
public $counter = 0;
public $status = array("off", "on");
public $file = /*.(resource).*/ NULL;
</pre>

    is equivalent to

<pre>
public /*. int .*/ $counter = 0;
public /*. array[int]string .*/ $status = array("off", "on");
public /*. resource .*/ $file = NULL;
</pre>

    <p>
	The initial value <code>STATICEXPRn</code> is optional and, if provided,
	its type must match the x_type. Remember that properties without an
	initial value are initialized to the value NULL; in this case the
	responsibility to assign them a proper initial value is left to the
	constructor method.
    </p>

</blockquote>

<p>
<b>private</b> properties can be re-defined inside the derived classes,
but this is not a proper "overriding", since the methods of the child
and of the extended class each one access its own properties.
</p>

<p>
<b>public</b> and <b>protected</b> properties cannot be redefined in extended
classes (PHPLint restriction).
</p>

<pre>

</pre>
<DIV><FIELDSET><LEGEND><b>IMPORTANT</b></LEGEND>
<p>
The PHP interpreter initializes all the properties that lack an initial value
to the NULL value. According to the type model of PHPLint, the NULL value is
not allowed for variables of simple type <b>boolean</b>, <b>int</b> or
<b>float</b>. In these cases PHPLint requires that an initial value be always
specified, for example <code>FALSE</code>, <code>0</code> or <code>0.0</code>
respectively otherwise an error is signaled.
</p>
</FIELDSET></DIV>
<pre>

</pre>

<p>
<b>Accessing.</b>
Properties can be accessed in several ways, depending on the context
and on their attributes:
</p>

<blockquote>

<p>
<code>$this-&gt;v</code>
<br>
Inside a non-static method to access a local non-static property, or an
inherited <b>public</b>|<b>protected</b>, non-static property.
</p>

<p>
<code>$obj-&gt;v</code>
<br>
Everywhere to access a non-static, <b>public</b> property.  Note that
<b>protected</b> properties are not accessible this way, but only through
$this-&gt;v or self::$v.  Accessing via $obj-&gt; to <b>protected</b>
properties is forbidden (PHPLint restriction).
</p>

<p>
<code>self::$v</code>
<br>
Inside a method to access a local <b>static</b> property, or an inherited
<b>public</b>|<b>protected</b>, <b>static</b> property.
</p>

<p>
<code>parent::$v</code>
<br>
Inside a method to access an inherited <b>public</b>|<b>protected static</b>
property. Since in PHPLint the non-private properties cannot be re-defined,
nor public|protected properties can be overridden, this gives the same
as <code>self::$v</code>.
</p>

<p>
<code>CLASSNAME::$v</code>
<br>
Everywhere to access a <b>static</b>, <b>public</b> property.
</p>

</blockquote>


<p>
<b>Re-defining.</b>
Only <b>private</b> properties can be re-defined in extended classes.
</p>

<p>
<b>Overriding.</b>
Properties cannot be overridden (PHPLint restriction).
</p>

<table align=center width="70%"><tr><td>
NOTE. PHP allows to override properties, but the overridden property gets
shadowed by the new one and cannot be accessed anymore, neither from its
own class.
</td></tr></table>



<a name=classes-methods></a>
<h3>Methods</h3>

<p>
A method can be declared using a syntax similar to this one:
</p>

<blockquote>
<pre>
<i>[visibility]</i> <i>[</i>static<i>]</i> <i>[</i>final<i>]</i> /*. <i>x_type</i> .*/
function methodName(<i>arguments</i>)
{
    // the code here
}
</pre>
</blockquote>

<p>
As of PHP 5.3.3, in namespaced classes the constructor method must be called
<tt>__construct()</tt>. In PHPLint the constructor method must be always
called <tt>__construct()</tt> and a warning is raised on methods that have the
same name of the class.
</p>


<a name=classes-methods-attributes></a>
<h4>Methods attributes</h4>

<p>
A method is basically a function that can have several attributes,
in any order.
</p>

<p>
The allowed visibility attributes for methods are:
<b>public</b> (the default), <b>protected</b> or <b>private</b>.
</p>

<p>
The <b>static</b> attribute marks the method to be a proper <i>class
method</i> rather than an <i>instance method</i>, so this methods
is not bound to a particular object. <b>static</b> methods cannot use
the special variable <code>$this</code> (PHPLint restriction).
</p>

<p>
The <b>final</b> attribute marks methods that cannot be overridden.
</p>

<p>
The type of the returned value isn't mandatory since PHPLint can guess
the type from the <code>return</code> statement, but it is recommended
be always indicated explicitly.
Methods that do not return a value should be <b>void</b>.
</p>


<a name=classes-inheritance-and-methods-overriding></a>
<h4>Inheritance and methods overriding</h4>

<p>
A class B is said to be a <i>subclass</i> of the class A if the class
B extends the class A or if the class B extends a class X that is a
subclass of A (note the recursive definition). For example:
</p>

<blockquote>
<pre>
class A {
    function a() {}
}

class B extends A {
    function a() {}
}
</pre>
</blockquote>

<p>
Normally, the names of the methods of a subclass differ from any other
method of its parent class.  However, the subclass B can override
the method A::a() of its parent class defining the overriding
method B::a().
</p>

<p>
The basic rule of the polymorphism in OOP is that <i>overridden methods
must be usable exactly as the original ones</i>. For example, if A::a()
is expected to return a string, the overriding method B::a() must return
a string; if A::a() requires two mandatory arguments, also B::a() must be
callable with two arguments.
PHPLint checks accurately every overridden method: the signature, the
attributes and the thorwn exceptions are compared and possible
incompatibilities are detected.
PHP 5 already does some checks on the attributes and on the number of
mandatory and default arguments, but PHPLint enhance these restrictions to
the types of the arguments,
and the possible presence of optional arguments <code>/*.args.*/</code>,
the type of the returned value,
and the exceptions thrown.
Lets start defining what a signature is.
</p>

<p>
The <i>signature</i> of a method is composed of:
<ul>
<li>the type of the returned value, possibly <b>void</b></li>
<li>the ordered list of the types of the mandatory arguments</li>
<li>the ordered list of the types of the default arguments</li>
<li>possible presence of a variable number of arguments  <b>/*.args.*/</b></li>
</ul>
For example, the signature of the method
</p>

<blockquote>
<code>/*.int.*/ function a(/*.int.*/ $a, $b=3.14 /*., args.*/)
</code></blockquote>

<p>
is <code>int(int,[float],...)</code> with one mandatory argument ($a), one
default argument ($b) and possibly a list of more optional arguments.
</p>

<p>
The attributes, the signature and the list of the exceptions thrown
of the overriding method B::a() are subject to these restrictions:
</p>

<ul>

<li>The two methods must have the same name (ok, that's obvious...).
</li>

<li><b>final</b> methods cannot be overridden (PHP 5 restriction).
</li>

<li><b>private</b> methods cannot be re-defined (PHP 5 limitation,
    but see the note 1).
</li>

<li>The visibility of the new method must be the same or greater:
    if A::a() is protected, B::a() can be either protected or public;
    if A::a() is public, B::a() must be public (PHP 5 restriction).
</li>

<li>The two methods must be both non-static or both <b>static</b>
    (PHP 5 restriction).
</li>

<li>
The signature of the overriding method must be compatible with the
signature of the overridden method, that is:

	<ul>

	<li>
	The return type must be the same of the overridden method.
	If the return type is an object, it may also be a sub-class.
	</li>

	<li>
	For each matching formal argument, the passing method (by value, return
	by reference or by reference) must be the same.
	</li>

	<li>
	The type of each argument must be the same of the overridden method.
	If the argument is an object passed by value, it may also be a sub-class.
	</li>

	<li>
	If the parent method has only mandatory arguments (or no arguments
	at all), the overridding method can add default arguments and
	optional arguments.
	</li>

	<li>
	If the parent method has default arguments, the overridding method can
	add more default arguments and optional arguments.
	</li>

	</ul>
</li>

<li>
	The new method can throw the same exceptions inherited from the
	original method, or even subclasses of them; throwing other exceptions
	is not allowed. The chapter devoted to the exceptions provides more
	details about this topic.
</li>

<li>
	The set of declared thrown exceptions must be a class subset of the
	the set of the declared exceptions in the original method.
	In particular, note that is the original method does not declares
	any thrown exception, the new method cannot throw checked exceptions
	at all.
	See the chapter devoted to the exceptions for more details.
</li>


</ul>

<p>
In this example, the subclass B overrides all the methods of its parent class
A. The body of all the methods is left empty, since it does not matter in
our discussion. Note that B::g() adds a default argument $y, while B::h()
adds a variable number of optional arguments and raises its visibility from
<b>protected</b> to <b>public</b>.
</p>

<blockquote>
<pre>
class A {
    public /*. void .*/ function f(){}

    public /*. int  .*/ function g(/*. int .*/ $i){}

    protected /*. void .*/ function h(/*. int .*/ $x){}
}

class B extends A {
    public /*. void .*/ function f(){}

    public /*. int  .*/ function g(
        /*. int .*/ $x,
        /*. int .*/ $y = 0)
    {}

    public /*. void .*/ function h(/*. int .*/ $x /*., args .*/){}
}
</pre>
</blockquote>


<pre>

</pre>
<hr width="20%" align=left>
<blockquote>
<p>
<b>NOTE 1.</b> PHP 5 does not allow to re-define a private method, and it
checks the new method as it were an overriding one. This implies that a
different number of arguments generates a warning when the E_STRICT mode
is enabled.  It seems to me a little bug, since I'm used to split complex
methods into several little private functions with short, trivial names;
these utility functions should not be visible outside the class.
</p>

<p>
Workaround: avoid trivial names for private methods. For example, if the
method <code>Items::printList()</code> needs an utility function that
sort the list before be printed, you can call this private function
something like <code>Items::printList_sort()</code>, and not simply
<code>Items::sort()</code>: not only this prevent collisions with possible
other private methods of extended classes, but it also make clear to
the human reader of the source that this is an utility method bound to
<code>printList()</code>.
</blockquote>
<pre>

</pre>



<a name=classes-accessing-to-the-methods></a>
<h4>Accessing to the methods</h4>

<p>
Methods can be accessed in several ways, depending on the context
and on their attributes:
</p>

<blockquote>

<p>
<code>$this-&gt;f()</code>
<br>
Inside a non-static method to access a local non-static method, or an
inherited <b>public</b>|<b>protected</b>, non-static method.
</p>

<p>
<code>self::f()</code>
<br>
Inside a method to access a local <b>static</b> method, or an inherited
<b>public</b>|<b>protected</b>, <b>static</b> method.
</p>

<p>
<code>parent::f()</code>
<br>
Inside a method to access an inherited <b>public</b>|<b>protected</b>
<b>static</b>|non-static method. Useful if the inherited method has
been overridden, so <code>parent::f()</code> is the original method,
while <code>$this->f()</code> (if non-static) or <code>self::f()</code>
(if static) is the overriding one. Note the usage of the <i>static
resolution operator</i> "<code>::</code>" also for non-static methods:
in fact in this case the dynamic binding does not take place since the
method we are referring to is statically determined.  The typical
usage is calling the parent constructor from the derived class using
<code>parent::__construct();</code> (remember that if the derived class
has a constructor, the parent constructor isn't called automatically, but
it must be called explicitly from the constructor of the derived class).
</p>

<p>
<code>CLASSNAME::f()</code>
<br>
Everywhere to access a static, public method.
</p>

<p>
<code>$obj-&gt;f()</code>
<br>
Everywhere to access a non-static, <b>public</b> method.
<b>protected</b> methods are not accessible this way (PHPLint restriction).
</p>

</blockquote>


<p>
PHPLint will raise an error message if a <b>static</b> method does use the
special variable <code>$this</code> (PHPLint restriction).
</p>


<a name=classes-special-methods></a>
<h3>Special methods</h3>

<p>
<b>Constructors.</b>
A constructor method <code>__construct()</code> can have a visibility
attribute, then the usual visibility rules apply. For example, note that if
the constructor is <b>private</b> or <b>protected</b>, objects of its class
can be instantiated only inside the class itself (if <b>private</b>) and
the constructor can be called by the extended classes (if <b>protected</b>).
</p>

<p>
A class constructor cannot be <b>abstract</b> nor <b>static</b>.
</p>

<p>
The signature of a class constructor must return <code>void</code> and it
may contain arbitrary formal arguments, since its signature is not compared
with that of the parent class (constructors do not "override" constructors).
</p>

<p>
A class constructor is called implicitly by the <b>new</b> operator; it
cannot be called explicitly with the only exception of the constructor of
the derived classes (PHPLint restriction).
</p>

<p>
A constructor must call explicitly its parent constructor if one exists,
since in this case PHP would not call automatically the constructor of the
parent class.  It is an error if the constructor of the derived class omits
to call the parent constructor through <code>parent::__construct();</code>
(PHPLint restriction).
</p>

<p>
<b>Destructors.</b>
A class destructor <code>__destruct()</code> can have a visibility attribute.
Destructors are invoked automatically by the PHP interpreter once the object
has no more references. Destructors cannot be called explicitly by the program
(with the only exception of the destructor of the derived class; see below).
</p>

<p>
Note that <b>private</b> and <b>protected</b> destructors cannot be invoked
outside their class or their derived classes, so that if the destruction
of an object occurs outside the visibility context of this method, the
PHP interpreter raises a warning message. Since PHPLint cannot practically
determine in which context the object of this class will be destroyed,
it cannot check the proper usage of the <b>private</b> and <b>protected</b>
attributes applied to destructors, so it imposes these methods be always
<b>public</b> (PHPLint limitation).
</p>

<p>
A class destructor cannot be <b>abstract</b> nor <b>static</b>.
</p>

<p>
A class destructor must return <code>void</code> and it cannot have formal
arguments.
</p>

<p>
Thus the only allowed signature of a destructor is as follows:
</p>

<blockquote><pre>
function __destruct(){ ... }
</pre></blockquote>

<p>
A destructor must call explicitly its parent destructor if one exists,
since in this case PHP would not call automatically the destructor of the
parent class.  It is an error if the destructor of the derived class omits
to call the parent destructor through <code>parent::__destruct();</code>
(PHPLint restriction).
</p>


<p>
<b>Other special methods.</b>
This table summarizes the other special methods and their expected visibility
and signature:
</p>

<table border=1 align=center cellpadding=5 cellspacing=0>

<tr>
<th>Visibility and Signature</th>
<th>Notes</th>
</tr>

<tr>
<td><code>public [final] mixed __call(string, array[]mixed)</code></td>
<td>This special method is parsed but actually not supported.
You can't call undefined methods.
</td>
</tr>

<tr>
<td><code>public [final] static mixed __callStatic(string, array[]mixed)</code></td>
<td>
Not supported by PHPLint: static methods must be always explicitly declared.
</td>
</tr>

<tr>
<td><code>public [final] void __clone()</code></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><code>public [final] mixed __get(string)</code></td>
<td>Not supported by PHPLint.</td>
</tr>

<tr>
<td><code>public [final] void __invoke(args)</code></td>
<td>Not supported by PHPLint: objects cannot be called as functions.</td>
</tr>

<tr>
<td><code>public [final] boolean __isset(string)</code></td>
<td>Not supported by PHPLint.</td>
</tr>

<tr>
<td><code>public [final] void __set(string, mixed)</code></td>
<td>Not supported by PHPLint.</td>
</tr>

<tr>
<td><code>public [final] object __set_state(array[string]mixed)</code></td>
<td>Dangerous with PHPLint as it has no control on the actual values assigned
to the properties.</td>
</tr>

<tr>
<td><code>public [final] static __set_static(array[string]mixed)</code></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><code>public [final] array[int]string __sleep()</code></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><code>public [final] string __toString()</code></td>
<td>&nbsp;</td>
</tr>

<tr>
<td><code>public [final] void __unset(string)</code></td>
<td>Not supported by PHPLint.</td>
</tr>

<tr>
<td><code>public [final] void __wakeup()</code></td>
<td>&nbsp;</td>
</tr>

</table>


<a name=classes-abstract-classes></a>
<h3>Abstract classes</h3>

<p>
The general syntax of an abstract class can be informally described as
follows:
</p>

<blockquote><pre>
/*. private .*/ abstract class CLASSNAME
    extends ANOTHER_ABSTRACT_CLASS
    implements INTERFACE1, INTERFACE2
{
	<i>constants
	properties
	abstract methods
	concrete methods</i>
}
</pre></blockquote>

<p>
An abstract class is similar to any other concrete class, but with three
important differences: 1. it can contain abstract methods; 2. it cannot be
instantiated with the <b>new</b> operator; 3. derived, concrete classes must
implement all the abstract methods defined inside the abstract class; if the
abstract class extends another abstract class, or implements some interfaces,
the concrete class must also implement the inherited abstract methods.

<blockquote>
NOTE. In practice, the same result can be obtained with a concrete
class simply leaving empty the body of the abstract method: this would
satisfy the requisite no. 1, while a source validator like PHPLint might
ensure the observance of the points 2 and 3. In PHP 4, where abstract
classes and abstract methods are not available, the PHPLint meta code
<code>/*.abstract.*/</code> allows to to obtain the same result.
</blockquote>

<p>
The basic properties of abstract classes are:
</p>

<ul>

<li>
Abstract classes are intended to be a model for other "concrete" classes,
so that all the extended classes derived from them share a common behavior. As
a logical consequence, abstract classes cannot be <b>final</b>.
</li>


<li>
An abstract class can extend another abstract class and can implement
several interfaces.  The extended abstract class inherits the properties, the
methods and the abstract methods of its parent class and parent interfaces.
</li>

<li>
A concrete (i.e. non-abstract) class MUST implement all the abstract
methods inherited from the abstract class it extends.
</li>

<li>
Your program can process abstract objects that belong to an abstract
class, whatever the concrete class to which they actually belong may
be.
</li>

<li>
Objects cannot be instantiated from an abstract class.
</li>

</ul>

<p>
Abstract classes can be private to the package: in this case also any
derived class must be private.	Abstract classes cannot be <b>final</b>,
since they are useful only if they can be extended.
</p>

<p>
Abstract classes can extend another abstract class, and can implement
several interfaces. The abstract class itself may implement some of the
inherited abstract methods.
</p>

<p>
Constants inherited from the implemented interfaces and from the extended
class, and properties inherited from the extended class cannot collide
together nor they can collide with the items defined inside the abstract
class.
</p>

<p>
Instead, a method can override or implement several methods inherited from the
extended classes and from implemented interfaces, provided that this method be
compatible with all them.
</p>

<p>
An abstract method is a public, non-static, non-final method that has the
<b>abstract</b> qualifier, and its body is substituted by a semicolon:
</p>

<blockquote><pre>
abstract class Shape
{
    const DEF_SCALE = 1.0;

    public $x = 0.0, $y = 0.0;

    function moveTo(/*. float .*/ $x, /*. float .*/ $y)
    {
        $this-&gt;x = $x;
        $this-&gt;y = $y;
    }

    abstract /*. void .*/ function scale(/*. float .*/ $factor) ;
}
</pre></blockquote>

<p>
This class describes a generic geometric shape that can be moved and
scaled.	 The position is a property that can be defined for any shape,
so the <code>moveTo()</code> method can be <i>concrete</i>. On the contrary,
scaling a generic shape cannot be implemented in a general way and the
method implementing this feature only declares its interface but not its code,
i.e. it is <i>abstract</i>.
</p>

Since the method <code>scale()</code> is abstract, it must be
implemented in any derived, concrete, class:
</p>

<blockquote><pre>
class Circle extends Shape
{
    public $radius = 1.0;

    function scale(/*. float .*/ $factor)
    {
        $this-&gt;radius *= $factor;
    }
}

class Rectangle extends Shape
{
    public $side_a = 1.0, $side_b = 2.0;

    function scale(/*. float .*/ $factor)
    {
        $this-&gt;side_a *= $factor;
        $this-&gt;side_b *= $factor;
    }
}
</pre></blockquote>


<p>
Abstract classes are useful to describe data structures and deal with them
without knowing their actual nature. For example, this chunk of code declares
a drawing as a list of shapes and declares a function that scale them all:
</p>


<blockquote><pre>
$drawing = /*. (array[int]Shape) .*/ array();

function scale_shapes(/*. float .*/ $factor)
{
    foreach($GLOBALS['drawing'] as $shape)
        $shape->scale($factor);
}


$drawing[] = new Circle();
$drawing[] = new Circle();
$drawing[] = new Rectangle();
scale_shapes(10.0);
</pre></blockquote>


<a name=classes-interfaces></a>
<h3>Interfaces</h3>

<p>
The syntax of an interface can be described informally as follows:
</p>

<blockquote><pre>
/*. private .*/ interface NAME
    extends INTERFACE1, INTERFACE2
{
	<i>public constants
	abstract methods</i>
}
</pre></blockquote>

<p>
An interface is similar to an abstract class declaring only constants and
abstract methods.  Basically, interfaces are used as "syntactical glue"
between different classes, and are not really necessary for a scripting
language as PHP is.  Nevertheless, interfaces are an important feature in
complex applications:
</p>

<ul>

<li>
Concrete and abstract classes can extend only one class, but can implement
several interfaces.
</li>

<li>
PHP (and PHPLint too) ensures that all the indicated abstract methods be
actually implemented, so that all the classes implementing a given interface
will exhibit the same behaviour.
</li>

<li>
Interfaces help in documenting the source, as the various relationships
among related classes become evident.
</li>

<li>
PHPLint and PHP 5 can understand the actual intention of the programmer,
so they can help to debug the program both at validation-time and at
run-time respectively.
</li>

</ul>

<p>
Constants and abstract methods inherited from the extended interfaces
cannot collide together and cannot collide with items defined inside
the interface.
</p>

<p>
Properties are not allowed in interfaces (PHP 5 restriction).
You can still force implementing classes to define some accessor methods (also
known as "setters" and "getters") to write and read the property. The following
example illustrates two accessor methods allowing to read and write the
property "xxx":
</p>

<blockquote><pre>
interface IAccessorsDemo
{
    /*. void .*/ function setXxx(/*. int .*/ $value);
    /*. int  .*/ function getXxx();
}
</pre></blockquote>

<p>
Constructor methods are allowed in interfaces only since PHP 5.2.0.
</p>

<p>
All the methods must be abstract, public and non-final, but the
<b>abstract</b> attribute is not required, since all the methods of an
interface must be abstract.
</p>

<p>
Methods can be <b>static</b>.
</p>

<p>
An interface can extend several other interfaces, so inheriting all their
abstract methods.
</p>

<p>
Interfaces cannot be instantiated into an object, so the <b>new</b> operator
cannot be applied to an interface. Interfaces can be extended by other
interfaces, and can be implemented by abstract and concrete classes.
</p>

<p>
In the following example, an interface describes the methods that a generic
"data container" must provide.  Every datum has a name and a value; the
methods set() and get() allow to store/retrieve that value.  The abstraction
introduced by this class is that the medium where these data have to be stored
is left to the implementation of the interface. Several implementations
can follow different strategies, for example data can be stored in memory,
in the user session, inside a DB, etc.  The point is that the software
written in terms of this interface becomes largely independent from the
implementation we can choose.
</p>

<p>
Two (very crude) concrete classes implementing this interface are also defined,
then an example that stores a copy of the $_SESSION[] data is shown.
</p>

<pre>

interface DataContainer
{
    /*. void .*/ function set(
        /*. string .*/ $name,
        /*. string .*/ $value);

    /*. string .*/ function get(/*. string .*/ $name);
}


class MemoryBasedContainer implements DataContainer
{
    private $data = /*.(array[string]string).*/ array();

    /*. void .*/ function set(
        /*. string .*/ $name,
        /*. string .*/ $value)
    {
        $this->data[$name] = $value;
    }

    /*. string .*/ function get(/*. string .*/ $name)
    {
        if( isset($this->data[$name]) )
            return $this->data[$name];
        else
            return NULL;
    }
}


class FileBasedContainer implements DataContainer
{
    private $base_dir = "";

    /*. void .*/ function __construct(/*. string .*/ $base_dir)
    {
        $this->base_dir = $base_dir;
    }

    /*. void .*/ function set(
        /*. string .*/ $name,
        /*. string .*/ $value)
    {
        file_put_contents($this->base_dir ."/". $name, $value);
    }

    /*. string .*/ function get(/*. string .*/ $name)
    {
        $fn = $this->base_dir ."/". $name;
        if( ! file_exists($fn) )  return NULL;
        return file_get_contents($fn);
    }
}


class DbBasedContainer implements DataContainer
{
    /* etc etc etc */
}


function save_session_data(/*. DataContainer .*/ $c)
{
    foreach($_SESSION as $k => $v)
        $c->set($k, serialize($v));
}


$c = /*. (DataContainer) .*/ NULL;

switch( SAVE_METHOD ){
    case SAVE_ON_MEMORY: $c = new MemoryBasedContainer(); break;
    case SAVE_ON_FILE:   $c = new FileBasedContainer("/tmp"); break;
    case SAVE_ON_DBASE:  $c = new DbBasedContainer(); break;
}

save_session_data($c);
/* ... */

</pre>


<p>
Note that the function <code>save_session_data()</code> formally accepts an
object from a class that cannot be instantiated. This is obviously a
syntactical trick that simply says: well, my dear function, whatever the actual
object may be, that object will behave as specified by the
<code>DataContainer</code> interface, so that the methods specified there will
be available.
</p>

<p>
Note that the same code would work perfectly on PHP also omitting the interface
declaration at all, as the type of the variable $c is dynamically determined
and the method calls are always dynamically resolved at run-time. Yet, the
interface makes evident to the human reader (an to PHPLint) which are the
features shared by every instance of the object $c.
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#recursivedeclarations-recursive-declarations'>Recursive declarations</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#recursivedeclarations-function-prototypes'>Function prototypes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#recursivedeclarations-method-prototypes'>Method prototypes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#recursivedeclarations-class-prototypes'>Class prototypes</a><p>
<a name=recursivedeclarations-recursive-declarations></a>
<h2>Recursive declarations</h2>

<p>
PHPLint is a single-pass parser. With this design, the program becomes simple
and fast. The drawback is that every item has to be declared before be used,
and the programmer is forced to declare functions, classes and methods in a
strict bottom-up order: low-level come first, high-level ones next. However
there are cases in which functions (or even methods and classes) must call each
other recursively because this may be the "natural" way to resolve some complex
algorithms. PHPLint resolves these cases through the <b>forward
declaration</b>.
</p>

<p>
Forward declarations are meta-code statements that may declare the
<b>prototype</b> of a function, a class or a method, so that these elements can
be used before being fully declared in actual PHP code.
</p>

<p>
All the prototypes declared in a file MUST have their corresponding full
code declaration in the same file. When PHPLint ends parsing a file, in
fact, it checks that all the prototypes declared in that file be resolved
in actual PHP code.
</p>


<a name=recursivedeclarations-function-prototypes></a>
<h3>Function prototypes</h3>

<p>
Function prototypes MUST be declared at global scope. Function prototypes
cannot be declared inside a function or inside a method. This also means that
function prototypes cannot be used inside files included by a function.
</p>

<p>
Function prototypes MUST fully declare the signature of the function, including
returned type and argument types, as in this example:
</p>

<blockquote>
<code>/*. forward void function Location(string $url = ); .*/</code>
</blockquote>

<p>
Note the reserved keyword <b>forward</b> that marks the prototype. Note also
that the expression giving the default value of the argument must be left
empty, so that this value can be indicated only once for all where the
actual code is implemented.
</p>

<p>
The actual code implementing this prototype MUST match exactly the signature
of the prototype. Here we can rely on the guesses PHPLint performs, but the
resulting signature must be that expected. For example, the function above
can be implemented in code omitting the returned type, as this type can
be guessed by PHPLint:
</p>

<blockquote>
<pre>
function Location(/*. string .*/ $url = NULL)
{
    if( $url === NULL )
        header("Location: http://www.mysite.com/");
    else
        header("Location: $url");
}
</pre>
</blockquote>

<p>
Note that the $url argument has a default value, and this default value has
been explicitly given only in the actual PHP code and was omitted in the
prototype.
</p>

<p>
Function prototypes can include also the <b>private</b> attribute and
the <b>args</b> formal argument. The following example illustrates
a private function that has a mandatory argument, a default argument
and zero or more optional arguments:
</p>

<blockquote>
<pre>
/*. forward private void function
    print_list(string $label, string $sept=, args); .*/
</pre>
</blockquote>

<p>
The implementation in actual PHP code must match the same signature:
</p>

<blockquote>
<pre>
/*. private void .*/ function print_list(
    /*. string .*/ $label,
    /*. string .*/ $sept = ", "
    /*., args .*/)
{
    #...
}
</pre>
</blockquote>

<p>
A prototype of function can also declare a set of thrown checked exceptions. In
the actual function the set of declared thrown exceptions must be a class
subset of the the set of the declared exceptions in the prototype. In
particular, note that if the prototype does not declares any thrown exception,
the actual function cannot throw checked exceptions at all. See the chapter
devoted to the exceptions for more details.
</p>

<p>
None of the examples above actually required a prototype, as none of the
functions depends recursively from another function (or class).
If you know any concrete, short example that illustrates the actual need
for recursive functions, please let me know and I will add it here.
</p>


<a name=recursivedeclarations-method-prototypes></a>
<h3>Method prototypes</h3>

<p>
Recursive calls arise also within the methods of a class. In this case some of
the methods have to be declared <b>forward</b>. Methods prototypes are just
like function prototypes, with the only difference that methods may have also
their proper attributes, visibility, <b>static</b> and <b>final</b>.
</p>

<blockquote>
<pre>
class Data {

    /*.
        forward public void function __construct(string $value);
        forward public Data function getMoreData();
    .*/

    # From now on __construct() and getMoreData() can be used by
    # any method and can be declared in PHP code in any order.
}
</pre>
</blockquote>

<p>
A prototype of method can also declare a set of thrown checked exceptions. In
the actual method the set of declared thrown exceptions must be a class subset
of the the set of the declared exceptions in the prototype. In particular, note
that if the prototype does not declares any thrown exception, the actual
method cannot throw checked exceptions at all. See the chapter devoted to the
exceptions for more details.
</p>



<a name=recursivedeclarations-class-prototypes></a>
<h3>Class prototypes</h3>

<p>
A class prototype declares the class name and possibly the signature of some of
its methods. There is not need to list the signatures of all the methods that
will be actually declared in the actual PHP code, but only those that are
involved in recursive declarations or recursive calls. When only the class
name is involved in a recursive declaration, defining a forward class
is sufficient:
</p>

<blockquote>
<pre>
/*.  forward class A {}  .*/

class B {

    private $a = /*. (A) .*/ NULL;

    /*. A .*/ function getA(){ return $this->a; }
}

class A {

    private $b = /*. (B) .*/ NULL;

    /*. B .*/ function getB(){ return $this->b; }
}
</pre>
</blockquote>

<p>
In more complex cases of recursive depency among classes, the A class also
call some methods of B and vice-versa. In this case we declare the prototype of
the first class along the methods that are required by the B class:
</p>

<blockquote>
<pre>
/*.
forward class A {
    void function __construct(mixed $x);
    int  function someMethod();
}
.*/

class B {
    # Here we can use the A class
    # and the methods A::__construct()
    # and A::someMethod().
}

class A {
    # Finally, here is the A class,
    # that may fully use B and its
    # methods.
}
</pre>
</blockquote>

<p>
Programmers accustomed to split their program source one class per file,
may encounter a problem when defining classes that have recursive references.
Lets take for example two classes A and B, each one declared in its own
file A.php and B.php respectively. Now suppose both the classes need the other
one, for example each class has a method that return an object of the other
class. Here is structure of the source that resolves the recursive references:
</p>

File A.php:
<blockquote><pre>
&lt;?php

/*. forward class A{} .*/

require_once 'B.php';

class A {
    /*. B .*/ function m(){}
}
</pre></blockquote>


File B.php:
<blockquote><pre>
&lt;?php

/*. forward class B{} .*/

require_once 'A.php';

class B {
    /*. A .*/ function n(){}
}
</pre></blockquote>


We note that:

<ul>

<li>
In every file, the class is declared <b>forward</b>, then the other file is
included, and finally the <b>forward</b> class is declared in its actual PHP
code. The order of these elements is essential.
</li>

<li>
Every file has a <b>forward</b> declaration for the same class that is declared
just few lines below in the same file, that make easier to maintain the source
in case some change be made.
</li>

<li>
Each file of this example can be parsed separately by PHPLint, as the
<code>require_once</code> statements give to PHPLint (and to PHP as well) the
exact loading sequence of all the classes involved. Moreover, the client
packages can load any of the two files or even both in any order, since the
<code>require_once</code> statement ensures all the required files be loaded.
</li>

</ul>

<p>

</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-control-structures'>Control structures</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-declare-'>declare()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-namespace'>namespace</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-use'>use</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-const'>const</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-if-'>if()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-for-'>for()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-while-and-do-while-'>while() and do...while()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-foreach-'>foreach()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-switch-'>switch()</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-try-catch'>try...catch</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-return'>return</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#controlstructures-break'>break</a><p>
<a name=controlstructures-control-structures></a>
<h2>Control structures</h2>

<p>
PHPLint supports all the control structures of the PHP language,
with the only exception of the old form that the PHP manual title
<i>Alternative syntax for control structures</i>. In what will follow,
a <i>statement</i> is either a single instruction or the compaund instruction
"<code>{...}</code>" that may contain zero or more instructions.
The empty statement "<code>;</code>" (simply a semicolon) is also allowed
as statement.
</p>



<a name=controlstructures-declare-></a>
<h3>declare()</h3>

<p>
<code>declare(<i>identifier</i> = <i>static_expr</i>, <i>identifier</i> = <i>static_expr</i>, </code>...<code>) <i>statement</i></code><br>
Currently this declaration is parsed by PHPLint but it is otherwise ignored.
The only identifiers allowed are <code>ticks</code> and <code>encoding</code>.
</p>



<a name=controlstructures-namespace></a>
<h3>namespace</h3>

<p>
<code>namespace <i>identifier</i>\<i>identifier</i>\</code>...<code>;</code><br>
<code>namespace <i>identifier</i>\<i>identifier</i>\</code>...<code> { </code>...<code> }</code><br>
</p>



<a name=controlstructures-use></a>
<h3>use</h3>

<p>
<code>use <i>identifier</i>\<i>identifier</i>\</code>...<code>;</code><br>
<code>use <i>identifier</i>\<i>identifier</i>\</code>...<code> as <i>identifier</i>;</code><br>
</p>


<a name=controlstructures-const></a>
<h3>const</h3>

<p>
<code>const <i>identifier</i> = <i>static_expr</i>,
<i>identifier</i> = <i>static_expr</i>, </code>...<code>;</code><br>
Differently from <code>define()</code>, these constants are added to the
current namespace.
</p>



<a name=controlstructures-if-></a>
<h3>if()</h3>

<p>
<code>if(</code> <i>expr</i> <code>)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>statement</i><br>
<code>elseif(</code> <i>expr</i> <code>)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>statement</i><br>
<code>else</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>statement</i><br>
All the <i>expr</i> that appear here must result in a <b>boolean</b> value.
</p>



<a name=controlstructures-for-></a>
<h3>for()</h3>

<p>
<code>for(</code> <i>expr_list</i><code>;</code> <i>expr</i><code>;</code> <i>expr_list</i> <code>)</code> <i>statement</i><br>
The <i>expr_list</i> may be either empty or a list of expressions.
The <i>expr</i> may be either empty or a <b>boolean</b> expression.
</p>


<a name=controlstructures-while-and-do-while-></a>
<h3>while() and do...while()</h3>

<p>
<code>while(</code><i>expr</i><code>)</code> <i>statement</i><br>
<code>do</code> <i>statement</i> <code>while(</code><i>expr</i><code>);</code><br>
No much to say about these statements. As you might guess at this point, the
expression that controls the execution of the loop must be of the type
<b>bool</b>.
</p>



<a name=controlstructures-foreach-></a>
<h3>foreach()</h3>

<p>
<code>foreach(</code> <i>expr</i> <code>as</code> <i>[ $key</i> =&gt; <i>] [</i> <code>&amp;</code> <i>]</i> <i>$value</i><code>)</code> <i>statement</i><br>
Here, <i>expr</i> must be either an expression of the type <b>array</b>
of any structure, or an object of any class. <i>$key</i> and <i>$value</i>
must be two variables. The types of the key and of the value are determined
according to the type of the expression, namely:
</p>


<ul>

<li>
<p>
If <i>expr</i> is of the type <b>array</b>, the two variables must be
compatible by assignment with the type of the key and the type of the
elements of the array, respectively. If <i>expr</i> is an object, the
key must be assignment compatible with <b>string</b> and the value must
be <b>mixed</b>.
</p>
</li>

<li>
<p>
If <i>expr</i> implements the <b>Iterator</b> standard interface, then the type
of the key is the return type of the implemented <code>Iterator::key()</code>
method, and the type of the value is the return type of the implemented
<code>Iterator::current()</code> method.
<br>
Note that since these methods both return <b>mixed</b> in their original
definition, only <b>string</b>, <b>array</b> of any structure, <b>resource</b>
and <b>objects</b> of any class are allowed as overriding return types. Then
<b>boolean</b>, <b>int</b> and <b>float</b> still have to be returned boxed
inside a <b>mixed</b> object.
</p>
</li>

<li>
<p>
Finally, if <i>expr</i> implements the <b>IteratorAggregate</b> standard
interface, then the types of the key and of the value are determined according
to the implemented <b>Iterator</b> interface as returned by the implemented
<code>IteratorAggregate::getIterator()</code> method.
</p>
</li>

</ul>


<a name=controlstructures-switch-></a>
<h3>switch()</h3>

<p>
<code>switch(</code> <i>expr</i> <code>) {</code><br>
	<code>case</code> <i>static_expr1</i><code>:</code> <i>[ statements ]</i><br>
	<code>case</code> <i>static_expr2</i><code>:</code> <i>[ statements ]</i><br>
	...<br>
	<code>default:</code> <i>[ statements ]</i><br>
<code>}</code><br>
The value of the selector expression <i>expr</i> must be either <b>int</b> or
<b>string</b>. Each case selector <i>static_expr1</i>, <i>static_expr2</i>, ...
must be of the same type of the selector expression <i>expr</i>. But beware to
the strings: PHP execute the comparison using the weak equality operator
"<code>==</code>", so you might get unexpected results when a string looks like
a number. For example, the string <code>"1"</code> will match the string
<code>"01"</code>.
<p>
Each <code>case</code> can be empty (i.e. no statements), or it can contain one
or more statements. In this latter case, the last statement should be a
<code>return</code>, a <code>break</code> or the end of the switch() body; if
none of these three cases occcurs, then PHPLint raises a warning message. To
prevent this message from being displayed, you may add the special meta-code
statement <code>/*.&nbsp;missing_break;&nbsp;.*/</code>. Note that the
statement is terminated by a meta-code semicolon character.
<p>
The <code>default</code> branch can be empty (i.e. no statements), or it can
contain one or more statements. In this latter case, the last statement should
be a <code>return</code>, a <code>break</code> or the end of the switch() body;
if none of these three cases occcurs, then PHPLint raises a warning message. To
prevent this message from being displayed, you may add the special meta-code
statement <code>/*.&nbsp;missing_default:;&nbsp;.*/</code>. Note that the
statement is terminated by a meta-code semicolon character. Note that the
branch is terminated by a meta-code colon character.
<p>

Example:
</p>


<blockquote>
<pre>
switch( $i ){

    case 0:
        echo "do case 0";
        break;

    case 1:
    case 2:
        echo "do case 1 and 2";
        return;
    
    case 3:
        echo "do case 3";
        /*. missing_break; .*/

    case 4:
        echo "do case 4 and possibly 3";
        break;

    /*. missing_default: .*/
}
</pre>
</blockquote>


<a name=controlstructures-try-catch></a>
<h3>try...catch</h3>

<p>
<code>try { <i>protected block</i> }<br>
catch(ExceptionName1 $e) { <i>handling block</i> }<br>
catch(ExceptionName2 $e) { <i>handling block</i> }<br>
...</code><br>
Checked exceptions that may be thrown in the protected block of code
can be caught in the <code>catch()</code> branches. Checked exceptions that
are not thrown in the protected block of code cannot be caught.
<br>
The catch branches can also catch any unchecked exception.
<br>
All the exceptions must appear in the proper order: more specialized ones
first, ancestor ones next.
<br>
The variable $e that appear in each <code>catch()</code> branch is assigned
with the type of the caught exception. It is allowed to use the same variable
for all the branches. In fact the type of $e changes from a <code>catch()</code>
to the other. This is the only case in PHPLint in which a variable may change
its type. Exiting from the <code>try...catch</code> statement, all these
special variables are deleted.
</p>


<a name=controlstructures-return></a>
<h3>return</h3>

<p>
<code>return;</code><br>
<code>return</code> <i>expr</i> <code>;</code><br>
This statement can be used only inside functions and methods (PHPLint
restriction; PHP allows to "return" also from included files).  If a return
value is provided, it must be assignment-compatible with the type of the
function or method. PHPLint looks at this statement to guess the signature
of the function or method if not provided as meta-code.
</p>

<p>
Moreover, PHPLint uses the fist "return" statement found in the function or
method to guess the returned type. More on this topic in the chapter
<u>Functions</u>.
</p>


<a name=controlstructures-break></a>
<h3>break</h3>

<p>
<code>break;</code><br>
Prematurely exists from the current loop (for, foreach, while, do...while).
Also terminates a <code>switch...case</code> branch.
The <code>break <i>n</i>;</code> for is not supported by PHPLint and
gives error.
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-definite-assignment-analysis'>Definite assignment analysis</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-if-statement'>The if() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-while-statement'>The while() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-do-while-statement'>The do...while() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-foreach-statement'>The foreach() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-for-statement'>The for() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-switch-statement'>The switch() statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-the-try-catch-statement'>The try...catch statement</a><p>
&emsp;&emsp;&emsp;&emsp;<a href='#definiteassignment-arguments-passed-by-reference'>Arguments passed by reference</a><p>
<a name=definiteassignment-definite-assignment-analysis></a>
<h2>Definite assignment analysis</h2>


<p>
In PHPLint the properties of an object are always garanteed to have a value,
that is properties are always initialized to some value appropriate for their
type. For example, an integer may be zero, while a string of characters may be
NULL. In any case, every variable can be safely used because it has a definite
value.
</p>

<p>
Also mandatory arguments of function passed by value, and default arguments
of function passed by value always are definitely assigned.
</p>

<p>
But what about global and local variables?
Consider for example this code, were the variable $a may be assigned or not
only if a given condition is TRUE:
</p>

<blockquote><pre>
error_reporting(E_ALL|E_STRICT);

$flag = isset($_POST['data']);

if( $flag )
    $a = 123;

echo $a;  # &lt;== $a not assigned
</pre></blockquote>

<p>
When the code above runs, and <tt>$flag</tt> evaluates to FALSE, PHP displays
the message below, which indicates the usage of an unassigned variable:
</p>

<blockquote><code>
Notice: Undefined variable: a in /home/salsi/test.php on line 5
</code></blockquote>

<p>
What PHP reports as minor bug, might reveals to be a catastrophic flaw in our
source. That is why PHPLint performs a <i>conservative definitely assignment
analysis</i> on local variables and on arguments of function passed by
reference, and reports any case in which a variable might be used unassigned.
</p>

<p>
From here on we will indicate as <i>SDAV</i> the set of variables that are
definitely assigned after a given statement, whichever may be the execution
path the program will actually follow at runtime.
</p>

<p>
This analysis is said <i>conservative</i> in the sense that false positives may
arise, at least in some particular cases, and in these cases the variable must
be initialized to some dummy value before the involved statement.
</p>



<a name=definiteassignment-the-if-statement></a>
<h2>The if() statement</h2>

<p>
We already seen that variables defined inside the "then" branch of an if()
statement are considered unassigned in the next statement. But what if there is
also an "else" branch? In this case only the variables that are assigned in
both the brances are considered definitely assigned, the others remaining
unassigned. The example illustrates this fact:
</p>

<blockquote><pre>
if( $flag ){
    $b = 1;
    $c = 2;
} else {
    $b = 4;
    $d = 5;
}

echo $b, $c, $d;  # &lt;== $c, $d not assigned
</pre></blockquote>

<p>
Note that only the variable $b is considered definitely assigned, while $c and
$d are not and cannot be used as right-hand values because it is not garanteed
them will have a value when this code will be executed.
</p>

<p>
The only exception to the rule above is when the boolean expression can be
statically evaluated to be FALSE or TRUE: in this case the branch that will be
executed is univocally determinated and the set of variables definitely
assigned is that resulting from the parsing of this branch alone. The typical
example is a block of conditional code that depends on some constants:
</p>

<blockquote><pre>
const DEBUG = TRUE,
      DOLOG = FALSE;

if( DEBUG or DOLOG )
    $logfile = fopen("log.txt", "w");

if( DEBUG )
    fwrite($logfile, "Still alive!\n");

fwrite($logfile, "Processing...");
</pre></blockquote>

<p>
where in this case $logfile results to be definitely assigned because the two
controlling boolean expressions are statically evaluable to TRUE.
<br>
Note also that if both the constants were set to FALSE, then the last statement
that write "Processing..." would not pass the validation as the variable
$logfile in this case would not be definitely assigned. Then a source may
or may not pass the validation of PHPLint depending on the value of some
constants.
</p>

<p>
Another important exception is when the if() statements includes
statements like <code>return</code>, <code>exit</code> (also known as
<code>die</code>) or <code>throw</code>: variables definetely assigned
up to these statements cannot contribute to the SDAV, but the set of
the possible execution paths reduces:
</p>

<blockquote><pre>
if( $flag )
    $data = (string) $_POST['data'];
else
    die("no data");

echo $data;
</pre></blockquote>

<p>
This code passes the validation because the <code>echo $data;</code> statement
will be executed only if the "then" branch has been executed, so $data is
definitely assigned.
<br>
Similar special cases are considered by PHPLint also for the other statements
we will examine below.
</p>


<a name=definiteassignment-the-while-statement></a>
<h2>The while() statement</h2>

<blockquote><pre>
while( <i>EXPR</i> )
    <i>BLOCK</i>
</pre></blockquote>

<p>
The SDAV is the SDAV resulting from the evaluation of the expression EXPR;
variables assigned in the BLOCK of statements are not considered definitely
assigned.
Exception: when EXPR is statically evaluable to TRUE, the SDAV at the end of
the BLOCK are also definitely assigned after the while() statement.
</p>




<a name=definiteassignment-the-do-while-statement></a>
<h2>The do...while() statement</h2>

<blockquote><pre>
do
    <i>BLOCK</i>
while( <i>EXPR</i> );
</pre></blockquote>

<p>
The SDAV is the SDAV after the BLOCK joined with the variables assigned in the
expression EXPR.
</p>



<a name=definiteassignment-the-foreach-statement></a>
<h2>The foreach() statement</h2>

<blockquote><pre>
foreach(ARRAY as $k =&gt; $v)
    <i>BLOCK</i>
</pre></blockquote>

<p>
The foreach() statement never adds variables to the SDAV.
</p>



<a name=definiteassignment-the-for-statement></a>
<h2>The for() statement</h2>

<blockquote><pre>
for(LIST1; EXPR; LIST2)
    <i>BLOCK</i>
</pre></blockquote>

<p>
To the SDAV contribute LIST1 and EXPR, but not LIST2 and BLOCK.
</p>



<a name=definiteassignment-the-switch-statement></a>
<h2>The switch() statement</h2>

<p>
If there is a default branch, the SDAV is the intersection of the sets
contributed by each branch, joined with the set of variables assigned in the
expression EXPR.
</p>

<p>
If there is not a default branch, then only the variables assigned in the
expression are considered definitely assigned.
</p>



<a name=definiteassignment-the-try-catch-statement></a>
<h2>The try...catch statement</h2>

<blockquote><pre>
try {
    <i>BLOCK_0</i>
}
catch(BException $e){
    <i>BLOCK_1</i>
}
catch(AException $e){
    <i>BLOCK_2</i>
}
</pre></blockquote>

<p>
The try...catch statement contributes to the SDAV with the intersection of all
the sub-sets of variables definitely assigned in every "try" and "catch"
branch.
</p>




<a name=definiteassignment-arguments-passed-by-reference></a>
<h2>Arguments passed by reference</h2>

<p>
<b>Arguments passed by reference</b> must be definitely assigned by the
caller, and then these arguments are considered definitely assigned
inside the callee:
</p>


<blockquote><pre>
function inc_by_one(/*. int .*/ &amp; $i)
{
    echo "before: $i\n";
    $i++;
    echo "after: $i\n";
}

$n = 0;
inc_by_one($n);

inc_by_one($n2);  # &lt;== ERROR: $n2 unassigned
</pre></blockquote>


<p>
<b>Arguments that return by value</b> may be unassigned at call time as their
assignment is in charge of the callee; these arguments are then considered
unassigned entering the function. PHPLint also takes care to assure that
arguments that return by reference be actually assigned before returning from
the function itself:
</p>


<blockquote><pre>
function get_hash_code(/*. return string .*/ &amp; $hash)
{
    if( DEBUG ){
        $hash = DEBUG_HASH;
        return;
    }

    if( ! isset($_REQUEST['hash']) )
        return;   # &lt;== ERROR: $hash not assigned
    
    $s = (string) $_REQUEST['hash'];
    if( strlen($s) &lt; 8 )
        die("hash code too short");
    
    $hash = $s;
}

get_has_code($valid_form);
</pre></blockquote>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#functions-functions'>Functions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-returned-type'>Returned type</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-mandatory-arguments'>Mandatory arguments</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-default-arguments'>Default arguments</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-optional-arguments'>Optional arguments</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-passing-method-for-arguments'>Passing method for arguments</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-the-contract-of-a-function'>The contract of a function</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#functions-examples'>Examples</a><p>
<a name=functions-functions></a>
<h2>Functions</h2>

<p>
A function is a chunk of code with a name and possibly some arguments.
Once defined, a function can be called from any scope and cannot be
re-defined. The functions cannot be nested (although PHP lets to do so,
it is dangerous). Differently from the constants and the variables, the
name of a function isn't case sensitive. However, PHPLint checks the right
spelling and raises a warning if you call a function with a name that
does not match exactly its declaration. So, for example,
<code>strlen()</code> cannot be written as <code>StrLen()</code> nor as
<code>STRLEN()</code>.
</p>

<pre>

</pre>
<DIV><FIELDSET><LEGEND><b>IMPORTANT</b></LEGEND>
<p>
The general rule in PHPLint is that all the identifiers and the keywords
are always case-sensitive and must be written exactly as defined in the
PHP manual.
</p>
</FIELDSET></DIV>
<pre>

</pre>

<p>
The <i>signature</i> of a function gives the type of the formal arguments
and the type of the returned value, or <b>void</b> if the function does
not return a value. The PHPLint meta-code lets you to provide the type of
the returned value, the types of any mandatory formal argument, the type
of the default formal arguments, and lets you to declare if the function
can accepts a variable number of optional arguments. The general structure
of the declaration can be described informally as follows:
</p>

<blockquote>
<pre>
/*. TYPE1 .*/ function funcName(
      /*. TYPE2 .*/ $mandatory1,   # mandatory args
      /*. TYPE3 .*/ $mandatory2,

      $default1 = EXPR1,           # default args
      $default2 = EXPR2

      /*. , args .*/ )             # optional args
{
    ...
}
</pre>
</blockquote>


<a name=functions-returned-type></a>
<h3>Returned type</h3>

<p>
The <b>type returned</b> by the function (TYPE1 in the schema above) can be
guessed by PHPLint parsing the first "<b>return</b> EXPR;" statement that
appears in the source: the resulting type of the expression gives the type
of the function; if the expression EXPR is missing, the function does not
return anything, then its type is <b>void</b>.
</p>

<blockquote>
<pre>
function title(/*. string .*/ $t)
{
    echo "&lt;h1&gt;$t&lt;/h1&gt;\n";
}
# Guessed signature is: void(string)


function mean(/*. float .*/ $a, /*. float .*/ $b)
{
    return 0.5*($a + $b);
}
# Guessed signature is: float(float,float)


function firstByte(/*. string .*/ $code)
{
    if( strlen($code) == 0 )
        return /*. (string) .*/ NULL;
    else
        return $code[0];
}
# Guessed signature is: string(string)
</pre>
</blockquote>

<p>
Although omitting some meta-code brings to a shorter source code, however
it is better to provide an explicit type for the returned value: it is safer
for a strict parsing, and it is more intelligible to the reader of the source.
</p>

<a name=functions-mandatory-arguments></a>
<h3>Mandatory arguments</h3>

<p>
Every <b>mandatory argument</b> can have its type provided by the PHPLint
meta-code. Omitting the explicit declaration of the type, PHPLint will
raises an error because the type of the argument is unknown.
</p>

<a name=functions-default-arguments></a>
<h3>Default arguments</h3>

<p>
The type of a <b>default argument</b> can be guessed by the type of the
expression giving its default value:
</p>

<blockquote><code>function f($x = 123){ ... }</code></blockquote>

<p>
Anyhow, you can also specify a type:
</p>

<blockquote><code>function f(/*. int .*/ $x = 123){ ... }</code></blockquote>

<p>
In this case the explicit type must be assignment-compatible with the default
value.  An explicit type is required when the type of the expression cannot
be guessed by PHPLint. This is the case of the <code>NULL</code> value and
of the empty array <code>array()</code> constructor: both require a formal
type-cast (see the chapter <u>Typecasting</u> for details). Example:
</p>

<blockquote><pre>function f(
    $conn = /*. (resource) .*/ NULL,
    $arr  = /*. (array[int]string) .*/ array()
){ ... }</pre></blockquote>


<a name=functions-optional-arguments></a>
<h3>Optional arguments</h3>

<p>
The special meta-code keyword <b>args</b> tells that the function takes
a variable number of <b>optional arguments</b> that follow the mandatory
arguments and the default arguments.  For example, the function that follows
takes one mandatory argument and a variable number of optional arguments:
</p>

<blockquote><pre>
<b>/*.void.*/</b> function PrintArgs(<b>/*.string.*/</b> $prompt <b>/*. , args.*/</b>)
{
    echo $prompt, "\n";
    $n = func_num_args();
    for($i = 1; $i &lt;= $n; $i++ )
        echo (string) func_get_arg($i), "\n";
}
</pre></blockquote>

<p>
Please note that a comma character is required before the <code>args</code>
meta-code, keyword.
</p>



<a name=functions-passing-method-for-arguments></a>
<h3>Passing method for arguments</h3>

<p>
When a function is called, every <i>actual argument</i> is evaluated by the
caller before being passed to the called function and assigned to the
<i>formal argument</i> inside the code of the function.
Consider, for example this chunk of code:
</p>

<blockquote>
<pre>
function f(
    <b>/*. int        .*/</b>   $a,   # BY VALUE
    <b>/*. return int .*/</b> &amp; $b,   # RETURN BY REFERENCE
    <b>/*. int        .*/</b> &amp; $c)   # BY REFERENCE
{
    $b = $a + $c;
    if( $c &gt; 0 )
        $c = 0;
}


$carry = -3;
f(1+2, $result, $carry);
echo $result;  # 0; $carry===0
</pre>
</blockquote>

<p>
There are 3 passing methods:
</p>

<ul>

<li>
<b>By value.</b>
The formal argument $a that appears in the declaration of the
function is a variable, local to the function, that receives an incoming value
from the evaluation of the actual argument, that is the expression
<code>1+2</code>, and this actual value is copied inside the local variable.
In a word, from the point of view of the function, arguments passed by value
are incoming values.
</li>

<li>
<b>Return by reference.</b>
The formal argument $b that appears in the declaration of the function is a
variable, local to the function, that receives a <i>reference</i> to another
variable (the actual argument $result), so that the actual and the formal
variables both refer to the same value. Then, assigning $b also $result will
be assigned. The attribute <b>return</b> is a special attribute introduced
by PHPLint telling that this argument will return a value because it will be
certainly assigned inside the function.
In other words, the <b>return</b> attribute tells that this argument represents
an outgoing value from the function to the caller.
<br>
PHPLint raises an error if the value of the variable $b is used inside the
function before being assigned. PHPLint also raises an error if $b is not
definitely assigned before exiting the function.
</li>

<li>
<b>By reference.</b>
The formal argument $c is a reference to an actual argument which is a variable
already assigned by the caller, $carry. Then, variables passed by reference can
be used inside the function both as incoming and as outgoing values.
<br>
PHPLint raises an error if the actual argument $carry is not definitely
assigned before the call to the function.
</li>

</ul>


<a name=functions-the-contract-of-a-function></a>
<h3>The contract of a function</h3>

<p>
Functions may generate errors either calling another function or method that
may generate an error (for example <code>fopen()</code>), or invoking
explicitly the <code>trigger_error()</code> function. PHPLint warns about
unhandled errors. Errors can be handled and silenced with the <code>@</code>
operator.
</p>

<p>
Moreover, functions may generate exceptions either calling another function or
method or explicitly throwing an exception. PHPLint warns about uncaught
checked exceptions (more about exceptions in the <u>Exceptions</u> chapter).
Exceptions can be caught and handled with <code>try...catch</code>.
</p>

<p>
PHPLint accounts for any non-silenced error the function may raise and any
non-caught checked exception the function may throw. This list of raised errors
and thrown checked exceptions, along with the signature, become the
<i>contract</i> of the interface between the function an the client code that
will call this function. The client code, in turn, inherits these errors and
these checked exceptions and an either handle these cases or pass them to the
contract with the respective client code. More on the checked exceptions in the
Exceptions chapter.
</p>


<a name=functions-examples></a>
<h3>Examples</h3>

<p>
These examples illustrates the relations among types, variables and
function arguments:
</p>

<blockquote><pre>
$n = 123;           # Guess: $n is of type int
$s = "123";         # Guess: $s is of type string
$n = $s;            # ERROR: type mismatch: the left type is int,
                    #    while the right type is string
$n = (int) $s;      # Typecast prevents warning from PHPLint

PrintArgs($n, $s);  # ERROR: type mismatch on arg. no. 1

PrintArgs((string) $n, $s);
                    # Typecast prevent warning from PHPLint

function f($a, $b)  # Default signature: unknown(mixed, mixed)
{
    if( $a &lt; 0 ) # Warning: comparing unknown type $a with 0
        return 1;   # Guess: f() returns int
    else
        return 0.0; # Warning: that looks to be a float!
}

/*. private float .*/ function fabs(/*.float.*/ $x)
{
    return ($x >= 0.0)? $x : -$x;
}
</pre></blockquote>



<p>
Functions that are private to the package and that cannot be used
by other packages can be qualified as "private":
</p>

<blockquote><code>
/*. private void .*/ function DoSomething(){ ... }
</code></blockquote>

<p>
The private functions are reported by the PHPLint Documentator inside
the list of the <b>Private items</b> of the package.
</p>

<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#errors-errors'>Errors</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#errors-fully-handling-of-errors'>Fully handling of errors</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#errors-triggering-errors-and-errors-inheritance'>Triggering errors and errors inheritance</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#errors-mapping-errors-into-exceptions'>Mapping errors into exceptions</a><p>
<a name=errors-errors></a>
<h2>Errors</h2>


<p>
This chapter explains how errors raised by PHP at runtime can be detected, and
how PHPLint's error tracking feature works to help programmers being aware of
any potential error source. This chapter also explains another important
feature of PHPLint named <i>errors mapping into exceptions</i> that allows to
handle errors just like any other exception.
</p>



<a name=errors-fully-handling-of-errors></a>
<h3>Fully handling of errors</h3>

<p>
Several functions of the PHP standard library may signal an error of level
E_WARNING if something goes wrong. These errors are not fatal, in the
sense that a message is logged and then the program continues,
badly crashing or causing others unpredictable disasters:
</p>

<blockquote><pre>
$fn = "file-that-does-not-exist.txt";
$f = fopen($fn, "r");
$data = fread($f, filesize($fn));
fclose($f);

<b>==&gt;
PHP Warning:  fopen(file-that-does-not-exist.txt): failed to open stream: No such file or directory in /home/salsi/src/phplint/stdlib/err-test.php on line 5
PHP Warning:  filesize(): stat failed for file-that-does-not-exist.txt in /home/salsi/src/phplint/stdlib/err-test.php on line 6
PHP Warning:  fread() expects parameter 1 to be resource, boolean given in /home/salsi/src/phplint/stdlib/err-test.php on line 6
PHP Warning:  fclose() expects parameter 1 to be resource, boolean given in /home/salsi/src/phplint/stdlib/err-test.php on line 7
</b>
</pre></blockquote>



<p>
So, it is
responsibility of the programmer to check for possible errors and to take
counter measures appropriate for the case. Usually a simple <tt>die()</tt>
does the job, as there is nothing else the program can do:
</p>

<blockquote><pre>
$fn = "file-that-does-not-exist.txt";
$f = fopen($fn, "r");
if( $f === FALSE )
    die("can't read data file");
$data = fread($f, filesize($fn));
fclose($f);

<b>==&gt;
PHP Warning:  fopen(file-that-does-not-exist.txt): failed to open stream: No such file or directory in /home/salsi/src/phplint/stdlib/err-test.php on line 5
can't read data file
</b>
</pre></blockquote>


<p>
Note that in the example above if the opening of the file fails, then an error
message is logged or displayed on the screen depending on the configuration.
The programmer may also take care to generate meaningful error
messages prepending the silencer operator <tt>@</tt> to the function that may
fail, as in the example below:
</p>

<blockquote><pre>
$fn = "file-that-does-not-exist.txt";
$f = <b>@</b>fopen($fn, "r");
if( $f === FALSE )
    die("can't read data file: " . $php_errormsg);
$data = fread($f, filesize($fn));
fclose($f);

<b>==&gt;
can't read data file: fopen(file-that-does-not-exist.txt): failed to open stream: No such file or directory
</b>
</pre></blockquote>

<p>
But, if the programmer omits to performs these checks on the functions that may
fail, the result may be unpredictable and potentially might compromise the
safety of the system. PHPLint helps signaling all the functions it knows may
fail, but PHPLint cannot guarantee these errors are correctly handled by the
program.
</p>


<a name=errors-triggering-errors-and-errors-inheritance></a>
<h3>Triggering errors and errors inheritance</h3>

<p>
Not only the functions (and methods) of the standard library may fail. Also the
user's defined functions (and methods) may fail, either intentionally calling
the <tt>trigger_error()</tt> function, or omitting to handle errors that may be
raised by other functions called in their body. PHPLint collects all the errors
that are triggered inside a function (or method) and all the errors that are not
silenced, and then PHPLint signals these errors every time that function (or
method) gets used next, so making aware the programmer that these functions
generate or inherit errors that should be handled in some way.
</p>



<a name=errors-mapping-errors-into-exceptions></a>
<h3>Mapping errors into exceptions</h3>

<p>
Under PHP 5, PHPLint allows to enable the mapping of errors into
an exception through the <tt>error_throws_exception</tt> pragma:
</p>

<blockquote><tt>
/*. pragma 'error_throws_exception' 'ErrorException'; .*/
</tt></blockquote>

<p>
This pragma tells to PHPLint that errors of any level must be handled just like
an exception of type ErrorException. Then, for example, triggering an error
with <tt>trigger_error("Message", E_USER_ERROR);</tt> is just like throwing an
exception with <tt>new&nbsp;ErrorException("Message");</tt>.
The standard library of PHPLint provides the <tt>errors.php</tt> package
that takes advantage from this pragma to implement error mapping into
exceptions using the <tt>set_error_handler()</tt> function. So, simply
including this package you get two important benefits: unhandled errors
always causes an immediate interruption of the program, whereas handled errors
can be detected with the standard <tt>try/catch</tt> statement.
Here is an example of what happens with an unhandled error:
</p>

<blockquote><pre>
require_once "errors.php";
$fn = "file-that-does-not-exist.txt";
$f = fopen($fn, "r");
if( $f === FALSE )
    die("can't read data file");
$data = fread($f, filesize($fn));
fclose($f);

<b>==&gt;
Uncaught exception 'ErrorException' with message 'E_WARNING: fopen(file-that-does-not-exist.txt): failed to open stream: No such file or directory in /home/salsi/src/phplint/stdlib/err-test.php:5' in /home/salsi/src/phplint/stdlib/errors.php:49
Stack trace:
#0 [internal function]: error_handler(2, 'fopen(file-that...', '/home/salsi/src...', 5, Array)
#1 /home/salsi/src/phplint/stdlib/err-test.php(5): fopen('file-that-does-...', 'r')
#2 {main}
</b>
</pre></blockquote>


<p>
Errors raised by the functions of the standard library are mapped into
exceptions too, then we may catch these errors in the standard way:
</p>

<blockquote><pre>
require_once "errors.php";
$fn = "file-that-does-not-exit.txt";
try {
    $f = fopen($fn, "r");
    $data = fread($f, filesize($fn));
    fclose($f);
}
catch( ErrorException $e ){
    echo "can't access data file: $e\n";
}

<b>==&gt;
can't read data file file-that-does-not-exist.txt: fopen(file-that-does-not-exist.txt): failed to open stream: No such file or directory
</b>
</pre>
</blockquote>


<p>
Since errors cannot be silenced anymore with the <tt>@</tt> operator, the
programmer now MUST take care to handle errors or leave its program facing its
destiny, that is abrupt termination on error. And note that "minor" errors that
normally would produce an (apparently) harmless E_NOTICE, now may interrupt the
program. This is the case, for example, when an unassigned variable is used:
</p>

<blockquote>
<pre>
require_once "errors.php";
echo $unassigned_variable;

<b>==&gt;
Uncaught exception 'ErrorException' with message 'E_NOTICE: Undefined variable: unassigned_variable in /home/salsi/src/phplint/stdlib/err-test.php:4' in /home/salsi/src/phplint/stdlib/errors.php:49
Stack trace:
#0 /home/salsi/src/phplint/stdlib/err-test.php(4): error_handler(8, 'Undefined varia...', '/home/salsi/src...', 4, Array)
#1 {main}
</b>
</pre>
</blockquote>

<p>
Usage of unassigned variables can be prevented taking seriously the error
messages signaled by PHPLint as "<i>variable `$xxx' has not been assigned</i>"
and also "<i>variable $xxx might not have been assigned</i>" in case of
variables that are not definitely assigned (see chapter "Definite assignment
analysis").
</p>

<p>
Instead, accessing array's elements that do not exit is a bug that can be
detected only at runtime, and it throws an exception:
</p>

<blockquote>
<pre>
require_once "errors.php";
$a = array("zero", "one", "two");
echo $a[3];

<b>==&gt;
Uncaught exception 'ErrorException' with message 'E_NOTICE: Undefined offset: 3 in /home/salsi/src/phplint/stdlib/err-test.php:5' in /home/salsi/src/phplint/stdlib/errors.php:49
Stack trace:
#0 /home/salsi/src/phplint/stdlib/err-test.php(5): error_handler(8, 'Undefined offse...', '/home/salsi/src...', 5, Array)
#1 {main}
</b>
</pre>
</blockquote>

<p>
So, you should always check in advance for the existance of an entry in the
array whenever you are not sure that this entry really exists. This is the
case, for example, of the arrays like $_GET[], $_POST[], $_FILES[], $_COOKIE,
$SESSION[], $_ENV[] and any other array whose structure is not under the
control of our program but comes from an external source. So, always use
<tt>isset()</tt> before accessing the value:
</p>

<blockquote><pre>
require_once "errors.php";
if( isset($_GET["parameter") and is_string($_GET["parameter"]) )
    $parameter = $_GET["parameter"];
else
    $parameter = "default-value";
</pre></blockquote>

<p>
You must pay attention to the <tt>unserialize()</tt> function when applied
to arbitrary data, as it raises an exception if the data cannot be recognized
because corrupted, as it may be the case of serialized data retrieved from
a file:
</p>

<blockquote><pre>
require_once "errors.php";
require_once "autoload.php";
require_once "cast.php";
try {
    $fn = "users-data.bin";
    $f = fopen($fn, "r");
    $users_s = fread($f, filesize($fn));
    fclose($f);
    $users = cast("array[int]User", unserialize($users_s));
} 
catch(ErrorException $e){
    echo "retrieving users data from $fn: ", $e-&gt;getMessage();
    exit;
}  

<b>==&gt;
retrieving serialized data from users-data.bin: E_NOTICE: unserialize(): Error at offset 650 of 8355 bytes in /home/salsi/src/phplint/stdlib/test-unserialize.php:19
</b>
</pre></blockquote>

<p>
Note that PHP un this case raises a bare E_NOTICE that most PHP programmers
ignore, although the data retrieved from the file are corrupted and the
expected object of the class User cannot be reconstructed: this is another
case in which paying attention also to the "notices" helps making the program
safer. Note also the usage of the magic function <tt>cast()</tt> described in
the chapter "PHPLint's Standard Library"; this function checks at runtime that
the reconstructed object be really of the type we expect, in this case an array
of User objects; autoloading also garantees the User class be defined, and then
all its methods be restored.
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-exceptions'>Exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-the-exception-base-class'>The Exception base class</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-extending-exception'>Extending Exception</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-declaring-thrown-exceptions'>Declaring thrown exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-exceptions-and-prototypes-methods-and-inheritance'>Exceptions and prototypes, methods and inheritance</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-detecting-the-exceptions'>Detecting the exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-checked-exceptions'>Checked exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-unchecked-exceptions'>Unchecked exceptions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#exceptions-may-overriding-methods-throw-new-exceptions-'>May overriding methods throw new exceptions?</a><p>
<a name=exceptions-exceptions></a>
<h2>Exceptions</h2>


<p>
PHPLint knows about exceptions and checks for their proper usage. Exceptions
can be explicitly raised by the <code>throw</code> statement, then PHPLint
tracks their propagation through the call three of functions and methods.
PHPLint also accurately checks <code>try...catch</code> blocks and shows
improperly sorted <code>catch</code> brances and uncaught exceptions.
</p>

<p>
PHPLint handles exceptions thrown by a method as part of its signature, just
like the return type and its arguments. To be more precise, being the list of
the exceptions part of the interface that the method exhibits, overriding (or
implementing) methods must comply with the signature of the original method.
So, overriding (or implementing) methods cannot throw more exceptions than the
original method; nevertheless the new method can throw more specialized
exceptions derived from the exceptions already thrown by the original method
without violating the interface contract.
</p>

<p>
PHPLint also introduces unchecked exceptions, a variant of exceptions that are
not part of the contract of the interface of a function or method and have a
quite different semantic.
</p>




<a name=exceptions-the-exception-base-class></a>
<h3>The Exception base class</h3>

<p>
Exceptions are only the classes derived from the <code>Exception</code> base
class, declared in the <code>standard</code> module. In the following example,
PHPLint forbids to use a generic class as exception:
</p>

<blockquote><pre>
class NotAnException {}

throw new NotAnException();  # <b>&lt;= ERROR: not an Exception</b>
</pre></blockquote>


<a name=exceptions-extending-exception></a>
<h3>Extending Exception</h3>

<p>
The base <code>Exception</code> can be extended to get even more specialized
exception classes. In the following example the CException specializes
BException, that in turn specializes BException and so on. All these classes
are valid exceptions that will be used in the following examples:
</p>


<blockquote><pre>
/*. require_module 'standard'; .*/
class AException extends Exception {}
class BException extends AException {}
class CException extends BException {}
class DException extends CException {}
</pre></blockquote>

<p>
Given two sets of exceptions A and B, we will say that B is a <b>class
subset</b> of A if all the classes of B are also classes of A or classes
extending classes of A. In other words, if an object belongs to any of the
classes of the set B, then the object also belongs to at least one of the
classes of the set A.
</p>



<a name=exceptions-declaring-thrown-exceptions></a>
<h3>Declaring thrown exceptions</h3>

<p>
The following example declares a function that raises an exception.
This function is obviously completely useless, but will be used only
as a prototype of a function that generates an exception:
</p>

<blockquote><pre>
function f1()
<b>/*. throws BException, CException .*/</b>
{
    if( true )
        throw new BException();
    else
        throw new CException();
}
</pre></blockquote>

<p>
A function can throw exceptions with the <code>throw</code> statement but may
also inherit exceptions from other functions or methods he calls inside its
body. We will call all the exceptions a function (or method) may throw as
the <b>set of thrown exceptions.</b>
</p>

<p>
The <code>throws</code> statement must list all the exceptions the function can
throw. This is called the <b>set of declared thrown exceptions.</b> Normally
the list of the declared thrown exceptions is simply the list of the thrown
exceptions, but more in general the set of the thrown exceptions may be a class
subset of the declared thrown exceptions. So for example, the function
<code>f1()</code> might also throw <code>DException</code> because it is an
extension of <code>CException</code> and this latter already appears in the
<code>throws</code> declaration.
</p>

<p>
The signature of the function <code>void()</code> and the list of the declared
thrown exceptions are all part of the interface contract of this function, and
the client code that calls this function must comply with this contract. In
particular, the client code must either catch the declared thrown exceptions,
or it must propagate them, but it cannot ignore them.
</p>

<p>
The <code>throws</code> statement may also list others exceptions the function
does not currently throws, but the programmer is planning to add later as far
as the project evolves and new features are added.
</p>

<p>
The list of the declared thrown exceptions can also be provided by
the <code>@throws</code> line tag of a DocBlock:
</p>

<blockquote><pre>
/**
 *  Test function that simply raises some exceptions.
 *
 *  @return void
 *
 *  <b>@throws BException</b> If the B event occurs.
 *  <b>@throws CException</b> If the C event occurs.
 */
function f1(){ ... }
</pre></blockquote>

<p>
PHPLint collects and joins the exceptions declared in the <code>@throws</code>
DocBlock line tag along with the exceptions declared in the <code>throws</code>
PHPLint meta-tag. The difference among the two styles is that the
<code>@throws</code> line tag allows to indicate a description of the
conditions under which the given exception might be thrown.
</p>


<a name=exceptions-exceptions-and-prototypes-methods-and-inheritance></a>
<h3>Exceptions and prototypes, methods and inheritance</h3>

<p>
There are several contexts in which the declaration of a function must be
repeated: methods that implements an abstract method, methods that override an
inherited method, and functions and methods that implements a prototype
declared in a <code>forward</code> declaration. In all these cases there may be
a set of declared thrown exceptions in the first declaration of the method or
function (that we will call <i>original</i> for short) and another set of
declared thrown exceptions in the second declaration (that we will call
<i>new</i> for short). The new declaration must be compatible with the original
one, that is <b>the set of declared thrown exceptions in the new declaration
must be a class subset of the original declared thrown set.</b>
</p>

<p>
When function prototypes are needed, the <code>throws</code> declaration must
list all the exceptions the actual function throws.
The implementing function must then repeat this list of thrown exceptions:
</p>

<blockquote><pre>
/*. forward void function f2() throws BException; .*/

function f2()
<b>/*. throws BException .*/</b>
{
    # can throw BException or even any derived class
}
</pre></blockquote>

<p>
The <code>throws</code> declaration may also list more exceptions that are not
currently thrown by the function, but that the programmer plans to add later
as far as the project evolves.
</p>

<p>
The following example illustrates the <code>throws</code> declaration used in
interface and classes:
</p>

<blockquote><pre>
interface I1 {
    public function m() <b>/*. throws BException .*/</b> ;
}

class C1 implements I1 {
    public function m()
    <b>/*. throws BException .*/</b>
    {
        # This method may throw BException or even
        # any extension of BException.
    }
}
</pre></blockquote>

<p>
In the following example PHPLint detects that the overriding method C2::m()
throws an incompatible exception, and it raises an error:
</p>

<blockquote><pre>
class C2 extends C1 {
    public function m()
    <b>/*. throws CException, AException .*/</b>  # <b>&lt;= ERROR: invalid AException</b>
    {
        if( true )
            throw new CException();
        else
            throw new AException();  # <b>&lt;= ERROR: incompatible</b>
    }
}
</pre></blockquote>

<p>
In the example above, note that CException is a valid extension of BException
and then it is accepted. On the contrary, AException does not extend any of the
inherited exceptions (it is, by the way, a parent class) and must be rejected:
then C2::m() is not a valid overriding method of C1::m().
</p>




<a name=exceptions-detecting-the-exceptions></a>
<h3>Detecting the exceptions</h3>

<p>
PHPLint checks the proper order of the <code>catch()</code> branches, and
warns about useless branches and uncaught exceptions.
As a general rule, the <code>catch()</code> branches must be ordered
so that the more specialized exceptions come first, and then the more
general exceptions next, so the correct order is CException, BException,
AException and then Exception.
The following chunk of code illustrates several cases:
</p>

<blockquote><pre>
f1(); # <b>&lt;= Warning: uncaught exceptions CException, BException</b>

# Full handling:
try { f1(); }
catch( CException $e ){ }
catch( BException $e ){ }

# Incomplete handling:
try { f1(); }
catch( CException $e ){ }  # <b>&lt;= Warning: uncaught exception BException</b>

# Improper order of the branches:
try { f1(); }
catch( BException $e ){ }
catch( AException $e ){ }  # <b>&lt;= ERROR: CException already caught by BException</b>
</pre></blockquote>

<p>
Note that PHPLint raises a Warning message on unhandled exceptions that can
be thrown at global scope, that is in the main program; exceptions in
error messages are always sorted in the suggested catching order, then
<code>CException</code> first and <code>BException</code> next.
</p>

<p>
Instead, unhandled exceptions that can be thrown inside a function
or inside a method are accounted as exceptions thrown and then checked
against the set of the declared thrown exceptions.
</p>

<p>
Note also how PHPLint accounts for all the exceptions thrown inside the
<code>try{}</code> block and then checks every <code>catch(){}</code> branch
agains the list of exceptions involved. Exceptions not handled by any of the
<code>catch(){}</code> branches are processed just like any other exception
that can be thrown there, as explained above.
</p>


<a name=exceptions-checked-exceptions></a>
<h3>Checked exceptions</h3>

<p>
All the exceptions we seen so far are <i>checked</i> because PHPLint accurately
checks the context in which them are generated and how they propagate through
the code and sets some restrictions on their usage.
Basically, checked exceptions are part of the contract between functions and
methods and their client code.
</p>

<p>
Moreover, packages that are libraries cannot throw checked exceptions at global
scope, that is including these libraries cannot expose the client package to
unexpected abnormal termination of the program.
</p>

<p>
Checked exceptions are intended to simplify the structure of a program in order
to deal with exceptional situations that normally should not happen.
Programmers and designers of libraries can then choose if a function must
return FALSE or another special value to indicate a failure, or if it should
throw a checked exception instead. The choice depends on several factors
we will not analyze here.
</p>

<p>
The important point to stress here is that checked exceptions are part of the
contract of the method or function, and then PHPLint helps the programmer to be
always aware these exceptions should be properly caught and handled, or
declared to be thrown, but cannot be ignored.
</p>



<a name=exceptions-unchecked-exceptions></a>
<h3>Unchecked exceptions</h3>

<p>
Moreover, PHPLint also allows to declare <i>unchecked</i> exceptions
using the <code>/*. unchecked .*/</code> attribute:
</p>

<blockquote><pre>
<b>/*. unchecked .*/</b> class UncheckedException extends Exception {}
</pre></blockquote>

<p>
Unchecked exceptions do not contribute to the contract of the function or
method, and then their propagation through the code is not tracked. Unchecked
exceptions can be thrown in any context. Unchecked exceptions are normally not
reported in the generated documentation; only unchecked exceptions for which a
non-empty description is provided in a <code>@throws</code> DocBlock line tag
are reported, the others are not.
</p>

<p>
Unchecked exceptions are not part of the contract of the function or method,
rather are thrown when this contract if broken. Typically this happens when the
values submitted as arguments are not appropriate according with the
documentation of the method, or when the method is called in the wrong context
(for example, trying to access above the last item of a list when the iterator
already reported the scan is finished). The following example illustrates a
function that may throw either a checked exception or an unchecked exception:
</p>

<blockquote><pre>
class IOException extends Exception {}
<b>/*. unchecked .*/</b> class InvalidArgumentException extends Exception {}

/**
 *  Log the message.
 *  @param int $level  Severity: 0=error, 1=warning, 2=notice.
 *  @param string $msg  The message.
 *  @return void
 *  <b>@throws IOException  Failed access to the log file.</b>
 */
function doLog($level, $msg)
{
    if( $level &lt; 0 or $level &gt; 2 )
        throw new InvalidArgumentException("level=$level");
    $f = @fopen("log.txt", "a");
    if( $f === FALSE )
        throw new IOException($php_errormsg);
    $a = array("ERROR", "Warning", "Notice");
    $w = fwrite($f, $a[$level] . ": $msg\n");
    if( $w === FALSE ){
        fclose($f);
        throw new IOException($php_errormsg);
    }
    if( ! fclose($f) )
        throw new IOException($php_errormsg);
}
</pre></blockquote>

<p>
In this case the programmer decided to throw a checked exception
<code>IOException</code> if the log message cannot be appended to the file, so
that the client code can take an alternative action, for example to display the
error on the screen rather than try to save it on a file. Then the client code
has the opportunity to either catch the exception, or to declare it as thrown.
</p>

<p>
Instead this function throws the unchecked exception
<code>InvalidArgumentException</code> if the client code passed an invalid
argument $level, for example calling <code>doLog(4, "xyz");</code>: being this
a violation of the contract of usage of the function as stated in its
description, the designer of this function cannot pretend the client code be
prepared to handle a failure which himself created, so there is no reason to
make this exception checked; it is the client code that needs to be fixed. The
normal destiny of the program if this case happens is an abrupt termination.
</p>

<p>
According to this premise, normally there is no need to catch unchecked
exceptions as these should be thrown only on bugged programs.
</p>

<p>
On the contrary, checked exceptions are typically due to exceptional events
that are external to the program (file system error, lost of network
connection, missing reply from the database system, etc.) and that the program
should be interested to handle in the appropriate way.
</p>




<a name=exceptions-may-overriding-methods-throw-new-exceptions-></a>
<h3>May overriding methods throw new exceptions?</h3>

<p>
As a conseguence of the strict inheritance model PHPLint implements, new
methods that implements or override an original method can only throw
the same exceptions of the original method or even more specialized
extensions of these latter.
</p>

<p>
We will consider the following example, where an interface is defined
in order to access the elements of a list of strings:
</p>

<blockquote><pre>
class OutOfBoundException extends Exception {}

interface MyList {
    /*. string .*/ function getElement(/*. int .*/ $index)
        <b>/*. throws OutOfBoundException .*/</b>
}
</pre></blockquote>

<p>
The interface provided by the <code>getElement</code> method perfectly
fits an implementation in which the list is stored in memory, but what
if the same interface has to be implemented on a file? Accessing files
may raise exceptions like <code>IOException</code> or something alike,
but such an exception can't be thrown by <code>getElement</code> without
violating its interface contract.
So how to cope with this restriction when the new method really needs to throw
another, new exception? Here there are some suggestions and alternative
solutions:
</p>


<ul>


<li>
<p>
<b>Exception translation.</b>
The new method might throw a new exception, provided that this new exception be
an extension of any of the exceptions already raised by the original method.
For example, we may define a new exception that will be thrown if an
<code>IOException</code> occurs:
</p>

<blockquote><pre>
class OutOfBoundDueToIOException extends OutOfBoundException {}

class MyListOnFile {

    /*. string .*/ function getElement(/*. int .*/ $index)
    {
        try {
            <i>try_to_read_the_element_from_file</i>
        }
        catch( IOException $e ){
            throw new OutOfBoundDueToIOException( $e-&gt;getMessage() );
        }
    }

}
</pre></blockquote>

<p>
In newest releases of PHP, the Exception class also implements a `previous'
exception property with which you can also report to the caller the original
exception that was thrown:
</p>

<blockquote><pre>
throw new OutOfBoundDueToIOException(
    $e-&gt;getMessage(), $e-&gt;getCode(), $e);
</pre></blockquote>

</li>



<li>
<p>
<b>More specialized method.</b>
We may create a new method with another name; this new method can now throw
any exception it needs. The original method should then
be disabled calling <code>die()</code> and made deprecated:
</p>

<blockquote><pre>
class MyListOnFile {

    /** @deprecated Please use getElementFromFile() instead. */
    /*. string .*/ function getElement(/*. int .*/ $index)
	{ die("this method disabled; use getElementFromFile instead"); }

    /*. string .*/ function getElementFromFile(/*. int .*/ $index)
		/*. throws IOException .*/
    {
        <i>try_to_read_the_element_from_file</i>
    }

}
</pre></blockquote>
</li>


<li>
<p>
<b>Simply die if the caller cannot handle the exception.</b>
Simply call <code>die()</code> when the new exception occurs:
</p>

<blockquote><pre>
class MyListOnFile {

    /*. string .*/ function getElement(/*. int .*/ $index)
    {
        try {
            <i>try_to_read_the_element_from_file</i>
        }
        catch( IOException $e ){
            die( $e-&gt;getMessage() );
        }
    }

}
</pre></blockquote>

<p>
The rationale behind this radical choice is that client of the
<code>MyList</code> interface cannot be aware of the new exception this
particular implementation can throw, so dying is the only logical choice.
</p>
</li>


<li>
<p>
<b>Move any new exception you may need in the constructor of the new class.</b>
Typically, constructors are not implementation of another constructor
(the only exception being a constructor defined inside an interface,
but usually there is no any need to do that). So, a constructor can throw
any new exception it needs. In our example, the constructor of
the <code>MyListOnFile</code> might read in advance all the data from the
file, and then the <code>getElement</code> method reduces to a bare access
to the CPU memory, so it does not need to throw <code>IOException</code>
anymore:
</p>

<blockquote><pre>
class MyListOnFile {

    /. void .*/ function __construct(/*. string .*/ $filepath)
        /*. throws IOException, OutOfBoundException .*/
    { ... }

    /*. string .*/ function getElement(/*. int .*/ $index)
        /*. throws OutOfBoundException .*/
    { <i>read_the_element_from_memory</i> }

}
</pre>
</blockquote>
</li>


<li>
<b>Re-throw the checked exception as unchecked exception.</b> This is the last
resort to be considered, as checked exceptions should be be handled properly by
the client code, while rethrowing them as unchecked exception hides the actual
meaning of the exception.
</li>


</ul>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#stdlib-phplint-s-standard-library'>PHPLint's Standard Library</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#stdlib-handling-errors-errors-h'>Handling errors -- errors.h</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#stdlib-autoloading-classes-autoload-php'>Autoloading classes -- autoload.php</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#stdlib-the-typecast-magic-function-cast-php'>The typecast magic function -- cast.php</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#stdlib-include-all-all-php'>Include all -- all.php</a><p>
<a name=stdlib-phplint-s-standard-library></a>
<h2>PHPLint's Standard Library</h2>

<p>
PHPLint comes with its own library of real PHP code named <i>PHPLint
Standard Library</i>. These libraries provide features intended to be
strictly tight to the PHPLint validator. These libraries are available
under the <tt>stdlib/</tt> directory of the PHPLint package.
</p>


<a name=stdlib-handling-errors-errors-h></a>
<h3>Handling errors -- errors.h</h3>

<p>
The <tt>stdlib/errors.php</tt> sets the error log level to the maximum
value and maps errors, warnings and notices into exceptions, to be
more precise into <tt>ErrorException</tt>. This provides two benefits:
</p>

<ul>

<li>
Errors can be now managed with only one tool, that is the try/catch statements.
Note that <tt>ErrorException</tt> is checked, so you must choose to either
handle these errors, or declare them as thrown by the function or method.
This improves the safety of the program because it is garanteed the
error is handled somewhere.
</li>

<li>
Protects the program against the access to missing entries in arrays. In fact,
by default under PHP accessing an unexisting array element produces a simple
E_NOTICE, altought this error might have severe conseguences on the safety of
the program. Moreover, selecting an invalid entry generates NULL as value,
which might bring to unexpected errors several statement later, making
debugging more difficult. So detecting these events may be really important for
the safety of the whole program.
</li>

</ul>

<p>
The following example illustrates how simple can become error handling
of I/O functions using exceptions:
</p>

<blockquote><pre>
require_once "stdlib/errors.php";

$fn = "doesNotExist.txt";
try {
    $f = fopen($fn, "r");
    $content = fgets($f, filesize($fn));
    fclose($f);
}
catch( ErrorException $e ){
    echo $e-&gt;getMessage(), ", using default empty content.\n";
    $content = "";
}
echo $content;

<b>=&gt; WARNING [2] fopen(doesNotExist.txt): failed to open stream:
   No such file or directory in /home/salsi/test.php:18, using
   default empty content.</b>

</pre></blockquote>


<p>
The following example illustrates what happen accessing an invalid index
of an array:
</p>


<blockquote><pre>
$a = array("zero", "one", "three");
echo $a[0];
echo $a[1];
echo $a[2];
echo $a[3];
<b>=&gt; Uncaught exception 'ErrorException' with message
   'WARNING: Undefined offset: 3 in /home/salsi/test.php:13'</b>
</pre></blockquote>

<p>
If you are unsure if a certain entry of an array does exist of not, you must
then use the function <tt>array_key_exists($key, $array)</tt>.
</p>




<a name=stdlib-autoloading-classes-autoload-php></a>
<h3>Autoloading classes -- autoload.php</h3>

<p>
This package contains the magic <tt>__autoload($class)</tt> which is invoked
automatically by PHP (and then by PHPLint too) in order to resolve unknown
classes. Using this package you don't need to <tt>require_once</tt> every class
your source require, as this is performed automatically by PHP at runtime.
PHPLint applies this algorithms also to classes that appear in the meta-code,
in DocBlocks and in the <tt>cast()</tt> function.
</p>

<p>
This package should be located in the root directory of all your PHP sources
as the path of the path of the class it contruct is made relative to the
directory where the package <tt>autoload.php</tt> resides:
</p>

<blockquote><pre>
const SRC_BASE_DIR = __DIR__;

/*. unchecked .*/ class AutoloadException extends Exception {}

/*. void .*/ function __autoload(/*. string .*/ $name)
{
    /*. pragma 'autoload' './' '/' '.php'; .*/
    $fn = (string) str_replace("\\", "/", $name) . ".php";
    if( ! is_readable($fn) )
        throw new AutoloadException("__autoload($name): file $fn does not exist or not readable");
    require_once $fn;
}
</pre></blockquote>

<p>
The <code>SRC_BASE_DIR</code> constant can also be used to load packages that
are not bare classes:
</p>

<blockquote><pre>
require_once SRC_BASE_DIR . "/mylib/mypkg.php";
</pre></blockquote>

<p>
To improve the safety of yours programs, this package also checks that the
proper php.ini file had been loaded, that is the php.ini file that resides
in the root directory.
</p>


<p>
The final structure of the PHP's source directory might then look similar
to this one:
</p>

<blockquote>
<pre>
(PHP's sources root)
|-- all.php
|-- autoload.php
|-- cast.php
|-- errors.php
|-- php.ini
|-- com
|   `-- acme
|       |-- framework
|       |   `-- ...
|       |-- utils
|       |   `-- ...
|       `-- website
|           `-- ...
`-- it
    `-- icosaedro
        |-- bignumbers
        |   |-- BigFloat.php
        |   `-- BigInt.php
        |-- examples
        |   |-- FunnyMessages.php (class it\icosaedro\examples\FunnyMessages)
        |   |-- User.php (class it\icosaedro\examples\User)
        |   |-- cast-test.php
        |   |-- err-test.php
        |   `-- serialize-test.php
        `-- utils
            |-- Floats.php (class it\icosaedro\examples\Floats)
            |-- Floats-test.php
            |-- Integers.php (class it\icosaedro\examples\Integers)
            |-- Integers-test.php
            |-- Strings.php (class it\icosaedro\examples\Strings)
            `-- Strings-test.php
</pre>
</blockquote>


<a name=stdlib-the-typecast-magic-function-cast-php></a>
<h3>The typecast magic function -- cast.php</h3>

<p>
The <tt>cast.php</tt> package provides the <tt>cast()</tt> magic function as
described in the chapter <b>Typecasting</b>. It also defines the
<tt>CastException</tt> unchecked exception derived from <tt>Exception</tt>.
</p>




<a name=stdlib-include-all-all-php></a>
<h3>Include all -- all.php</h3>

<p>
Finally, the <tt>all.php</tt> package simply loads all the packages above,
so providing full support for class autoloading, safe error handling and
safe typecasting in your programs.
</p>
<pre>

</pre>
<a name=documentator-documentator></a>
<h2>Documentator</h2>

<p>
The features of the <b>PHPLint Documentator</b> are described in the
separated document <a href="documentator.html"><code>www.icosaedro.it/phplint/documentator.html</code></a>.
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#usage-usage'>Usage</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-command-line-options'>Command line options</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-general-options'>General options</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-error-detection-options'>Error detection options</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-format-of-the-report'>Format of the report</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-exit-status'>Exit status</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#usage-examples-of-invocation'>Examples of invocation</a><p>
<a name=usage-usage></a>
<h2>Usage</h2>


<a name=usage-command-line-options></a>
<h3>Command line options</h3>

<p>
The general syntax of the command is:
</p>

<blockquote>
<code>phplint [ option | file ] ...</code>
</blockquote>

<p>
where the arguments are any combination of files and options. Options
start with an hyphen "-", so that the file names cannot start with this
character. All the arguments are parsed from left to right, and the files are
parsed in the order, so that every option affects only the files to its right.
</p>

<p>
Normally only one source file at a time should be parsed, leaving to PHPLint
to follow recursively possibly <code>require</code>d<code>_once</code>
sources.
</p>

<p>
Several files can also be provided as well, and they are parsed in the
order. But be careful because PHPLint collects items defined in each source
parsed so it cannot detect if some of these files omit to include any of
the sources already scanned. It is ok to scan several, unrelated, files at once
in order to detect possible collisions among global items: this test can
be useful if you plan afterward to include all these files in some application.
</p>

<p>
Many options are flags and have the form <code>--xxxx</code> to enable,
and the corresponding <code>--no-xxxx</code> to disable a feature.
</p>


<a name=usage-general-options></a>
<h4>General options</h4>

<dl>

<dt><code>--version</code></dt>
<dd>Print version and copyright notice of the program.</dd>

<dt><code>--help</code></dt>
<dd>Print a brief description of the command and of the options.</dd>

<dt>
<code>--php-version 4</code><br>
<code>--php-version 5</code> (default)</dt>
<dd>
The PHP version, 4 or 5. The differences among PHP 4 and 5 are mostly
limited to the OOP, but there are also some differences in the extension
modules that are available with a version of the language and not in
the other. The source is parsed according to the version specified, and
this version is also reported in the documentation so generated.
</dd>

<dt><code>--modules-path DIR1:DIR2:DIR3</code></dt>
<dd>
Modules required with <code>require_module 'MODULENAME';</code>
are first searched inside the same directory of the file currently being
parsed, then are searched inside the directories specified by this option.
The directory <code>modules/</code> that
comes with the PHPLint package hold the standard modules provided with the
PHP interpreter, but you can add also yours custom extensions.
Example:

<blockquote><code>
phplint --modules-path /home/me/phplint/modules:/home/me/php-ext
</code></blockquote>

</dd>

<dt><code>--is-module</code><br>
<code>--no-is-module</code> (default)</dt>
<dd>
This flag should never be used when checking regular user's packages; it was
introduced just as a trick to generate the documentation about extension
modules avoiding several errors from being displayed.
Enabling this flag, the parsed files are considered as files of prototypes
describing extension modules of the PHP language and then:
<ul>
<li>
Missing <code>return&nbsp;</code><i>EXPR</i><code>;</code> statements are not
signaled as error because prototypes are not actual code to be executed.
</li>
<li>
The <code>trigger_error();</code> statement may raise error codes that are
otherwise forbidden in regular user's packages, as <code>E_DEPRECATED</code>.
</li>
</ul>
This flag is effective until disabled by <code>--no-is-module</code>, so
several modules can be parsed at once with the flag enabled.
</dd>

<dt><code>--packages-path DIR1:DIR2:DIR3</code></dt>
<dd>
Packages required with <code>require_once "some/file";</code> are first
searched inside the same directory of the file currently being parsed. Then,
if the file name provided is relative,
PHPLint will continue searching for the package in the directories
specified by this option, in the order: the relative path is appended to
each directory and a slash is added between them, so the DIR1/some/file,
DIR2/some/file, etc. are scanned in turn.  The packages that are detected
in this latter way are also listed in the documentation generated under
the label "<b>include_path must resolve these packages:</b> pkg2.php,
pkg3.php" so that system administrators are made aware of the installation
requirements of the package, and will update the <code>include_path</code>
of the php.ini accordingly.
Example:

<blockquote><code>
phplint --packages-path /home/me/php-lib:/home/me/php-ext
</code></blockquote>

</dd>

<dt>
<code>--recursive</code> (default)<br>
<code>--no-recursive</code></dt>
<dd>Parse recursively every <code>require_once</code> statement that appears at
scope level zero. If disabled, does not follows require_once statements that
may appear in the sorce files given from command line; autoloading is still
available and files autoloaded may, in turn, use the require_once statement.
THis option serves only for obvious security reasons just to implement the
PHPLint-on-line mask available in the www.icosaedro.it WEB site, and should not
be used elsewhere.
<dd>

<dt>
<code>--parse-phpdoc</code> (default)<br>
<code>--no-parse-phpdoc</code></dt>
<dd>
With this option enabled, PHPLint will parse the phpDocumentor DocBlocks
comments and will collect short/long descriptions, variables, parameters, etc.
herein declared. Sources not intended to be phpDocumentor-compliant often uses
<code>/******/</code> or alike as visual markers, but these markers are not
valid DocBlocks and an error is raised: in this case it is required to disable
DocBlock parsing.
</dd>

<dt>
<code>--doc-help</code></dt>
<dd>
Displays a summary of the options of the PHPLint Documentator. See the
manual of the PHPLint Documentator for a detailed explanation of these options.
</dd>

</dl>


<a name=usage-error-detection-options></a>
<h4>Error detection options</h4>

<dl>

<dt>
<code>--ctrl-check</code> (default)<br>
<code>--no-ctrl-check</code></dt>
<dd>
Reports control characters found in strings.
</dd>

<dt>
<code>--ascii-ext-check</code> (default)<br>
<code>--no-ascii-ext-check</code></dt>
<dd>
Reports "extended ASCII" characters (ISO-xxx, UTF-8, etc.) found in the
source, either in the literal strings and in IDs. The bare HTML code
outside the PHP code is not checked.
</dd>

<dt>
<code>--print-notices</code> (default)<br>
<code>--no-print-notices</code><br>
<code>--print-warnings</code> (default)<br>
<code>--no-print-warnings</code><br>
<code>--print-errors</code> (default)<br>
<code>--no-print-errors</code></dt>
<dd>
Print error/warning/notice messages.
<i>Errors</i> are problems that might involve safety or security issues,
or that may prevent the program from running at all.  <i>Notices</i>
have mostly informational purpose, but are still useful to "fine tuning"
the source (unused variables, misspelled case-insensitive names, etc.).
<i>Warnings</i> are all the other cases that PHPLint was not able to resolve
neither as error nor as notice, anyhow human attention is required.
</dd>

</dl>


<a name=usage-format-of-the-report></a>
<h3>Format of the report</h3>

<p>
The report generated on standard output is a sequence of lines having this
general structure:
</p>

<blockquote>
<code>
<i>file_name</i>:<i>line_no</i>: <i>severity</i>: <i>textual description</i><br>
?: notice: <i>textual description</i>
</code>
</blockquote>

<p>
where
</p>

<blockquote>

	<p>
	<code><i>file_name</i></code> is the absolute path of the file the
	message is referring to,
	</p>

	<p>
	<code><i>line_no</i></code> is the line number, the first line of the
	source being the number 1,
	</p>

	<p>
	and the <code><i>severity</i></code> can be <code>FATAL ERROR</code>,
	<code>ERROR</code>, <code>Warning</code> or <code>notice</code>.
	</p>

</blockquote>

<p>
Lines beginning with a question mark are notices PHPLint cannot relate to
a specific source file.	 A fatal error is raised if PHPLint cannot proceed
with the parsing because of a severe error or an unsupported feature,
then the execution is interrupted abruptly with exit status 1.	A final line
summarizes the total number of errors and warnings found (see also the
<code>--overall</code> option):
</p>

<blockquote>
<code>
Overall test results: <i>number</i> errors, <i>number</i> warnings.
</code>
</blockquote>

<p>
The format described here is suitable to be post-processed by other programs.
Several options can modify the format of the report, mostly to render it
more readable:
</p>

<dl>

<dt>
<code>--print-source</code><br>
<code>--no-print-source</code> (default)</dt>
<dd>Print the source, line by line, along with its number before
the line be parsed. Source and diagnostic messages are so mixed
in a human-readable form.</dd>

<dt>
<code>--print-line-numbers</code> (default)<br>
<code>--no-print-line-numbers</code>
</dt>
<dd>
Enable/disable the line numbers printed along the source, when
<code>--print-source</code> is enables. Disabling line numbers the shorter
report so generated is suitable to be compared with an old one to see the
differences and to monitor the improvements of the source, avoiding to confuse
the <code>diff</code> program even if the source gets slightly changed adding
or removing lines.
</dd>

<dt>
<code>--print-file-name</code> (default)<br>
<code>--no-print-file-name</code></dt>
<dd>
Every error message marks the message with the name of the file, the line
number and the column number. The resulting report file might become very
long and difficult to read, especially if absolute file names are printed.
When this option gets disabled, and the source gets printed (--print-source),
the file name of the source itself is not printed to make the report a bit
more readable to humans; only the line number gets printed. The file name
gets printed only if the message involves errors found in imported modules.
</dd>

<dt>
<code>--print-path absolute</code> (default)<br>
<code>--print-path relative</code><br>
<code>--print-path shortest</code>
</dt>
<dd>
By default file names are always displayed as absolute paths, so to simplify
the work of automated programs to which the report has to be submitted
for further processing.
The report can be made more human readable enabling the displaying of
paths relative to the current working directory (the directory from
which PHPLint was started). The option <code>shortest</code> automatically
choose the shortest representation between the absolute and the relative
path.
</dd>

<dt>
<code>--report-unused</code> (default)<br>
<code>--no-report-unused</code></dt>
<dd>Report unused items. Items collected from here on are reported
in a notice message if not used. This include both global entities
(constants, global variables, functions, classes, class constants,
properties and methods) and local variables inside functions and methods.
</dd>

<dt>
<code>--print-context</code> (default)<br>
<code>--no-print-context</code></dt>
<dd>
When an error is detected, the line of the source involved is printed
along the error message. The exact point of the line where the error
was detected is visually marked with "<code>\_HERE</code>".
</dd>

<dt>
<code>--tab-size N</code> (default: 8)</dt>
<dd>Set the size of the tabulation character (ASCII HT) typically used
to indent the code. Every error message raised by PHPLint is preceded
by the file name, the line number and column number. The tabulation size
is required to exactly calculate the column where the problem was detected.
</dd>

<dt>
<code>--overall</code> (default)<br>
<code>--no-overall</code></dt>
<dd>Displays the last line of the report that summarizes the total number of
errors and warning. This option is useful in scripts that perform validation of
a large number of sources.
</dd>

</dl>




<a name=usage-exit-status></a>
<h3>Exit status</h3>


<dl>

<dt>
<code>--fails-on-warning</code><br>
<code>--[no-]fails-on-warning</code> (default)</dt>
<dd>
Normally the program exist status if 1 if errors were detected, and 0
otherwise. If this option is enabled, also warnings contribute to the exit
status of 1, which may be useful in automated scripts if you want to be very
strict in validating you code base.
</dd>

</dl>



<a name=usage-examples-of-invocation></a>
<h3>Examples of invocation</h3>

<p>
A typical interaction with the <code>phplint</code> command might look like
this one:
</p>

<blockquote>
<pre>
$ <b>cat test-page.php</b>
&lt;?php
/*. require_module 'standard';  .*/
require_once 'banner.php';
echo $undef_var;
phpinfo();
?&gt;

$ <b>phplint --modules-path phplint/modules test-page.php</b>
4: ERROR: variable `$undef_var' has not been assigned
4: Warning: can't determine the type of the argument of `echo'
?: notice: required module: standard
Overall test results: 1 errors, 1 warnings.
</pre>
</blockquote>

<p>
The module <code>phplint/modules/standard</code> will be loaded and the file
<code>banner.php</code> will be parsed as well. In this example, PHPLint
raised an error about a variable never assigned.
</p>


<p>
It might be useful to validate an existing source that was not intended to be
PHPLint-compliant. In this case every file of the project should be edited
in order to add the extension modules required: boring.  Useful trick:
a <code>dummy.php</code> file can contain the list of the required
extensions used by your project:
</p>

<blockquote>
<pre>
&lt;?php  # dummy.php
/*.
    require_module 'standard';
    require_module 'session';
    require_module 'mysql';
    require_module 'pcre';
.*/
?&gt;
</pre>
</blockquote>

<p>
then this file can be added to the command invoking PHPLint, just before
the file being checked:
</p>

<blockquote>
<code>$ <b>phplint</b></code> <i>options</i> <b><code>dummy.php myPage.php</code></b>
</blockquote>

<p>
There are several options and many long pathfiles to type.  You may use the
GUI version of the program (phplint.tk), but there is also another useful
trick: define your own <code>phpl</code> program using a scripting language.
Here is the script I use, written in the Bash shell scripting language,
you should only modify the pathfiles and the options accordingly to the
layout of your system:
</p>

<blockquote>
<pre>
#!/bin/bash
# Syntax: phpl OPTIONS FILES

# PHPLint package base dir (assumes this script is
# just in the base dir of the PHPLint package):
d=$(dirname $0)

$d/src/phplint \
    --no-print-file-name \
    --print-path shorter \
    --modules-path $d/modules \
    --print-source \
    --print-context \
    "$@"
</pre>
</blockquote>

<p>
Checking a file while debugging the application becomes as simple as
typing the command:
</p>

<blockquote>
<pre>
$ <b>phpl myprogr.php | less</b>
</pre>
</blockquote>

<p>
The <code>less</code> command allows to move up and down through the
report; jumping to the next error requires to type <code>/HERE</code>
and jumping to the next error requires only to press the <b>n</b> key,
or <b>SHIFT-n</b> to jump backward to the previous one.
Once the errors have been fixed, the documentation can be generated simply
adding the <code>--doc</code> option, and the file <code>myprogr.html</code>
will be produced:
</p>

<blockquote>
<pre>
$ <b>phpl --doc myprogr.php</b>
</pre>
</blockquote>

<pre>

</pre>
<a name=howto-how-to-></a>
<h2>How To...</h2>

<p>
This chapter contains a collections of suggestions to get the best results
developing with PHPLint.
</p>

<p>
<b>The declarations first.</b><br>
Since PHPLint is a single-pass parser, it is better to declare things
before to use them. On a typical WEB application, you might collect
all the constants, global variables, functions and classes on a file,
and then you can include this file in any page.
</p>

<p>
<b>Constants should be... constants!</b><br>
The expression defining a constant should be statically determinable by
the parser. Don't use variables and functions, but only literals (numbers
and strings) and other constants. If an expression isn't statically
computable, PHPLint will complain not to be able to calculate its value
or its type.
</p>

<p>
<b>Assign a value to the global variables.</b><br>
PHPLint can guess the type of these variables from the result of the
expression. Isn't required that this expression be statically evaluable,
since what is of interest to PHPLint is the resulting type, not the value.
For example:
</p>
<blockquote><pre>
$now = time();           # time() returns an int
$tout = $now + 100;      # adding two int gives another int
$today = date("Y-m-d");  # date() returns a string
</pre></blockquote>

<p>
<b>Declarations of functions and methods.</b><br>
Complete the declarations indicating the type of the returned value,
or void if no value is returned.  For any formal argument, add its type.
This is particularly recommended for libraries that are used often, but
it is useful also for ordinary programs to enforce a strict type checking.
</p>

<p>
<b>Class properties.</b><br>
Always assign them a type and/or a value, as a literal or a static
expression. PHPLint uses the result if the expression to guess the type
of the property whenever not given explicitly.
</p>

<p>
<b>Safe handling of the data coming from the browser.</b><br>
Remember that the type of the elements of the array $_POST and $_GET
can be either strings or arrays. Always check for the existence of
the parameter and its actual type. See the chapter <u>Predefined
superglobals</u> for examples.
</p>

<p>
<b>Don't use the function each().</b><br>
This function returns a generic array, so loosing the type of the
elements of the array passed by argument.  The following code

<blockquote>
<pre>
/* WRONG CODE: */
$a = array(1, 2, 3);
reset($a);
while( list($k, $v) = each($a) ){ echo $k, $v; }
</pre>
</blockquote>

<p>
although valid for the PHP interpreter, raise many error messages because
the expression inside the <code>while(EXPR)</code> is expected to be of
the type <b>boolean</b>, and the types of the variable $k and $v cannot
be determined.  The same code can be rewritten as:
</p>

<blockquote>
<pre>
$a = array(1, 2, 3);
foreach( $a as $k =&gt; $v ){ echo $k, $v; }
</pre>
</blockquote>

<p>
<b>Some functions might return values of different types.</b><br>
For example, the <code>strpos($str, $substr)</code> function returns an
integer number that is the position of the string <code>$substr</code>
inside the string <code>$str</code>, or it returns the boolean value
<code>FALSE</code> if the sub-string was not found. The right way to
handle this case is:
</p>

<blockquote>
<pre>
$pos = strpos($str, $substr);
if( $pos === FALSE )
    # not found
else
    # found
</pre>
</blockquote>

<p>
If you are interested only to know if the sub-string is contained inside the
string, the code can be made shorter:
</p>

<blockquote>
<pre>
if( strpos($str, $substr) !== FALSE )
    # found!
else
    # not found.
</pre>
</blockquote>

<p>
Another example is the function <code>ereg()</code>. The code
</p>

<blockquote>
<code>/* WRONG CODE: */<br>
if( ereg("^[0-9]+$", $str) ){ }</code>
</blockquote>

<p>
is not valid because the <code>if(EXPR)</code> instruction require
a boolean expression, but the function <code>ereg()</code> formally
returns an integer number, that is the number of characters of the given
string that match the regular expression. Even more: the function
<code>ereg()</code> returns FALSE if the regular expression does not match
the given string. If you are interested on the value returned by the
function, you should write something like this:
</p>

<blockquote>
<pre>
$n = ereg("^[0-9]+", $str);
if( $n === FALSE )
    # does not match at all
else
    # $n leading digits found
</pre>
</blockquote>

<p>
If, instead, you are only interested to check if the given string match or
not the regular expression, this is the right way:
</p>

<blockquote>
<pre>if( ereg("^[0-9]+$", $str) !== FALSE )
    # it match
</pre>
</blockquote>

<p>
The function <code>fopen()</code> formally returns a value of the type
<b>resource</b>, but it might return a <b>boolean</b> <code>FALSE</code>
value as well if the file cannot be opened. This is the right way
to use this function:
</p>

<blockquote>
<pre>
$f = fopen("xyz", "r");
if( $f === FALSE )  die("cannot open xyz");
</pre>
</blockquote>

<p>
Invalid ways:
</p>

<blockquote>
<pre>
/* WRONG CODE: */
$f = fopen("xyz", "r") or die("cannot open xyz");
# the operands of the "or" operator aren't boolean values
# because fopen() returns a resource, and die() does not
# return a value at all.

/* WRONG CODE: */
if( $f = fopen("xyz", "r") ) die("cannot open xyz");
# the expression inside if(EXPR) isn't of the type boolean.

/* Valid, but confusing: */
if( ($f = fopen("xyz", "r")) === FALSE ) die("cannot open xyz");
</pre>
</blockquote>

<p>
<b>Beware of unsafe string comparisons.</b><br>
When a string looks like a number, PHP try to compare strings as such,
so often giving unexpected results. For example, these comparisons give
TRUE, although a strict character-by-character comparison would give a well
different result:
</p>

<blockquote>
<code>
"1.00" == "1"<br>
"01" &gt;= "1"<br>
"02" &gt; "1"
</code>
</blockquote>

<p>
That's why PHPLint allows to compare strings only using the strict
comparison operators <code>===</code> and <code>!==</code> since these
two operators gives the expected results.  Any other string comparison
should be done with the <code>strcmp()</code> function. This table should
help in translating commonly used, unsafe, PHP string comparisons into
safe, PHPLint-compliant, string comparisons:
</p>

<pre>

</pre>

<blockquote>
<table align=center border=1 cellspacing=0 cellpadding=7>
<tr><th>Invalid:</th><th>Valid:</th></tr>

<tr><td><code>$a == $b</code></td>
<td><code>$a === $b</code> <center>or</center> <code>strcmp($a, $b) == 0</code>
<br>but see the note below.</td></tr>

<tr><td><code>$a != $b</code></td>
<td><code>$a !== $b</code> <center>or</center> <code>strcmp($a, $b) != 0</code>
<br>but see the note below.</td></tr>

<tr><td><code>$a &lt; $b</code></td>
<td><code>strcmp($a, $b) &lt; 0</code></td></tr>

<tr><td><code>$a &lt;= $b</code></td>
<td><code>strcmp($a, $b) &lt;= 0</code></td></tr>

<tr><td><code>$a &gt;= $b</code></td>
<td><code>strcmp($a, $b) &gt;= 0</code></td></tr>

<tr><td><code>$a &gt; $b</code></td>
<td><code>strcmp($a, $b) &gt; 0</code></td></tr>

</table>
</blockquote>

<pre>

</pre>

<p>
It is interesting to note that introducing the <code>strcmp()</code>
function, the comparison operator does not change.  Simply, we have mapped
</p>

<blockquote>
<code>$a </code><i>operator</i><code> $b</code>
</blockquote>
to
<blockquote>
<code>strcmp($a, $b) </code><i>operator</i><code> 0</code>
</blockquote>

<p>
<b>Note.</b>
There is a subtle difference among the <code>strcmp()</code> function
and the strict comparison operators when one of the strings being compared
is <code>NULL</code>. According to the <code>strcmp()</code> function the
<code>NULL</code> value is equivalent to the empty string <code>""</code>.
By the contrary, for the strict comparison operators a <code>NULL</code>
value is different from an empty string.
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-php4-classes'>PHP4 - Classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-new-attributes-for-class-items'>New attributes for class items</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-class-constants'>Class constants</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-properties'>Properties</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-methods'>Methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-example'>Example</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-overriding-properties'>Overriding properties</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-overriding-methods'>Overriding methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-special-methods'>Special methods</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-final-classes'>Final classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#php4-classes-abstract-classes'>Abstract classes</a><p>
<a name=php4-classes-php4-classes></a>
<h2>PHP4 - Classes</h2>

<p>
PHP4 classes declare properties and methods.
PHPLint extends the syntax
of the PHP 4 classes adding the visibility attributes (<b>public</b>,
<b>protected</b> and <b>private</b>), <b>abstract</b>, <b>final</b> and
<b>static</b>.  Since these attributes are not allowed by PHP 4, they can
be specified either through the PHPLint meta-code or through a DocBlock
comment. In the examples that follow we will use the PHPLint meta-code
because it is shorter. PHPLint uses these informations in several ways:
</p>

<ul>

<li>
Any declared item must be accessed according to its visibility.
</li>

<li>
<b>static</b> methods and non-static methods must be called with the proper
operator (<code>::</code> and <code>-&gt;</code> respectively).
</li>

<li>
The <b>abstract</b> and <b>final</b> attributes control if and how a class
can be extended.
</li>

</ul>


<a name=php4-classes-new-attributes-for-class-items></a>
<h3>New attributes for class items</h3>

<p>
The new <i>visibility</i> attributes are:
</p>

<dl>

<dt><code><b>public</b></code></dt>
<dd>The item is accessible anywhere. This is the default, but it can be
specified for readability.
<p>
</dd>

<dt><code><b>protected</b></code></dt>
<dd>The item is accessible only from the class itself and from the classes
that extend this one. For example:
<pre>
/*. protected .*/ var $limited_access_var = 123;
/*. protected int .*/ function GetNo(){ ... }
</pre>
</dd>

<dt><code><b>private</b></code></dt>
<dd>The item is accessible only from the class where it is defined.
<pre>
/*. private .*/ var $log_file = /*. resource .*/ NULL;
/*. private void .*/ function ResetStatus(){ ... }
</pre>
</dd>

</dl>

<p>
Any non-static item declared inside a class is by default tied to an
object and can be accessed through the "dynamic" dereferencing operator
"<code>-&gt;</code>", for example <code>$obj-&gt;<i>item</i></code>.  Methods
that do not use the special variable <code>$this</code> can be marked as
<b>static</b> and must be accessed through the "static" dereferencing operator
"<code>::</code>", for example <code>ClassName::static_func()</code>. A
property cannot be <b>static</b> (only PHP 5 implements the static properties).
</p>

<p>
The <b>final</b> attribute marks methods that cannot be overridden.
A <b>private final</b> item is allowed, although it does not make much sense,
since if it is <b>private</b> isn't visible from outside the class.
</p>


<a name=php4-classes-class-constants></a>
<h3>Class constants</h3>

<p>
PHP 4 does not provide support for class constants.
Constants can be declared using the <code>define()</code> statement
at global scope.
</p>


<a name=php4-classes-properties></a>
<h3>Properties</h3>

<p>
Properties are variables automatically instantiated for every new
object of the class. Every object has its own set of properties.
</p>

<p>
All the properties of the class must be declared explicitly (PHPLint
restriction). At run-time you cannot assign new properties to an existing
object, so that <code>$obj-&gt;newProp = 123;</code> is an error (PHPLint
restriction).
</p>

<p>
A property can be declared using a syntax similar to this one:
</p>

<blockquote>
<pre>
/*. <i>visibility</i> .*/ var /*. <i>x_type</i> .*/
    $prop1,
    $prop2 = EXPR1,
    $prop3 = EXPR2;
</pre>
</blockquote>

<p>
Note that several properties can be declaredi in a single statement, all having
the same type and visibility attributes.
</p>

<p>
The visibility attribute is optional, and the default is <b>public</b>.
</p>

<p>
The type is optional. It is simpler and often shorter to indicate a proper
initial value.
</p>

<p>
Properties cannot be <b>final</b> nor <b>static</b>.
</p>

<p>
<b>public</b> and <b>protected</b> properties cannot be overridden nor
re-defined in extended classes (PHPLint restriction).
</p>

<p>
<b>private</b> properties cannot be re-defined (PHPLint restriction due to the
PHP 4 lack of actual support of the <b>private</b> visibility attribute).
</p>

<pre>

</pre>
<DIV><FIELDSET><LEGEND><b>IMPORTANT</b></LEGEND>
<p>
The PHP interpreter initializes all the properties that lack an initial value
to the NULL value. According to the type model of PHPLint, the NULL value is
not allowed for variables of simple type <b>boolean</b>, <b>int</b> or
<b>float</b>. In these cases PHPLint requires that an initial value be always
specified, for example <code>FALSE</code>, <code>0</code> or <code>0.0</code>
respectively otherwise an error is signaled.
</p>
</FIELDSET></DIV>
<pre>

</pre>


<p>
Properties can be accessed in several ways:
</p>

<blockquote>

<p>
<code>$this-&gt;v</code>
<br>
Inside a method to access a local property, or an inherited
<b>public</b>|<b>protected</b>, property.
</p>

<p>
<code>$obj-&gt;v</code>
<br>
Everywhere to access a <b>public</b> property.  Note that <b>protected</b>
properties are not accessible this way, but only through $this-&gt;v.
Accessing via $obj-&gt; to <b>protected</b> properties is forbidden
(PHPLint restriction).
</p>

</blockquote>



<p>
Lets see how a property can be declared through some examples:
</p>

<p><code>var $something;</code></p>
<blockquote>
A <b>public</b> property of default type <b>mixed</b> and undefined
initial value. PHPLint raises a warning on this declaration, since the
default value of this property once the object will be created is NULL,
a value that might not be suitable for the intended usage of the variable.
</blockquote>

<p><code>var $counter = 123;</code><br>
<code>var $fn = "";</code><br>
<code>var $fd = /*.(resource).*/ NULL;</code>
</p>
<blockquote>
Three <b>public</b> properties of the type <b>int</b>, <b>string</b>
and <b>resource</b> respectively. Note that the NULL value requires
a formal type-cast, as we already explained.
</blockquote>

<p><code>/*. private .*/ var $names = /*. (array[int]string) .*/ array();</code></p>
<blockquote>
A <b>private</b> property of type <b>array[int]string</b>, initially
empty, and that cannot be used outside its class.
</blockquote>


<a name=php4-classes-methods></a>
<h3>Methods</h3>

<p>
Methods can have one of the visibility attributes <b>private</b>
or <b>protected</b> or <b>public</b>.  The default attribute is
<b>public</b>.
</p>

<p>
<b>private</b> methods are accessible only inside the code of the
class itself, and are not visible outside. <b>private</b> methods
cannot be overridden in the child classes (PHP4 limitation).
</p>

<p>
<b>protected</b> methods are accessible only from the class itself and
its child classes.
</p>

<br>
<b>public</b> methods are always accessible and can be overridden.
</p>

<p>
Methods can have the <b>static</b> attribute.
<b>static</b> methods cannot use the special variable <b>$this</b>.
<b>static</b> methods can be accessed only through the "::" operator.
Non-static methods (the default) can be accessed only through
the "-&gt;" operator.
</p>

<p>
Methods can have the <b>final</b> attribute.
<b>final</b> methods cannot be overridden. <b>private</b> methods
cannot be <b>final</b>.
</p>

<p>
The general syntax of methods is the same we
already seen for the regular functions (see chapter <u>Functions</u>),
apart the attributes.
Lets see how a method can be declared through some examples:
</p>

<p><code>function doSomething(){}</code></p>
<blockquote>
A <b>public</b>, non-static, method of default type <b>undefined</b>. PHPLint
can guess the returned type from the <code>return</code> instruction,
if any is present inside the body of the method.
</blockquote>

<p><code>/*. protected int .*/ function getCounter()<br>
{ return $this-&gt;counter; }</code></p>
<blockquote>
A <b>protected</b>, non-static, method that returns an <b>int</b>
number.
</blockquote>

<p><pre>/*. public final array[int]string .*/
function getNames(/*. string .*/ $substr)
{
    $res = /*. (array[int]string) .*/ array();
    foreach($this-&gt;names as $v){
        if( strpos($v, $substr) !== FALSE ){
            $res[] = $v;
        }
    }
    return $res;
}</pre></p>
<blockquote>
A <b>public</b>, <b>final</b>, method that returns an <b>array</b> of
<b>string</b>s.
</blockquote>

<p>
Methods can be accessed in several ways, depending on the context
and on their attributes:
</p>

<blockquote>

<p>
<code>$this-&gt;f()</code>
<br>
Inside a non-static method to access a local non-static method, or an
inherited <b>public</b>|<b>protected</b>, non-static method.
</p>

<p>
<code>parent::f()</code>
<br>
Inside a method to access an inherited <b>public</b>|<b>protected</b>
<b>static</b>|non-static method. Useful if the inherited method has
been overridden, so <code>parent::f()</code> is the original method,
while <code>$this->f()</code> (if non-static) or <code>CLASSNAME::f()</code>
(if <b>static</b>) is the overriding one. Note the usage of the <i>static
resolution operator</i> "<code>::</code>" also for non-static methods:
in fact in this case the dynamic binding does not take place since the
method we are referring to is statically determined.  The typical
usage is calling the parent constructor from the overriding one using
<code>parent::CLASSNAME();</code> (remember that if the constructor
is overridden, the parent constructor isn't called automatically when
a new object is created).
</p>

<p>
<code>CLASSNAME::f()</code>
<br>
Everywhere to access a <b>static</b>, <b>public</b> method.
</p>

<p>
<code>$obj-&gt;f()</code>
<br>
Everywhere to access a non-static, <b>public</b> method.
<b>protected</b> methods are not accessible this way (PHPLint restriction).
</p>

</blockquote>


<p>
PHPLint will raise an error message if a <b>static</b> method does use the
special variable <code>$this</code> (PHPLint restriction).
</p>


<a name=php4-classes-example></a>
<h3>Example</h3>

<p>
Here is a complete example of an (useless) class in PHP 4:
</p>


<pre>

class A {

    /*. public .*/ var
        $prompt = "The current value is ",
        $counter = 0;

    /*. private .*/ var
        $internal_counter = 0,
        $list_of_names = /*.(array[int]string).*/ array();

    function A(/*. int .*/ $n)
    { 
        $this-&gt;counter = $n;
    }

    function get()
    {
        return $this-&gt;prompt . $this-&gt;counter;
    }

    /*. static string .*/
    function getParam(/*. string .*/ $name)
    {
        if( isset( $_REQUEST[$name] ) )
            return (string) $_REQUEST[$name];
        else
            return NULL;
    }
}


$title = A::getParam("TITLE");
$obj = new A(789);
echo $obj-&gt;get();  # Output: "The current value is 789"

</pre>


<a name=php4-classes-overriding-properties></a>
<h3>Overriding properties</h3>

<p>
Properties cannot be overridden (PHPLint restriction).
</p>



<a name=php4-classes-overriding-methods></a>
<h3>Overriding methods</h3>

<p>
A class B is said to be a <i>subclass</i> of the class A if the class
B extends the class A or if the class B extends a class X that is a
subclass of A (note the recursive definition).
</p>

<p>
Normally, the names of the methods of a subclass differ from any other
method of its parent class.  However, the subclass B can override
the method A::a() of its parent class defining the overriding
method B::a().
</p>

<p>
The basic rule of the polymorphism in OOP is that <i>overridden methods
must be usable exactly as the original ones</i>. For example, if A::a()
is expected to return a string, the overriding method B::a() must return
a string; if A::a() requires two mandatory arguments, also B::a() must be
callable with two arguments.
PHPLint checks accurately every overridden method: both the signature and
the attributes are compared and possible incompatibilities are detected.
Lets start defining what a signature is.
</p>

<p>
The <i>signature</i> of a method is given by
</p>

<ol>

<li>
the type of the <b>returned value</b>, possibly <code>void</code> if none is
returned;
</li>

<li>
the type of each <b>mandatory</b> formal argument;
</li>

<li>
the type of each <b>default</b> formal argument;
</li>

<li>
the possible presence of <b>optional</b> arguments <code>/*. args .*/</code>
(PHPLint extension).
</li>

</ol>

<p>
For example, the signature of the method
</p>

<blockquote><code>
/*. string .*/ function aMethod(/*. string .*/ $s, $n = 2 /*., args .*/){}
</code></blockquote>

<p>
is given by its return type (string), its mandatory arguments (one of
type string), its optional arguments (one of type int) and its variable
number of optional arguments (args). To be concise:
</p>

<blockquote><code>
string(string [, int, ...])
</code></blockquote>

<p>
The attributes and the signature of the overriding method B::a() are subject
to these rules (PHPLint restrictions):
</p>

<ul>

<li>The two methods must have the same name.
</li>

<li>The two methods must be both non-static or both <b>static</b>.</li>

<li>The visibility of the new method must be the same or greater:
    if A::a() is protected, B::a() can be either protected or public;
    if A::a() is public, B::a() must be public.
</li>

<li><b>final</b> methods cannot be overridden.
</li>

<li>
The signature of the overriding method must be compatible with the
signature of the overridden method, that is:

	<ul>

	<li>
	The return type must be the same of the overridden method.
	If the return type is an object, it may also be a sub-class.
	</li>

	<li>
	For each matching formal argument, the passing method (by value, return
	by reference or by reference) must be the same.
	</li>

	<li>
	The type of each argument must be the same of the overridden method.
	If the argument is an object passed by value, it may also be a sub-class.
	</li>

	<li>
	If the parent method has only mandatory arguments (or no arguments
	at all), the overridding method can add default arguments and
	optional arguments.
	</li>

	<li>
	If the parent method has default arguments, the overridding method can
	add more default arguments and optional arguments.
	</li>

	</ul>
</li>

</ul>

<p>
In this example, the subclass B overrides all the methods of its parent class
A. The body of all the methods is left empty, since it does not matter in
our discussion. Note that B::g() adds a default argument $y, and B::h()
adds optional arguments and raises its visibility from <b>protected</b>
to <b>public</b>.
</p>

<pre>

class A {
    /*. void .*/ function f(){}
    /*. int  .*/ function g(/*. int .*/ $i){}
    /*. protected void .*/ function h(/*. int .*/ $x){}
}

class B extends A {
    /*. void .*/ function f(){}
    /*. int  .*/ function g(/*. int .*/ $x, /*. int .*/ $y = 0){}
    /*. public void .*/ function h(/*. int .*/ $x /*., args .*/){}
}

</pre>



<a name=php4-classes-special-methods></a>
<h3>Special methods</h3>

<p>
A method whose name is the same as the class is assumed to be the
constructor. The constructor is called implicitly by the <b>new</b>
operator. A class constructor can be called explicitly only inside the
constructor of an extended class and it cannot be called explicitly elsewhere
(PHPLint restriction).
</p>

<p>
The signature of the special methods <code>__sleep()</code> and
<code>__wakeup()</code> must be as follows:
</p>

<blockquote><pre>
/*. public array[int]string .*/ function __sleep();
/*. public void .*/ function __wakeup();
</pre></blockquote>

<p>
An error is raised if the method name begins with two underscore characters,
since those names are reserver for future extensions of the language.
</p>


<a name=php4-classes-final-classes></a>
<h3>Final classes</h3>

<p>
A <b>final</b> class is a class that cannon be extended anymore.
Since the <b>final</b> attribute is an extension to the PHP 4 language,
it can be indicated either through PHPLint meta-code
</p>

<blockquote><pre>
/*. <b>final</b> .*/ class CLASS_NAME { ... }
</pre></blockquote>

<p>
The reasons why a class should be made "non-extensible" go beyond the
aims of this reference manual. Take a good book about OOP if you are
interested to the subject.
</p>

<p>
In the following examples we will use the PHPLint meta-code because it
is shorter, although you can use a DocBlock instead with exactly the same
meaning.
</p>




<a name=php4-classes-abstract-classes></a>
<h3>Abstract classes</h3>

<p>
An abstract class is a class with the <b>abstract</b> attribute in its
declaration. The <b>abstract</b> attribute is an extension to the PHP 4
language, so it must be indicated either through meta-code
</p>

<blockquote><pre>
/*. <b>abstract</b> .*/ class MyAbsClass { ... }
</pre></blockquote>

<p>
or unsing the <code>@abstract</code> line tags of a DocBlock.
</p>

<p>
Abstract classes can contain abstract methods, i.e. methods whose body
is left empty. Abstract methods must have the <b>abstract</b> attribute:
</p>

<blockquote><pre>
/*. <b>abstract</b> .*/ class MyAbsClass {

    /*. abstract void .*/ function doSomething() {}

}
</pre></blockquote>

<p>
An abstract class can have also non-abstracti (aka "concrete") methods and
properties. The basic properties of abstract classes are:
</p>

<ul>

<li>
Abstract classes are intended to be a model for other "concrete" classes,
so that all the extended classes derived from them share a common behavior. As
a logical consequence, abstract classes cannot be <b>final</b>.
</li>

<li>
An abstract class can extend another abstract class.  The extended abstract
class inherits the properties, the methods and the abstract methods of its
parent class.
</li>

<li>
A concrete (i.e. non-abstract) class MUST implement all the abstract
methods inherited from the abstract class it extends.
</li>

<li>
Your program can process abstract objects that belong to an abstract
class, whatever the concrete class to which they actually belong may
be.
</li>

<li>
You cannot instantiate an object from an abstract class.
</li>

</ul>

<p>
This example should be self-explanatory. An abstract class provides
the interface to a generic container of strings; every string has a name
and its value can be written and read with the abstract methods
set() and get():
</p>

<blockquote><pre>
/*. <b>abstract</b> .*/ class StringContainer {

    /*. abstract void .*/ function set(
        /*. string .*/ $name,
        /*. string .*/ $value){}

    /*. abstract string .*/ function get(/*. string .*/ $name){}

    /*. abstract void .*/ function dispose(){}
}
</pre></blockquote>

<p>
Since this class is abstract it cannot be used directly to instantiate objects,
but it must be implemented in some concrete class. For example, the following
example shows two concrete classes that implements
<code>StringContainer</code>. These implementations are very crude, without
error handling and with possible infinite loops: do not use them in real
applications! The first implementation, <code>StringOnFile</code>, creates a
directory whose name is randomly generated, then here it saves the value of
each string in a file with its name:
</p>

<blockquote><pre>
class StringOnFile extends StringContainer {

    /*. private .*/ var /*. string .*/ $dir;

    /*. void .*/ function StringOnFile()
    {
        do {
            $this-&gt;dir = "strings-" . rand();
        } while( file_exists( $this-&gt;dir ) );
        mkdir( $this-&gt;dir );
    }

    /*. void .*/ function set(
        /*. string .*/ $name,
        /*. string .*/ $value)
    {
        file_put_contents( $this-&gt;dir ."/$name", $value);
    }

    /*. string .*/ function get(/*. string .*/ $name)
    {
        $s = file_get_contents( $this-&gt;dir ."/$name" );
        return ($s===FALSE)? /*. (string) .*/ NULL : $s;
    }

    /*. void .*/ function dispose()
    {
        system( "rm -r ". $this-&gt;dir );
    }
}
</pre></blockquote>


<p>
The second implementation, <code>StringOnSession</code> saves each string in
the current session:
</p>

<blockquote><pre>
class StringOnSession extends StringContainer {

    /*. private .*/ var /*. string .*/$arr;

    /*. void .*/ function StringOnFile()
    {
        do {
            $this->arr = "strings-" . rand();
        } while( isset( $_SESSION[ $this->arr ] ) );
        $_SESSION[ $this->arr ] = array();
    }

    /*. void .*/ function set(
        /*. string .*/ $name,
        /*. string .*/ $value)
    {
        $arr = /*.(array[string]string).*/ &amp; $_SESSION[ $this->arr ];
        $arr[$name] = $value;
    }

    /*. string .*/ function get(/*. string .*/ $name)
    {
        $arr = /*.(array[string]string).*/ &amp; $_SESSION[ $this->arr ];
        if( ! isset( $arr[$name] ) )
            return (string) NULL;
        return $arr[$name];
    }

    /*. void .*/ function dispose()
    {
        unset( $_SESSION[ $this->arr ] );
    }
}
</pre></blockquote>

<p>
The power of abstract classes can be seen in the code below, where the
function can handle a container without knowing anything about its concrete
implementation. The object $container has only formally the type
<code>StringContainer</code>, but actually the concrete object that will
be passed to the function will be an instance of some implementation of
this abstract class. By the way, this function saves every entry of an
associative array into the container given:
</p>

<blockquote><pre>
/*. void .*/ function SaveParams(
    /*. array[string]string .*/ &amp; $params,
    /*. StringContainer     .*/ $container)
{
    foreach($params as $k =&gt; $v)
        $container-&gt;set($k, $v);
}


$data = array("userid"=&gt;"guest",
    "username"=&gt;"Guest",
    "userprivileges"=&gt;"0");

/* Save data on file: */
SaveParams($data, new StringOnFile());

/* Save data on session as well: */
SaveParams($data, new StringOnSession());
</pre></blockquote>
<pre>

</pre>
<a name=php4-typeconversionoperators-php4-type-conversion-operators></a>
<h2>PHP4 - Type conversion operators</h2>

<p>
A <i>type conversion operator</i> is a formal conversion of the type of a
term. Neither the value of the term, nor its type are really changed.
These type conversion operators are often required because some functions
return a generic type <b>mixed</b>, <b>array</b> or <b>object</b> that
does not fit the type of the expression where these function are called.
Another typical case where a type conversion operator is required
is to set the correct type for the <code>NULL</code> constant and the
empty array <code>array()</code>: we already seen some examples in the
chapter <u>Functions</u>.
<p>

<pre>

</pre>

<table cellspacing=0 cellpadding=3 border=2>

<tr bgcolor=ccccff>
<th>Type conversion operator</th>
<th>Applied to</th>
<th>Description</th>
</tr>

<tr>
<td valign=top><code>/*. (string) .*/<br>/*.&nbsp;(array)&nbsp;.*/<br>/*.&nbsp;(array&nbsp;...)&nbsp;.*/<br>/*. (resource)
.*/<br>/*. (object) .*/<br>/*.&nbsp;(</code><i>CLASS_NAME</i>&nbsp;<code>)&nbsp;.*/
</code>
</td>

<td valign=top><b>null</b></td>

<td valign=top>
The <code>NULL</code> value can be formally converted into any
type which is a reference in the PHPLint type model (see chapter
<u>Types</u>).
</td>
</tr>



<tr>
<td valign=top><code>
/*. (bool) .*/<br>
/*. (int) .*/<br>
/*. (float) .*/<br>
/*. (string) .*/<br>
/*.&nbsp;(array)&nbsp;.*/<br>
/*.&nbsp;(array&nbsp;...)&nbsp;.*/<br>
/*. (resource) .*/<br>
/*. (object) .*/<br>
/*.&nbsp;(</code><i>CLASS_NAME</i>&nbsp;<code>)&nbsp;.*/
</code></td>



<td valign=top><b>mixed</b></td>

<td valign=top>
A value of the type <b>mixed</b> can be formally converted to any type.
The program should take care to check the type of the value
before to do the conversion using one of these functions:
<code>is_bool()</code>,
<code>is_int()</code>,
<code>is_float()</code>,
<code>is_string()</code>,
<code>is_array()</code>,
<code>is_resource()</code>,
<code>is_object()</code>.
The class to which an object belong to can be checked with the function
<code>is_a()</code> (PHP 4) or the binary operator <code>instanceof</code>
(PHP 5).<br>
Note that the exact structure of an array cannot be checked easily at
run-time, so that the correcness of the conversion is in charge to the
internal logic of the program.<br>
Note that a value of the type <b>mixed</b> might be <b>NULL</b>;
you can check this value either using the logical expression
<code>\$value===NULL</code> or the function <code>is_null(\$value)</code>;
note that the original type to which this value belonged to cannot be
guessed at run-time.
Please, note the <code>is_string()</code>,
<code>is_array()</code>,
<code>is_resource()</code>,
<code>is_object()</code> give <code>FALSE</code> if their argument is the
value <code>NULL</code>.
</td>
</tr>



<tr>
<td valign=top><code>/*. (array ... ) .*/</code></td>

<td valign=top><b>array</b></td>

<td valign=top>
This operator lets to declare
the structure of a term of the generic type <b>array</b>. Note that
this operator cannot be applied to an array of a known structure; an
array of a given structure can be converted to an array of a different
structure using a specific algorithm.
</td>
</tr>



<tr>
<td valign=top><code>/*. (object) .*/<br>
/*. (</code><i>CLASS_NAME</i>&nbsp;<code>)&nbsp;.*/</code>
</td>

<td valign=top><b>object</b></td>

<td valign=top>
This operator converts the type of a generic <b>object</b> value to the
instance of the given class name. Before to apply this operator, the
program should check the actual class to which the object belong to using
the <code>instanceof</code> binary operator (PHP 5) or the <code>is_a()</code>
function (PHP 4).
</td>
</tr>

</table>

<pre>

</pre>

Examples:

<blockquote><pre>
$abc = array("a", "b", "c");
$cba = /*. (array[int]string) .*/ array_reverse($abc);
/* Reverse the order of the elements of the array $abc.
   Note that the formal type-cast conversion operator is
   required because the function array_reverse() returns
   a generic array, so loosing info about the actual
   structure of the resulting array. */

class A { }
$obj = /*. (A) .*/ NULL;
/* This variable is an object initially NULL. Since NULL
   is not a well defined type, a formal type-cast is required. */

$arr = /*. (array[int]string) .*/ array();
/* An array of strings with int index, initially empty. Since
   the empty array does not allows to PHPLint to guess neither the
   type of the index nor the type of the elements, a formal
   type-cast is required. */


class A_DOG { function bark(){} }
class A_CAT { function miaow(){} }

function Play(/*. object .*/ $obj)
/*
    Since this function accepts an object of different
    classes, type conversion operators will be required.
*/
{
    if( $obj instanceof A_DOG ){
        echo "It's a dog";
        $dog = /*. (A_DOG) .*/ $obj;
        $dog->bark();
        /* NOTE: $obj->bark() would be correct for PHP, but
           it would not for PHPLint, since a generic object
           does not has the method bark().  That's why a new
           variable $dog needs to be introduced. */
    } else if( $obj instanceof A_CAT ){
        echo "It's a cat";
        $cat = /*. (A_CAT) .*/ $obj;
        $cat->miaow();
    } else {
        echo "It's an unexpected animal";
    }
}

Play(new A_DOG());
Play(new A_CAT());
</pre></blockquote>


<p>
The last example involving cats and dogs is a typical example of how programs
<b>should not</b> be written. PHP 5 introduces the interfaces to resolve in a
more elegant way problems like this. PHP 4 does not has interfaces, but still
PHPLint allows to declare abstract classes with which a similar result can be
achieved.
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#reserverdkeywords-reserved-keywords'>Reserved keywords</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#reserverdkeywords-php-keywords'>PHP keywords</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#reserverdkeywords-phplint-keywords'>PHPLint keywords</a><p>
<a name=reserverdkeywords-reserved-keywords></a>
<h2>Reserved keywords</h2>

<p>
There are some differences on how PHP and PHPLint scan the source of
a program.  PHPLint behave much like a compiler would, first scanning the source
in distinct symbols and keywords, then parsing the semantic of these
symbols. Instead, the PHP interpreter act much like a scripting language
would do, and some of the words that compose the source have a meaning that
depend on the context.
</p>


<a name=reserverdkeywords-php-keywords></a>
<h3>PHP keywords</h3>

<p>
These keywords are reserved by the parser of the PHP code, and cannot
be used for names of constants, variables, functions, classes, class
constants, properties or methods.
</p>

<blockquote>
<code>
FALSE
NULL
TRUE
abstract
and
array
as
bool
boolean
break
case
catch
class
clone
const
continue
declare
default
define
die
do
double
echo
else
elseif
enddeclare
endfor
endforeach
endif
endswitch
endwhile
exit
extends
final
float
for
foreach
function
global
goto
if
implements
include
include_once
instanceof
int
integer
interface
isset
list
namespace
new
object
or
parent
print
private
protected
public
real
require
require_once
return
self
static
string
switch
throw
trigger_error
try
use
var
while
xor
</code>
</blockquote>

<p>
This list of keywords is longer than that stated by the PHP manual.
Moreover, variables, properties and methods cannot take the name of a
keyword, also if this name might be valid for the PHP interpreter. For
example, this code:
</p>

<blockquote><pre>
define('function', 'xxxx');

class string
{
    private $private = "yyyy";

    function int()
    {
        $private = $this->private;
    }
}
</pre></blockquote>

<p>
is valid for the PHP 5 interpreter, but it is not for PHPLint because the
constant name <code>function</code>,
the class name <code>string</code>,
the property name <code>$private</code>,
the function name <code>int()</code>,
the variable name <code>$var</code>
and the property <code>...->private</code>
are all reserved keywords. PHPLint will raise an error if a constant or
variable name collide with a keyword, and a fatal error in all the
other cases.
</p>



<a name=reserverdkeywords-phplint-keywords></a>
<h3>PHPLint keywords</h3>

<p>
These keywords are reserved by PHPLint when parsing the extended code
inside the comments "<code>/*.  .*/</code>":
</p>

<blockquote>
<code>
abstract
args
array
bool
boolean
class
else
end_if_php_ver
extends
final
float
forward
if_php_ver_4
if_php_ver_5
implements
int
integer
interface
missing_break
missing_default
mixed
namespace
object
parent
pragma
private
protected
public
require_module
resource
return
self
static
string
throws
unchecked
void
</code>
</blockquote>

<p>
Since the extended code can include the class names, class names cannot
collide with these keywords.
</p>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#todolist-to-do-list'>To-do list</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#todolist-known-bugs'>Known bugs</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#todolist-missing-features'>Missing features</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#todolist-php-features-intentionally-omitted'>PHP features intentionally omitted</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#todolist-other-differences'>Other differences</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#todolist-wish-list'>Wish list</a><p>
<a name=todolist-to-do-list></a>
<h2>To-do list</h2>


<a name=todolist-known-bugs></a>
<h3>Known bugs</h3>

<ul>

<li>
Trying to parse this code

<blockquote><pre>
$a = array();
$a[] = $a;
echo $a;
</pre></blockquote>

results in a segmentation violation, due to the recursive linking among the
types of $a and $a[] that consume all the stack space before the crash.
</li>

<li>
Optional arguments of function and method declared with the meta-code
<code>args</code> arguments cannot be passed by reference. This restriction
makes impossible to declare functions like scanf("...", $x) as PHPLint always
tells that "$x is not defined".
</li>

<li>
In <code>foreach(EXPR as </code>... EXPR must be a proper variable, not a
generic expression. For example, <code>foreach(array(1,2,3) as</code> ... isn't
allowed.
</li>

<li>
Heredocs and nowdocs are allowed in initial values of static variables,
class constants and properties only since PHP &ge; 5.3.
</li>

</ul>



<a name=todolist-missing-features></a>
<h3>Missing features</h3>

<ul>
<li>Support for the back-tick operator <code>`shell command`</code>.</li>
<li>Parsing of double-quoted strings containing complex curly-brace variables <code>"${VAR}"</code> and expressions <code>"${EXPR}"</code>.</li>
<li>Support for the tags: <code>&lt;script, &lt;%, &lt;%=</code>.</li>
<li>Modules library: some generic "array" types need to be rewritten
    by hand using the structured array type of PHPLint; some classes
    (mostly spl, com) are incomplete.</li>
<li>
Dereferencing constant by object $obj::CONST is allowed since PHP 5.2.4.
</li>

<li>
Static method call with arrow CLASSNAME-&gt;staticMetod() allowed since PHP
5.2.4.
</li>

<li>goto</li>

</ul>






<a name=todolist-php-features-intentionally-omitted></a>
<h3>PHP features intentionally omitted</h3>

<ul>
<li>Variable-variables <code>$$x</code> and <code>$x-&gt;$y</code>.</li>
<li>Variable-functions <code>$x()</code>. Use
    <code>call_user_func()</code> instead.</li>
<li>Alternate syntax for control structures, example: if(EXPR):   endif;</li>
<li>The short ternary operator <code><i>expr1</i>? : <i>expr2</i></code>.</li>
</ul>


<a name=todolist-other-differences></a>
<h3>Other differences</h3>

<ul>

<li>
PHP allows for dynamically evaluated <code>case EXPR</code>, for example
<code>case someFunc(): ...</code>.  PHPLint allows only expressions whose
value can be statically determined.  This restriction is intentional
(nothing prevent PHPLint to be modified to allows generic expressions) because
this is the behavior of most of the compiled languages for performance reasons.
</li>

<li>
PHP allows the <code>include*()</code> and <code>require*()</code> statements
to <code>return</code> something just like the included code were a function.
This is not allowes by PHPLint; use regular functions or static methods.
</li>

</ul>


<a name=todolist-wish-list></a>
<h3>Wish list</h3>
<ul>
<li>Check proper usage of <code>unset()</code>. For example, you should not
<code>unset($this)</code> nor <code>unset($this-&gt;property)</code>.</li>
<li>Checking the actual encoding of the source, UTF-8, ISO-8859-1, ASCII.
Waiting to see how Unicode will be supported by PHP 6.
</li>

<li>
Converting the documentation generated to a given encoding. Currently IDs are
printed unencoded (i.e. literally) while literal strings are always printed as
ASCII. For example, if the source is UTF-8 encoded, the constant
<code>define("aaaà", "aaaà");</code> get documented as <code>aaaà =
"aaa\xC3\xA0"</code>. By default PHPLint raises a Warning if non-ASCII
characters appears in IDs or literal strings. Still waiting to see how binary
and textual strings will be implemented in PHP 6: non-ASCII printable chars in
binary strings should be rendered with \xHH codes, while textual strings should
be rendered according to the encoding of the HTML output.
</li>

</ul>
<pre>

</pre>
<p><b>Contents of this chapter</b><p>
&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-memorandum'>Memorandum</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-source-encoding'>Source encoding</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-identifiers'>Identifiers</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-constants'>Constants</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-variables'>Variables</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-functions'>Functions</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-classes'>Classes</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-class-constants'>Class::Constants</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-class-variables-aka-properties-aka-members-'>Class::Variables (aka Properties, aka Members)</a><p>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<a href='#memorandum-class-functions-aka-methods-'>Class::Functions (aka Methods)</a><p>
<a name=memorandum-memorandum></a>
<h2>Memorandum</h2>

<p>
A brief summary of the goodnesses and the oddities of the PHP
language.  All the examples are tested on PHP version 5.0.4 with
<code>error_reporting</code> set to  <code>E_ALL | E_STRICT</code>.
</p>



<a name=memorandum-source-encoding></a>
<h3>Source encoding</h3>

<p>
The source may be encoded in any of the ISO-8859 charsets, or UTF-8
or any other encoding that preserves the representation of the ASCII
charset.  PHP isn't really aware of the encoding of the file, provided
that its keywords and symbols be recognizables as sequences of ASCII
characters. For example, the reserved keyword "<code>for</code>" must be
a sequence of the corresponding three ASCII characters, whatever the encoding
of the source may be.
</p>

<p>
Strings are sequences of bytes without any particular encoding. The
multi-byte strings library mbstring provides the support for the
conversions from any encoding to another.  UTF-8 is the preferred encoding
for internationalized applications.
</p>


<a name=memorandum-identifiers></a>
<h3>Identifiers</h3>

<p>
In what will follow, an <b>identifier</b> is any sequence of letters,
digits and the underscore "_" character. The first character cannot
be a digit. The letters include the ASCII lower-case characters
<code>a</code>...<code>z</code>, the ASCII upper-case characters
<code>a</code>...<code>z</code>, and any other code from 127 to 255, so
that an ID may be encoded into the charsets ISO-8859, UTF-8, etc.  The ASCII
control code 127 (DEL) is a valid "letter".  By default, PHPLint raises
a warning if an ID contain this control code or any non-ASCII characters.
</p>


<a name=memorandum-constants></a>
<h3>Constants</h3>

<p>
The <b>constants</b> (not to be confused with the class constants,
discussed below) have their name defined by a string ("PI"), but they
must be used as an unquoted identifier (PI).
</p>

<p>
Their name is case-sensitive, but the instruction <code>define()</code>
has a third optional argument that allows the constant name to be
used in any combination of upper-case and lower-case letters.  I have
not tested is this case-insensitiveness works when the constant name
contain letters of some extended charset, but since PHP is unaware of
the encoding of the source (it might be either ISO-8859-15 or UTF-8),
I think this feature be restricted to the ASCII letters only. There is no
reasons to use this feature, so PHPLint don't allows this third arguments,
and constants are always case sensitive.
</p>

<p>
All this has some strange consequences:
</p>

<blockquote><pre>
define("VALID_NAME", 123);
echo VALID_NAME;
# ok

define("1nv@lidname", 123);
# PHPLint: invalid constant name
# PHP: accepted, but it can't be used because is an invalid ID!

define("foreach", 123);
# PHPLint: error: the constant name is a keyword
# PHP: accepted, but it is a reserved word and can't be used!
</pre></blockquote>

<p>
The scope of constants is global and they, once defined, can be seen
everywhere.  Their instance is global too: there is always one and only
one constant with a given name.
</p>

<p>
Constants cannot be re-declared.
</p>

<p>
Constants may be declared inside a function, but the scope of the constant
is still global. So this function cannot be called twice because there
would be a collision with the previous declaration. PHPLint raises a
warning if a constant is declared inside a function. The namespace of the
constants is distinct from that of the functions and that of the classes,
so that there may be several items sharing the same name but with
different meaning, depending on the context where these IDs where found.
In this example, the ID "A" is heavily overridden:
</p>

<blockquote><pre>
define("A", 123);
$A = 456;
function A(){}
class A{}

echo A, $A;
A();
$a = new A();
</pre></blockquote>

<p>
It may be a bit confusing, and in some version in the future PHPLint
might raise a warning if any of these cases occurs.
</p>


<a name=memorandum-variables></a>
<h3>Variables</h3>

<p>
Their name is an ID with a leading "<code>$</code>" character.
The name is case-sensitive.
</p>

<p>
The scope may be global or local to a function or method. The variables
instantiated inside a function are automatically released exiting that
function.  A variable local to a function cannot be seen outside that
function, and does not collide with the name of other global variables and
with the local variables of the other functions.
</p>

<p>
Some special variables, named "superglobals", have always global scope.
Superglobals are defined by the PHP interpreter and have a special
meaning. The programmer cannot define new superglobal variables.
</p>

<p>
The ID part of the name of a variable may be a reserved word:
<code>$function</code>, <code>$define</code> and <code>$true</code>
are all valid variable names.  PHPLint raises an error in these cases.
</p>



<a name=memorandum-functions></a>
<h3>Functions</h3>

<p>
The name of a function is an ID and cannot be re-declared.  Their
namespace is global.
</p>

<p>
The name of a function is case-insensitive: <code>Print()</code>,
<code>print()</code> and <code>PRINT()</code> are the same.
PHPLint promotes a clean programming style, and raises a warning if
a function is used with names that differ only by upper-case and
lower-case letters.
</p>

<p>
A function may be declared inside another function, but the first
function cannot be called once more because there would be a collision in the
namespace with the previous declaration, like in this example:
</p>

<blockquote><pre>
function parent_f()
{
    function nested_f()
    {
    }
}

parent_f(); # ok; now also nested_f() exists
parent_f(); # FATAL ERROR
</pre></blockquote>

<p>
So, practically, nested functions aren't allowed in PHP as them cannot
be used in a natural way. Nested functions are there in PHP only to allow
inclusions of files inside a function. But beware: "global" variables
of the included file becomes local variables of the function!
</p>

<p>
PHPLint raises a warning on nested functions. The <code>require_once</code>
statement is allowed only at global scope and the included file is parsed
recursively by PHPLint. The <code>require</code>, <code>include</code>
and <code>include_once</code> statements are allowed inside functions,
but the included files are not parsed recursively by PHPLint.
</p>



<a name=memorandum-classes></a>
<h3>Classes</h3>

<p>
Class names are case-insensitive. "Inner" classes are not allowed. Classes
may be declared inside a function, but if this function is called twice
it is a fatal error. Classes cannot be defined inside a method. The scope
of classes IDs is global. The namespace of the entities declared inside a
class is protected by the name of the class and does not collide with global
items.
</p>

<p>
Constants, properties and methods declared inside the class each one has a
reserved namespace; the syntax of the language allows to discern which item
has to be used. For example there may be an "x" constant, a "$x" property
and a "x()" method that can be referred as CLASS::x, CLASS::$x or $obj->x
and CLASS::x() respectively.
</p>


<a name=memorandum-class-constants></a>
<h3>Class::Constants</h3>

<p>
Case-sensitive.
</p>


<a name=memorandum-class-variables-aka-properties-aka-members-></a>
<h3>Class::Variables (aka Properties, aka Members)</h3>

<p>
Case-sensitive.
</p>



<a name=memorandum-class-functions-aka-methods-></a>
<h3>Class::Functions (aka Methods)</h3>

<p>
Case-insensitive.
</p>
<pre>

</pre>
<a name=license-license></a>
<h2>License</h2>

<p>
Copyright (c) 2005, Umberto Salsi, icosaedro.it di Umberto Salsi<br>
All rights reserved.
</p>

<p>
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
</p>

<ul>
<li>Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.
</li>

<li>Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
</li>

<li>Neither the name of the icosaedro.it di Umberto Salsi nor
the names of its contributors may be used to endorse or promote products
derived from this software without specific prior written permission.
</li>

</ul>

<p>
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</p>
<pre>

</pre>
<a name=references-references></a>
<h2>References</h2>

<ul>

<li>
<b>PHPLint</b><br>
<a href="http://www.icosaedro.it/phplint/"><code>www.icosaedro.it/phplint/</code></a><br>
Official WEB site of the PHPLint project.
<p>
</li>

<li>
<b>PHP: Hypertext Preprocessor</b><br>
<a href="http://www.php.net/"><code>www.php.net</code></a><br>
Official WEB site of the PHP programming language.
<p>
</li>

<li>
<b>Zend Technologies Ltd.</b><br>
The developers of the "core" PHP interpreter.<br>
<a href="http://www.zend.com/"><code>www.zend.com</code></a>
<p>
</li>

<li>
<b>Programming PHP</b><br>
Rasmus Lerdorf, Kevin Tatroe<br>
O'Reilly (2002), reprint 11/4<br>
ISBN 1-56592-610-2
<p>
A bit outdated (it does not cover PHP 5) but it explains the fundamentals
at the base of the PHP language.  Very interesting the section about
the application techniques and the section about the development of PHP
extensions, those that about the PHPlint terminology are called "modules".
A "must read" for every PHP programmer.
</li>

<li>
<b>PHP 5 Power Programming</b><br>
Andi Gutmans, Stig Bakken, Derick Rethans<br>
Prentice Hall PTR (2004)<br>
ISBN 013147149X<br>
<a href="http://www.phptr.com/"><code>www.phptr.com</code></a>
<p>
</li>

</ul>
<pre>

</pre>
<a name=syntax-the-syntax-of-phplint></a>
<h2>The syntax of PHPLint</h2>

<p>
The language parsed by PHPLint is a (nearly complete) subset
of the PHP language. Here the syntax is described through
the modified BNF formalism (also known as EBNF) - see <a
href="http://www.icosaedro.it/bnf_chk/index.html">www.icosaedro.it/bnf_chk/index.html</a>
for more details. The elements whose name begin with "x_" belong to the
special PHPLint meta-code and they must always appear inside a multi-line
comment <code>/*. .*/</code>. The package (element no. 1) gives the
structure of the file being parsed.
</p>

<blockquote>
NOTE.
The official BNF-like syntax of the PHP language is available in the
file <code>Zend/zend_language_parser.y</code> of the PHP source package.
A more readable version of this syntax converted in EBNF and formatted
as HTML is available in the page <a href="http://www.icosaedro.it/articoli/php-syntax.html">PHP
EBNF Syntax</a> and refers to the PHP version 5.1.1 (the comments are
in italian language, but the EBNF is still readable by anyone).
</blockquote>

<!--EBNF_START-->1. package =  { <i>text</i><sub>2</sub> | <i>code_block</i><sub>4</sub> | <i>echo_block</i><sub>5</sub> } [ <i>unclosed_code_block</i><sub>3</sub> ] ;<p>
2. text =  <code><b>"one or more characters excluding the special sequence &lt;?"</b></code> ;<p>
3. unclosed_code_block =  ( <code><b>"&lt;?"</b></code> | <code><b>"&lt;?php"</b></code> ) { <i>statement</i><sub>52</sub> | <i>x_function_proto</i><sub>119</sub> | <i>x_class_proto</i><sub>122</sub> } ;<p>
4. code_block =  <i>unclosed_code_block</i><sub>3</sub> <code><b>"?&gt;"</b></code> ;<p>
5. echo_block =  <code><b>"&lt;?="</b></code> <i>expr</i><sub>20</sub> { <code><b>","</b></code> <i>expr</i><sub>20</sub> } [ <code><b>";"</b></code> ] <code><b>"?&gt;"</b></code> ;<p>
6. namespace_separator =  <code><b>"\\"</b></code> ;<p>
7. qualified_name =  [ <i>namespace_separator</i><sub>6</sub> ] <i>id</i><sub>14</sub> { <i>namespace_separator</i><sub>6</sub> <i>id</i><sub>14</sub> } ;<p>
8. constant =  <i>qualified_name</i><sub>7</sub> ;<p>
9. variable =  <code><b>"$"</b></code> <i>id</i><sub>14</sub> ;<p>
10. func_name =  <i>qualified_name</i><sub>7</sub> ;<p>
11. class_name =  <i>qualified_name</i><sub>7</sub> ;<p>
12. class_const =  <i>id</i><sub>14</sub> ;<p>
13. class_var =  <code><b>"$"</b></code> <i>id</i><sub>14</sub> ;<p>
14. id =  ( <i>letter</i><sub>15</sub> | <code><b>"_"</b></code> ) { <i>letter</i><sub>15</sub> | <i>digit</i><sub>132</sub> | <code><b>"_"</b></code> } ;<p>
15. letter =  <code><b>"a".."z"</b></code> | <code><b>"A".."Z"</b></code> | <code><b>"\x7F".."\xFF"</b></code> ;<p>
16. static_expr =  <code><b>"FALSE"</b></code> | <code><b>"TRUE"</b></code> | <code><b>"NULL"</b></code> | <i>constant</i><sub>8</sub> | <i>literal_int</i><sub>127</sub> | <i>literal_float</i><sub>135</sub> | <i>literal_string</i><sub>138</sub> | [ <code><b>"+"</b></code> | <code><b>"-"</b></code> ] <i>static_expr</i><sub>16</sub> | <i>static_class_const</i><sub>17</sub> | <i>static_array</i><sub>18</sub> | <i>x_formal_typecast</i><sub>168</sub> <i>static_expr</i><sub>16</sub> ;<p>
17. static_class_const =  ( <i>class_name</i><sub>11</sub> | <code><b>"self"</b></code> | <code><b>"parent"</b></code> ) <code><b>"::"</b></code> <i>class_const</i><sub>12</sub> ;<p>
18. static_array =  <code><b>"array"</b></code> <code><b>"("</b></code> [ <i>static_array_pair</i><sub>19</sub> { <code><b>","</b></code> <i>static_array_pair</i><sub>19</sub> } [ <code><b>","</b></code> ] ] <code><b>")"</b></code> ;<p>
19. static_array_pair =  <i>static_expr</i><sub>16</sub> [ <code><b>"=&gt;"</b></code> <i>static_expr</i><sub>16</sub> ] ;<p>
20. expr =  <i>expr3</i><sub>21</sub> { <code><b>"or"</b></code> <i>expr3</i><sub>21</sub> } ;<p>
21. expr3 =  <i>expr4</i><sub>22</sub> { <code><b>"xor"</b></code> <i>expr4</i><sub>22</sub> } ;<p>
22. expr4 =  <i>expr6</i><sub>23</sub> { <code><b>"and"</b></code> <i>expr6</i><sub>23</sub> } ;<p>
23. expr6 =  <code><b>"print"</b></code> <i>expr6</i><sub>23</sub> | <i>expr7</i><sub>24</sub> { <code><b>"?"</b></code> <i>expr</i><sub>20</sub> <code><b>":"</b></code> <i>expr</i><sub>20</sub> } ;<p>
24. expr7 =  <i>expr8</i><sub>25</sub> { <code><b>"||"</b></code> <i>expr8</i><sub>25</sub> } ;<p>
25. expr8 =  <i>expr9</i><sub>26</sub> { <code><b>"&amp;&amp;"</b></code> <i>expr9</i><sub>26</sub> } ;<p>
26. expr9 =  <i>expr10</i><sub>27</sub> { <code><b>"|"</b></code> <i>expr10</i><sub>27</sub> } ;<p>
27. expr10 =  <i>expr11</i><sub>28</sub> { <code><b>"^"</b></code> <i>expr11</i><sub>28</sub> } ;<p>
28. expr11 =  <i>expr12</i><sub>29</sub> { <code><b>"&amp;"</b></code> <i>expr12</i><sub>29</sub> } ;<p>
29. expr12 =  <i>expr13</i><sub>30</sub> [ ( <code><b>"=="</b></code> | <code><b>"!="</b></code> | <code><b>"&lt;&gt;"</b></code> | <code><b>"==="</b></code> | <code><b>"!=="</b></code> ) <i>expr13</i><sub>30</sub> ] ;<p>
30. expr13 =  <i>expr14</i><sub>31</sub> [ ( <code><b>"&lt;"</b></code> | <code><b>"&lt;="</b></code> | <code><b>"&gt;"</b></code> | <code><b>"&gt;="</b></code> ) <i>expr14</i><sub>31</sub> ] ;<p>
31. expr14 =  <i>expr15</i><sub>32</sub> [ ( <code><b>"&lt;&lt;"</b></code> | <code><b>"&gt;&gt;"</b></code> ) <i>expr15</i><sub>32</sub> ] ;<p>
32. expr15 =  <i>expr16</i><sub>33</sub> [ ( <code><b>"+"</b></code> | <code><b>"-"</b></code> | <code><b>"."</b></code> ) <i>expr16</i><sub>33</sub> ] ;<p>
33. expr16 =  <i>expr17</i><sub>34</sub> [ ( <code><b>"*"</b></code> | <code><b>"/"</b></code> | <code><b>"%"</b></code> ) <i>expr17</i><sub>34</sub> ] ;<p>
34. expr17 =  ( <code><b>"!"</b></code> | <code><b>"+"</b></code> | <code><b>"-"</b></code> | <code><b>"~"</b></code> | <code><b>"@"</b></code> ) <i>expr17</i><sub>34</sub> | <i>expr18</i><sub>35</sub> ;<p>
35. expr18 =  ( <code><b>"++"</b></code> | <code><b>"--"</b></code> ) <i>term</i><sub>36</sub> ;<p>
36. term =  <code><b>"NULL"</b></code> | <code><b>"FALSE"</b></code> | <code><b>"TRUE"</b></code> | <i>literal_int</i><sub>127</sub> | <code><b>"INF"</b></code> | <code><b>"NAN"</b></code> | <i>literal_float</i><sub>135</sub> | <i>literal_string</i><sub>138</sub> | <code><b>"&amp;"</b></code> <i>term</i><sub>36</sub> | <i>variable</i><sub>9</sub> [ <i>dereference_var</i><sub>37</sub> ] | <i>constant</i><sub>8</sub> | <i>func_call</i><sub>44</sub> [ <i>dereference_object</i><sub>40</sub> ] | <i>class_name</i><sub>11</sub> <i>dereference_static</i><sub>38</sub> | <code><b>"self"</b></code> <i>dereference_static</i><sub>38</sub> | <code><b>"parent"</b></code> <i>dereference_static</i><sub>38</sub> | <i>new</i><sub>46</sub> | <i>clone</i><sub>47</sub> | <i>list</i><sub>42</sub> | <i>isset</i><sub>43</sub> | <i>array</i><sub>50</sub> | <i>x_formal_typecast</i><sub>168</sub> <i>term</i><sub>36</sub> | <code><b>"("</b></code> <i>php_type</i><sub>49</sub> <code><b>")"</b></code> <i>term</i><sub>36</sub> | <code><b>"("</b></code> <i>expr</i><sub>20</sub> <code><b>")"</b></code> ;<p>
37. dereference_var =  <i>dereference_array</i><sub>39</sub> | <i>dereference_object</i><sub>40</sub> | <i>assign_op</i><sub>41</sub> <i>expr</i><sub>20</sub> | <code><b>"++"</b></code> | <code><b>"--"</b></code> | <code><b>"instanceof"</b></code> ( <i>class_name</i><sub>11</sub> | <code><b>"parent"</b></code> | <code><b>"self"</b></code> ) ;<p>
38. dereference_static =  <code><b>"::"</b></code> ( <i>class_const</i><sub>12</sub> | <i>class_var</i><sub>13</sub> [ <i>dereference_var</i><sub>37</sub> ] | <i>class_func_call</i><sub>45</sub> [ <i>dereference_object</i><sub>40</sub> ] ) ;<p>
39. dereference_array =  <code><b>"[]"</b></code> <code><b>"="</b></code> <i>expr</i><sub>20</sub> | <code><b>"["</b></code> <i>expr</i><sub>20</sub> <code><b>"]"</b></code> [ <i>dereference_var</i><sub>37</sub> ] ;<p>
40. dereference_object =  <code><b>"-&gt;"</b></code> ( <i>class_var</i><sub>13</sub> [ <i>dereference_var</i><sub>37</sub> ] | <i>class_func_call</i><sub>45</sub> [ <i>dereference_object</i><sub>40</sub> ] ) ;<p>
41. assign_op =  <code><b>"="</b></code> | <code><b>"+="</b></code> | <code><b>"-="</b></code> | <code><b>"*="</b></code> | <code><b>"%="</b></code> | <code><b>"/="</b></code> | <code><b>".="</b></code> | <code><b>"&amp;="</b></code> | <code><b>"|="</b></code> | <code><b>"^="</b></code> | <code><b>"&lt;&lt;="</b></code> | <code><b>"&gt;&gt;="</b></code> ;<p>
42. list =  <code><b>"list"</b></code> <code><b>"("</b></code> [ <i>variable</i><sub>9</sub> [ <i>dereference_var</i><sub>37</sub> ] ] { <code><b>","</b></code> [ <i>variable</i><sub>9</sub> [ <i>dereference_var</i><sub>37</sub> ] ] } <code><b>")"</b></code> <code><b>"="</b></code> <i>expr</i><sub>20</sub> ;<p>
43. isset =  <code><b>"isset"</b></code> <code><b>"("</b></code> <i>variable</i><sub>9</sub> [ <i>dereference_var</i><sub>37</sub> ] { <code><b>","</b></code> [ <i>variable</i><sub>9</sub> <i>dereference_var</i><sub>37</sub> ] } <code><b>")"</b></code> ;<p>
44. func_call =  <i>func_name</i><sub>10</sub> <i>actual_args</i><sub>48</sub> ;<p>
45. class_func_call =  <i>id</i><sub>14</sub> <i>actual_args</i><sub>48</sub> ;<p>
46. new =  <code><b>"new"</b></code> { <i>class_name</i><sub>11</sub> | <code><b>"self"</b></code> | <code><b>"parent"</b></code> } [ <i>actual_args</i><sub>48</sub> ] ;<p>
47. clone =  <code><b>"clone"</b></code> <i>term</i><sub>36</sub> ;<p>
48. actual_args =  <code><b>"("</b></code> [ <i>expr</i><sub>20</sub> { <code><b>","</b></code> <i>expr</i><sub>20</sub> } ] <code><b>")"</b></code> ;<p>
49. php_type =  <code><b>"boolean"</b></code> | <code><b>"int"</b></code> | <code><b>"integer"</b></code> | <code><b>"float"</b></code> | <code><b>"double"</b></code> | <code><b>"string"</b></code> ;<p>
50. array =  <code><b>"array"</b></code> <code><b>"("</b></code> [ <i>element</i><sub>51</sub> { <code><b>","</b></code> <i>element</i><sub>51</sub> } ] <code><b>")"</b></code> ;<p>
51. element =  [ <i>expr</i><sub>20</sub> <code><b>"=&gt;"</b></code> ] <i>expr</i><sub>20</sub> ;<p>
52. statement =  <i>namespace</i><sub>54</sub> | <i>use</i><sub>55</sub> | <i>define</i><sub>64</sub> | <i>global_const5</i><sub>65</sub> | <i>global</i><sub>106</sub> | <i>static</i><sub>107</sub> | <i>echo</i><sub>108</sub> | <i>func_decl</i><sub>83</sub> | <i>class_decl</i><sub>84</sub> | <i>declare</i><sub>57</sub> | <i>if</i><sub>109</sub> | <i>for</i><sub>112</sub> | <i>foreach</i><sub>114</sub> | <i>while</i><sub>115</sub> | <i>do</i><sub>116</sub> | <i>switch</i><sub>68</sub> | <i>continue</i><sub>66</sub> | <i>break</i><sub>67</sub> | <i>exit</i><sub>117</sub> | <i>return</i><sub>118</sub> | <i>x_require_module_statement</i><sub>59</sub> | <i>require</i><sub>60</sub> | <i>require_once</i><sub>61</sub> | <i>include</i><sub>62</sub> | <i>include_once</i><sub>63</sub> | <i>expr</i><sub>20</sub> <code><b>";"</b></code> | <i>try</i><sub>73</sub> | <i>throw</i><sub>75</sub> | <i>text_block</i><sub>53</sub> | <i>empty_statement</i><sub>76</sub> | <i>compound_statement</i><sub>77</sub> ;<p>
53. text_block =  <code><b>"?&gt;"</b></code> { <i>text</i><sub>2</sub> | <i>echo_block</i><sub>5</sub> } <code><b>"&lt;?"</b></code> ;<p>
54. namespace =  <code><b>"namespace"</b></code> <i>qualified_name</i><sub>7</sub> ( <code><b>";"</b></code> | <i>compound_statement</i><sub>77</sub> ) ;<p>
55. use =  <code><b>"use"</b></code> <i>use_alias</i><sub>56</sub> { <code><b>","</b></code> <i>use_alias</i><sub>56</sub> } <code><b>";"</b></code> ;<p>
56. use_alias =  <i>qualified_name</i><sub>7</sub> [ <code><b>"as"</b></code> <i>id</i><sub>14</sub> ] ;<p>
57. declare =  <code><b>"declare"</b></code> <code><b>"("</b></code> <i>directive</i><sub>58</sub> { <code><b>","</b></code> <i>directive</i><sub>58</sub> } <code><b>")"</b></code> <i>statement</i><sub>52</sub> ;<p>
58. directive =  <i>id</i><sub>14</sub> <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> ;<p>
59. x_require_module_statement =  <i>x_require_module</i><sub>172</sub> <i>x_single_quoted</i><sub>177</sub> <i>x_semicolon</i><sub>145</sub> ;<p>
60. require =  <code><b>"require"</b></code> <i>expr</i><sub>20</sub> <code><b>";"</b></code> ;<p>
61. require_once =  <code><b>"require_once"</b></code> <i>expr</i><sub>20</sub> <code><b>";"</b></code> ;<p>
62. include =  <code><b>"include"</b></code> <i>expr</i><sub>20</sub> <code><b>";"</b></code> ;<p>
63. include_once =  <code><b>"include_once"</b></code> <i>expr</i><sub>20</sub> <code><b>";"</b></code> ;<p>
64. define =  [ <i>x_private</i><sub>86</sub> ] <code><b>"define"</b></code> <code><b>"("</b></code> <i>expr</i><sub>20</sub> <code><b>","</b></code> <i>expr</i><sub>20</sub> <code><b>")"</b></code> ;<p>
65. global_const5 =  [ <i>x_private</i><sub>86</sub> ] <code><b>"const"</b></code> <i>id</i><sub>14</sub> <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> { <code><b>","</b></code> <i>constant</i><sub>8</sub> <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> } <code><b>";"</b></code> ;<p>
66. continue =  <code><b>"continue"</b></code> [ <i>expr</i><sub>20</sub> ] <code><b>";"</b></code> ;<p>
67. break =  <code><b>"break"</b></code> [ <i>expr</i><sub>20</sub> ] <code><b>";"</b></code> ;<p>
68. switch =  <code><b>"switch"</b></code> <code><b>"("</b></code> <i>expr</i><sub>20</sub> <code><b>")"</b></code> <code><b>"{"</b></code> { <i>case</i><sub>69</sub> | <i>default</i><sub>70</sub> | <i>x_missing_default</i><sub>72</sub> } <code><b>"}"</b></code> ;<p>
69. case =  <code><b>"case"</b></code> <i>static_expr</i><sub>16</sub> <code><b>":"</b></code> { <i>statement</i><sub>52</sub> } [ <i>x_missing_break</i><sub>71</sub> ] ;<p>
70. default =  <code><b>"default"</b></code> <code><b>":"</b></code> { <i>statement</i><sub>52</sub> } [ <i>x_missing_break</i><sub>71</sub> ] ;<p>
71. x_missing_break =  <i>x_missing_break</i><sub>71</sub> <i>x_semicolon</i><sub>145</sub> ;<p>
72. x_missing_default =  <i>x_missing_default</i><sub>72</sub> <i>x_colon</i><sub>155</sub> ;<p>
73. try =  <code><b>"try"</b></code> <code><b>"{"</b></code> { <i>statement</i><sub>52</sub> } <code><b>"}"</b></code> <i>catch</i><sub>74</sub> { <i>catch</i><sub>74</sub> } ;<p>
74. catch =  <code><b>"catch"</b></code> <code><b>"("</b></code> { <i>class_name</i><sub>11</sub> } <i>variable</i><sub>9</sub> <code><b>")"</b></code> <code><b>"{"</b></code> { <i>statement</i><sub>52</sub> } <code><b>"}"</b></code> ;<p>
75. throw =  <code><b>"throw"</b></code> <i>expr</i><sub>20</sub> <code><b>";"</b></code> ;<p>
76. empty_statement =  <code><b>";"</b></code> ;<p>
77. compound_statement =  <code><b>"{"</b></code> { <i>statement</i><sub>52</sub> } <code><b>"}"</b></code> ;<p>
78. function =  <i>signature</i><sub>79</sub> [ <i>x_thrown_exceptions</i><sub>126</sub> ] <code><b>"{"</b></code> { <i>statement</i><sub>52</sub> } <code><b>"}"</b></code> ;<p>
79. signature =  [ <i>x_type</i><sub>170</sub> ] <code><b>"function"</b></code> [ <code><b>"&amp;"</b></code> ] <i>id</i><sub>14</sub> <code><b>"("</b></code> [ <i>formal_args</i><sub>80</sub> ] <code><b>")"</b></code> ;<p>
80. formal_args =  <i>x_args</i><sub>161</sub> | <i>arg</i><sub>81</sub> { <code><b>","</b></code> <i>arg</i><sub>81</sub> } [ <i>x_comma</i><sub>162</sub> <i>x_args</i><sub>161</sub> ] ;<p>
81. arg =  [ <i>x_return</i><sub>157</sub> ] [ <i>x_type</i><sub>170</sub> | <i>php5_type_hint</i><sub>82</sub> ] [ <code><b>"&amp;"</b></code> ] <i>variable</i><sub>9</sub> [ <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> ] ;<p>
82. php5_type_hint =  <code><b>"array"</b></code> [ <i>x_index</i><sub>171</sub> { <i>x_index</i><sub>171</sub> } [ <i>x_type_name</i><sub>169</sub> ] ] | <i>class_name</i><sub>11</sub> | <code><b>"self"</b></code> | <code><b>"parent"</b></code> ;<p>
83. func_decl =  [ <i>x_private</i><sub>86</sub> ] <i>function</i><sub>78</sub> ;<p>
84. class_decl =  <i>class4</i><sub>85</sub> | <i>class5</i><sub>94</sub> ;<p>
85. class4 =  [ <i>x_private</i><sub>86</sub> ] [ <i>x_final</i><sub>87</sub> ] [ <i>x_abstract</i><sub>88</sub> ] <code><b>"class"</b></code> <i>id</i><sub>14</sub> [ <code><b>"extends"</b></code> <i>class_name</i><sub>11</sub> ] <code><b>"{"</b></code> { <i>property4</i><sub>92</sub> | <i>method4</i><sub>93</sub> <i>x_method_proto</i><sub>120</sub> } <code><b>"}"</b></code> ;<p>
86. x_private =  <code><b>"private"</b></code> ;<p>
87. x_final =  <code><b>"final"</b></code> ;<p>
88. x_abstract =  <code><b>"abstract"</b></code> ;<p>
89. x_visibility =  <code><b>"public"</b></code> | <code><b>"protected"</b></code> | <code><b>"private"</b></code> ;<p>
90. x_static =  <code><b>"static"</b></code> ;<p>
91. x_unchecked =  <code><b>"unchecked"</b></code> ;<p>
92. property4 =  [ <i>x_visibility</i><sub>89</sub> ] <code><b>"var"</b></code> [ <i>x_type</i><sub>170</sub> ] <i>variable</i><sub>9</sub> [ <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> ] { <code><b>","</b></code> <i>variable</i><sub>9</sub> [ <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> ] } <code><b>";"</b></code> ;<p>
93. method4 =  { <i>x_abstract</i><sub>88</sub> | <i>x_visibility</i><sub>89</sub> | <i>x_static</i><sub>90</sub> | <i>x_final</i><sub>87</sub> } <i>function</i><sub>78</sub> ;<p>
94. class5 =  <i>class_regular</i><sub>95</sub> | <i>class_interface</i><sub>97</sub> ;<p>
95. class_regular =  [ <i>x_private</i><sub>86</sub> ] [ <i>x_unchecked</i><sub>91</sub> ] [ <code><b>"final"</b></code> ] [ <code><b>"abstract"</b></code> ] <code><b>"class"</b></code> <i>id</i><sub>14</sub> <i>class_body</i><sub>96</sub> ;<p>
96. class_body =  [ <i>extends</i><sub>98</sub> ] [ <i>implements</i><sub>99</sub> ] <code><b>"{"</b></code> { <i>const5</i><sub>102</sub> | <i>property5</i><sub>103</sub> | <i>method5</i><sub>104</sub> | <i>x_method_proto</i><sub>120</sub> | <i>abstract_method</i><sub>105</sub> } <code><b>"}"</b></code> ;<p>
97. class_interface =  [ <i>x_private</i><sub>86</sub> ] <code><b>"interface"</b></code> <i>id</i><sub>14</sub> [ <code><b>"extends"</b></code> <i>class_name</i><sub>11</sub> { <code><b>","</b></code> <i>class_name</i><sub>11</sub> } ] <code><b>"{"</b></code> { <i>public_const5</i><sub>101</sub> | [ <code><b>"static"</b></code> ] <i>signature</i><sub>79</sub> [ <i>x_thrown_exceptions</i><sub>126</sub> ] <code><b>";"</b></code> } <code><b>"}"</b></code> ;<p>
98. extends =  <code><b>"extends"</b></code> <i>class_name</i><sub>11</sub> ;<p>
99. implements =  <code><b>"implements"</b></code> <i>class_name</i><sub>11</sub> { <code><b>","</b></code> <i>class_name</i><sub>11</sub> } ;<p>
100. visibility =  <code><b>"public"</b></code> | <code><b>"protected"</b></code> | <code><b>"private"</b></code> ;<p>
101. public_const5 =  <code><b>"const"</b></code> <i>id</i><sub>14</sub> <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> { <code><b>","</b></code> <i>constant</i><sub>8</sub> <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> } <code><b>";"</b></code> ;<p>
102. const5 =  [ <i>x_visibility</i><sub>89</sub> ] <i>public_const5</i><sub>101</sub> ;<p>
103. property5 =  [ <i>visibility</i><sub>100</sub> ] [ <code><b>"static"</b></code> ] [ <i>x_type</i><sub>170</sub> ] <i>variable</i><sub>9</sub> [ <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> ] { <code><b>","</b></code> <i>variable</i><sub>9</sub> [ <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> ] } <code><b>";"</b></code> ;<p>
104. method5 =  { <i>visibility</i><sub>100</sub> | <code><b>"static"</b></code> | <code><b>"final"</b></code> } <i>function</i><sub>78</sub> ;<p>
105. abstract_method =  <code><b>"abstract"</b></code> { <i>visibility</i><sub>100</sub> | <code><b>"static"</b></code> } <i>signature</i><sub>79</sub> [ <i>x_thrown_exceptions</i><sub>126</sub> ] <code><b>";"</b></code> ;<p>
106. global =  <code><b>"global"</b></code> <i>variable</i><sub>9</sub> { <code><b>","</b></code> <i>variable</i><sub>9</sub> } <code><b>";"</b></code> ;<p>
107. static =  <code><b>"static"</b></code> [ <i>x_type</i><sub>170</sub> ] <i>variable</i><sub>9</sub> [ <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> ] { <code><b>","</b></code> <i>variable</i><sub>9</sub> [ <code><b>"="</b></code> <i>static_expr</i><sub>16</sub> ] } <code><b>";"</b></code> ;<p>
108. echo =  <code><b>"echo"</b></code> <i>expr</i><sub>20</sub> { <code><b>","</b></code> <i>expr</i><sub>20</sub> } <code><b>";"</b></code> ;<p>
109. if =  <code><b>"if"</b></code> <code><b>"("</b></code> <i>expr</i><sub>20</sub> <code><b>")"</b></code> <i>statement</i><sub>52</sub> { <i>elseif</i><sub>110</sub> } [ <i>else</i><sub>111</sub> ] ;<p>
110. elseif =  <code><b>"elseif"</b></code> <code><b>"("</b></code> <i>expr</i><sub>20</sub> <code><b>")"</b></code> <i>statement</i><sub>52</sub> ;<p>
111. else =  <code><b>"else"</b></code> <i>statement</i><sub>52</sub> ;<p>
112. for =  <code><b>"for"</b></code> <code><b>"("</b></code> [ <i>expr_list</i><sub>113</sub> ] <code><b>";"</b></code> [ <i>expr_list</i><sub>113</sub> ] <code><b>";"</b></code> [ <i>expr_list</i><sub>113</sub> ] <code><b>")"</b></code> <i>statement</i><sub>52</sub> ;<p>
113. expr_list =  <i>expr</i><sub>20</sub> { <code><b>","</b></code> <i>expr</i><sub>20</sub> } ;<p>
114. foreach =  <code><b>"foreach"</b></code> <code><b>"("</b></code> <i>expr</i><sub>20</sub> <code><b>"as"</b></code> [ <i>variable</i><sub>9</sub> <code><b>"=&gt;"</b></code> ] [ <code><b>"&amp;"</b></code> ] <i>variable</i><sub>9</sub> <code><b>")"</b></code> <i>statement</i><sub>52</sub> ;<p>
115. while =  <code><b>"while"</b></code> <code><b>"("</b></code> <i>expr</i><sub>20</sub> <code><b>")"</b></code> <i>statement</i><sub>52</sub> ;<p>
116. do =  <code><b>"do"</b></code> <i>statement</i><sub>52</sub> <code><b>"while"</b></code> <code><b>"("</b></code> <i>expr</i><sub>20</sub> <code><b>")"</b></code> <code><b>";"</b></code> ;<p>
117. exit =  ( <code><b>"exit"</b></code> | <code><b>"die"</b></code> ) [ <code><b>"("</b></code> [ <i>expr</i><sub>20</sub> ] <code><b>")"</b></code> ] <code><b>";"</b></code> ;<p>
118. return =  <code><b>"return"</b></code> [ <i>expr</i><sub>20</sub> ] <code><b>";"</b></code> ;<p>
119. x_function_proto =  <i>x_forward</i><sub>144</sub> [ <i>x_private</i><sub>86</sub> ] <i>x_signature</i><sub>123</sub> [ <i>x_thrown_exceptions</i><sub>126</sub> ] <i>x_semicolon</i><sub>145</sub> ;<p>
120. x_method_proto =  <i>x_forward</i><sub>144</sub> <i>x_method</i><sub>121</sub> ;<p>
121. x_method =  { <i>x_visibility</i><sub>89</sub> | <i>x_abstract</i><sub>88</sub> | <i>x_final</i><sub>87</sub> | <i>x_static</i><sub>90</sub> } <i>x_signature</i><sub>123</sub> [ <i>x_thrown_exceptions</i><sub>126</sub> ] <i>x_semicolon</i><sub>145</sub> ;<p>
122. x_class_proto =  <i>x_forward</i><sub>144</sub> { <i>x_private</i><sub>86</sub> | <i>x_abstract</i><sub>88</sub> | <i>x_unchecked</i><sub>91</sub> } <i>x_class</i><sub>146</sub> <i>x_id</i><sub>165</sub> [ <i>x_extends</i><sub>147</sub> <i>x_qualified_name</i><sub>167</sub> ] [ <i>x_implements</i><sub>148</sub> <i>x_qualified_name</i><sub>167</sub> { <i>x_comma</i><sub>162</sub> <i>x_qualified_name</i><sub>167</sub> } ] <i>x_lbrace</i><sub>153</sub> { <i>x_method</i><sub>121</sub> } <i>x_rbrace</i><sub>154</sub> ;<p>
123. x_signature =  <i>x_type</i><sub>170</sub> <i>x_function</i><sub>156</sub> [ <i>x_by_ref</i><sub>158</sub> ] <i>x_id</i><sub>165</sub> <i>x_lround</i><sub>149</sub> [ <i>x_formal_args</i><sub>124</sub> ] <i>x_rround</i><sub>150</sub> ;<p>
124. x_formal_args =  <i>x_args</i><sub>161</sub> | <i>x_arg</i><sub>125</sub> { <i>x_comma</i><sub>162</sub> <i>x_arg</i><sub>125</sub> } [ <i>x_comma</i><sub>162</sub> <i>x_args</i><sub>161</sub> ] ;<p>
125. x_arg =  [ <i>x_return</i><sub>157</sub> ] <i>x_type</i><sub>170</sub> [ <i>x_by_ref</i><sub>158</sub> ] <i>x_variable</i><sub>176</sub> [ <i>x_eq</i><sub>160</sub> ] ;<p>
126. x_thrown_exceptions =  <i>x_throws</i><sub>159</sub> <i>x_qualified_name</i><sub>167</sub> { <i>x_comma</i><sub>162</sub> <i>x_qualified_name</i><sub>167</sub> } ;<p>
127. literal_int =  <i>literal_int_8</i><sub>128</sub> | <i>literal_int_10</i><sub>129</sub> | <i>literal_int_16</i><sub>130</sub> ;<p>
128. literal_int_8 =  <code><b>"0"</b></code> <i>digit8</i><sub>131</sub> { <i>digit8</i><sub>131</sub> } ;<p>
129. literal_int_10 =  <code><b>"1".."9"</b></code> { <i>digit</i><sub>132</sub> } ;<p>
130. literal_int_16 =  <code><b>"0x"</b></code> <i>digit16</i><sub>133</sub> { <i>digit16</i><sub>133</sub> } ;<p>
131. digit8 =  <code><b>"0".."7"</b></code> ;<p>
132. digit =  <code><b>"0".."9"</b></code> ;<p>
133. digit16 =  <i>digit</i><sub>132</sub> | <code><b>"a".."f"</b></code> | <code><b>"A".."F"</b></code> ;<p>
134. digits =  <i>digit</i><sub>132</sub> { <i>digit</i><sub>132</sub> } ;<p>
135. literal_float =  <i>digits</i><sub>134</sub> ( <i>decimals</i><sub>136</sub> | <i>scale</i><sub>137</sub> | <i>decimals</i><sub>136</sub> <i>scale</i><sub>137</sub> ) ;<p>
136. decimals =  <code><b>"."</b></code> <i>digits</i><sub>134</sub> ;<p>
137. scale =  ( <code><b>"e"</b></code> | <code><b>"E"</b></code> ) [ <code><b>"+"</b></code> | <code><b>"-"</b></code> ] <i>digits</i><sub>134</sub> ;<p>
138. literal_string =  <i>single_quoted</i><sub>139</sub> | <i>double_quoted</i><sub>140</sub> | <i>here_doc</i><sub>?</sub> ;<p>
139. single_quoted =  <code><b>"'"</b></code> { <code><b>"\\\\"</b></code> | <code><b>"\\'"</b></code> | <code><b>"any char except '\\"</b></code> } <code><b>"'"</b></code> ;<p>
140. double_quoted =  <code><b>"\""</b></code> { <i>escaped_char</i><sub>141</sub> | <i>escaped_octal</i><sub>142</sub> | <i>escaped_hex</i><sub>143</sub> | <i>variable</i><sub>9</sub> | <code><b>"any char except \" \\ $"</b></code> } <code><b>"\""</b></code> ;<p>
141. escaped_char =  <code><b>"\\"</b></code> ( <code><b>"n"</b></code> | <code><b>"r"</b></code> | <code><b>"t"</b></code> | <code><b>"\\"</b></code> | <code><b>"$"</b></code> | <code><b>"{"</b></code> | <code><b>"\""</b></code> ) ;<p>
142. escaped_octal =  <code><b>"\\"</b></code> <i>digit8</i><sub>131</sub> [ <i>digit8</i><sub>131</sub> [ <i>digit8</i><sub>131</sub> ] ] ;<p>
143. escaped_hex =  <code><b>"\\"</b></code> ( <code><b>"x"</b></code> | <code><b>"X"</b></code> ) <i>digit16</i><sub>133</sub> [ <i>digit16</i><sub>133</sub> ] ;<p>
144. x_forward =  <code><b>"forward"</b></code> ;<p>
145. x_semicolon =  <code><b>";"</b></code> ;<p>
146. x_class =  <code><b>"class"</b></code> ;<p>
147. x_extends =  <code><b>"extends"</b></code> ;<p>
148. x_implements =  <code><b>"implements"</b></code> ;<p>
149. x_lround =  <code><b>"("</b></code> ;<p>
150. x_rround =  <code><b>")"</b></code> ;<p>
151. x_lsquare =  <code><b>"["</b></code> ;<p>
152. x_rsquare =  <code><b>"]"</b></code> ;<p>
153. x_lbrace =  <code><b>"{"</b></code> ;<p>
154. x_rbrace =  <code><b>"}"</b></code> ;<p>
155. x_colon =  <code><b>":"</b></code> ;<p>
156. x_function =  <code><b>"function"</b></code> ;<p>
157. x_return =  <code><b>"return"</b></code> ;<p>
158. x_by_ref =  <code><b>"&amp;"</b></code> ;<p>
159. x_throws =  <code><b>"throws"</b></code> ;<p>
160. x_eq =  <code><b>"="</b></code> ;<p>
161. x_args =  <code><b>"args"</b></code> ;<p>
162. x_comma =  <code><b>","</b></code> ;<p>
163. x_self =  <code><b>"self"</b></code> ;<p>
164. x_parent =  <code><b>"parent"</b></code> ;<p>
165. x_id =  <i>id</i><sub>14</sub> ;<p>
166. x_namespace_separator =  <code><b>"\\"</b></code> ;<p>
167. x_qualified_name =  [ <i>x_namespace_separator</i><sub>166</sub> ] <i>x_id</i><sub>165</sub> { <i>x_namespace_separator</i><sub>166</sub> <i>x_id</i><sub>165</sub> } ;<p>
168. x_formal_typecast =  <i>x_lround</i><sub>149</sub> <i>x_type</i><sub>170</sub> <i>x_rround</i><sub>150</sub> ;<p>
169. x_type_name =  <code><b>"void"</b></code> | <code><b>"boolean"</b></code> | <code><b>"int"</b></code> | <code><b>"integer"</b></code> | <code><b>"float"</b></code> | <code><b>"double"</b></code> | <code><b>"string"</b></code> | <code><b>"resource"</b></code> | <code><b>"mixed"</b></code> | <code><b>"object"</b></code> | <i>x_qualified_name</i><sub>167</sub> | <i>x_self</i><sub>163</sub> | <i>x_parent</i><sub>164</sub> ;<p>
170. x_type =  <i>x_type_name</i><sub>169</sub> { <i>x_index</i><sub>171</sub> } | <i>x_array</i><sub>175</sub> [ <i>x_index</i><sub>171</sub> { <i>x_index</i><sub>171</sub> } <i>x_type_name</i><sub>169</sub> ] ;<p>
171. x_index =  <i>x_lsquare</i><sub>151</sub> [ <i>x_int</i><sub>173</sub> | <i>x_string</i><sub>174</sub> ] <i>x_rsquare</i><sub>152</sub> ;<p>
172. x_require_module =  <code><b>"require_module"</b></code> ;<p>
173. x_int =  <code><b>"int"</b></code> ;<p>
174. x_string =  <code><b>"string"</b></code> ;<p>
175. x_array =  <code><b>"array"</b></code> ;<p>
176. x_variable =  <code><b>"$"</b></code> <i>id</i><sub>14</sub> ;<p>
177. x_single_quoted =  <code><b>"'"</b></code> { <code><b>"\\\\"</b></code> | <code><b>"\\'"</b></code> | <code><b>"any char except '\\"</b></code> } <code><b>"'"</b></code> ;<p>
<!--EBNF_END-->
<pre>

</pre>
<hr><center><i>The PHPLint Reference Manual ends here.</i></center></BODY></HTML>

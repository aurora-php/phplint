<?php

namespace it\icosaedro\bignumbers;

/*.
	require_module 'standard';
	require_module 'spl';
.*/

require_once __DIR__ . '/../../../autoload.php';
use it\icosaedro\bignumbers\BigInt;
use it\icosaedro\bignumbers\BigFloat;

/**
 *  Simple algebraic expression evaluator with arbitrary precision.
 *  
 *  This package demonstrates how the {@link BigFloat} class can be used
 *  to evaluate simple algebraic expressions. For example, input fields of
 *  a WEB form can be made clever enough to accept not only bare numbers,
 *  but also complete expressions.
 *
 *  @package ExprEval
 *  @author icosaedro.it di Umberto Salsi <salsi@icosaedro.it>
 *  @version $Date: 2012/01/22 19:26:26 $
 */


/*. private .*/ class ExprScanner
{
	const
		/* Trick to preserve basic version info also if source gets stripped: */
		UPDATES = 'http://www.icosaedro.it/bignumbers',
		VERSION = '$Date: 2012/01/22 19:26:26 $';

	/* Symbols generated by scanner: */
	const
		FLOAT_SYM = 1,
		MINUS_SYM = 100,
		PLUS_SYM = 101,
		MUL_SYM = 102,
		DIV_SYM = 103,
		REM_SYM = 104,
		LPAREN_SYM = 200,
		RPAREN_SYM = 201,
		END_SYM = 999;
	
	public $sym_num = /*. (BigFloat) .*/ NULL;
	
	private $expr = "";
	private $idx = 0;
	private $c = "";


	public /*. string .*/ function here()
	{
		return substr($this->expr, 0, $this->idx) . "<-- ";
	}


	private /*. void .*/ function getChar()
	{
		if( $this->idx >= strlen($this->expr) ){
			$this->c = NULL;
			return;
		}
		$this->c = $this->expr[ $this->idx++ ];
	}


	private /*. bool .*/ function isDigit()
	{
		return strcmp($this->c, "0") >= 0 and strcmp($this->c, "9") <= 0;
	}


	/*. int .*/ function getSym()
	{
		while( $this->c === " " )
			$this->getChar();

		$c = $this->c;
		if( $c === "-" ){
			$this->getChar();
			return self::MINUS_SYM;
		} else if( $c === "+" ){
			$this->getChar();
			return self::PLUS_SYM;
		} else if( $c === "*" ){
			$this->getChar();
			return self::MUL_SYM;
		} else if( $c === "/" ){
			$this->getChar();
			return self::DIV_SYM;
		} else if( $c === "%" ){
			$this->getChar();
			return self::REM_SYM;
		} else if( $c === "(" ){
			$this->getChar();
			return self::LPAREN_SYM;
		} else if( $c === ")" ){
			$this->getChar();
			return self::RPAREN_SYM;
		} else if( $this->isDigit() ){
			$n = $c;
			$this->getChar();
			while( $this->isDigit() ){
				$n .= $this->c;
				$this->getChar();
			}
			if( $this->c === "." ){
				$n .= ".";
				$this->getChar();
				if( ! $this->isDigit() )
					throw new \InvalidArgumentException($this->here() . "expected digits after decimal point");
				while( $this->isDigit() ){
					$n .= $this->c;
					$this->getChar();
				}
			}
			if( $this->c === "e" or $this->c === "E" ){
				$n .= "e";
				$this->getChar();
				if( $this->c === "+" or $this->c === "-" ){
					$n .= $this->c;
					$this->getChar();
				}
				if( ! $this->isDigit() )
					throw new \InvalidArgumentException($this->here() . "missing digits in exponent");
				while( $this->isDigit() ){
					$n .= $this->c;
					$this->getChar();
				}
			}
			$this->sym_num = new BigFloat($n);
			return self::FLOAT_SYM;

		} else if( $c === NULL ){
			return self::END_SYM;
		} else {
			throw new \InvalidArgumentException($this->here() ."unexpected character");
		}
	}


	/*. void .*/ function __construct(/*. string .*/ $expr)
	{
		$this->expr = $expr;
		$this->idx = 0;
		$this->getChar();
	}

}


class ExprEval
{
	private $p = /*. (ExprScanner) .*/ NULL;
	private $sym = 0;
	private $precision = 0;


	private /*. void .*/ function getSym()
	{
		$this->sym = $this->p->getSym();
	}


	/*. forward private BigFloat function expr()
	throws \InvalidArgumentException ; .*/


	private /*. BigFloat .*/ function factor()
	{
		if( $this->sym == ExprScanner::FLOAT_SYM ){
			$f = $this->p->sym_num;
			$this->getSym();
			return $f;

		} else if( $this->sym == ExprScanner::LPAREN_SYM ){
			$this->getSym();
			$f = $this->expr();
			if( $this->sym != ExprScanner::RPAREN_SYM )
				throw new \InvalidArgumentException($this->p->here() ."missing closing `)'");
			$this->getSym();
			return $f;

		} else {
			throw new \InvalidArgumentException($this->p->here() ."unexpected symbol");

		}
	}


	private /*. BigFloat .*/ function term()
	{
		$p = $this->factor();

		do {
			if( $this->sym == ExprScanner::MUL_SYM ){
				$this->getSym();
				$p = $p->mul( $this->factor() );

			} else if( $this->sym == ExprScanner::DIV_SYM ){
				$this->getSym();
				$p = $p->div( $this->factor(), $this->precision-1 )
					->round($this->precision);

			} else if( $this->sym == ExprScanner::REM_SYM ){
				$this->getSym();
				$ignore = $p->div_rem( $this->factor(), 0, $p );

			} else {
				return $p;
			}
		} while( TRUE );
	}


	private /*. BigFloat .*/ function expr()
	{
		if( $this->sym == ExprScanner::PLUS_SYM ){
			$this->getSym();
			$s = $this->term();
		} else if( $this->sym == ExprScanner::MINUS_SYM ){
			$this->getSym();
			$s = $this->term()->minus();
		} else {
			$s = $this->term();
		}

		do {
			if( $this->sym == ExprScanner::PLUS_SYM ){
				$this->getSym();
				$s = $s->add( $this->term() );
			} else if( $this->sym == ExprScanner::MINUS_SYM ){
				$this->getSym();
				$s = $s->sub( $this->term() );
			} else {
				return $s;
			}
		} while( TRUE );
	}


	private /*. void .*/ function __construct(/*. string .*/ $expr)
	{
		$this->p = new ExprScanner($expr);
		$this->getSym();
	}


	/**
	 *  Evaluate a simple algebraic expression.
	 *  
	 *  An expression can be as simple as a fractional number, but
	 *  arithmetic operators <code>+ -  /</code>, the remainder operator
	 *  <code>%</code> and sub-expressions are also allowed. Spaces
	 *  between numbers and operators are ignored. Calculations are
	 *  performed with the class BigFloat.
	 *  
	 *  The syntax of an expression, spaces apart, can be expressed
	 *  in EBNF notation as follows:
	 *  
	 *  <pre>
	 *      expr = ["+"|"-"] term { ("+"|"-") term };
	 *      term = factor { (""|"/"|"%") factor };
	 *      factor = BigFloat | "(" expr ")";
	 *  </pre>
	 *  
	 *  Examples:
	 *  
	 *  <pre>
	 *      ExprEval::value("1/3", -5)  gives 0.33333
	 *      ExprEval::value("2  (0.57 - 0.56)", -2) gives 0.02
	 *  </pre>
	 *  
	 *  @param string $expr  The algebraic expression to be evaluated.
	 *  @param int $precision  Values resulting from divisions are
	 *         rounded to 10e$precision so to get two decimal digits
	 *         $precision must be set to -2.
	 *  @return BigFloat  The result of the evaluation.
	 *  @throws \InvalidArgumentException  if the expression contains
	 *          syntactical errors and on division by zero.
	 */
	static function value($expr, $precision)
	{
		$e = new ExprEval($expr);
		$e->precision = $precision;

		$f = $e->expr();
		if( $e->sym != ExprScanner::END_SYM )
			throw new \InvalidArgumentException($e->p->here() ."invalid symbol");

		return $f;
	}

}
